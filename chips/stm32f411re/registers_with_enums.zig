// this file was generated by cgen/registers.rb
pub const registers = struct {
    /// ADC common registers
    pub const adc_common = struct {
        pub const base_address = 0x40012300;

        /// address: 0x40012304
        /// ADC common control register
        pub const Ccr = packed struct {
            pub const Adcpre = enum(u2) {
                div2 = 0b00, // PCLK2 divided by 2
                div4 = 0b01, // PCLK2 divided by 4
                div6 = 0b10, // PCLK2 divided by 6
                div8 = 0b11, // PCLK2 divided by 8
            };
            pub const Vbate = enum(u1) {
                disabled = 0, // V_BAT channel disabled
                enabled = 1, // V_BAT channel enabled
            };
            pub const Tsvrefe = enum(u1) {
                disabled = 0, // Temperature sensor and V_REFINT channel disabled
                enabled = 1, // Temperature sensor and V_REFINT channel enabled
            };
            _reserved_0_15: u16,
            adcpre: Adcpre, // ADC prescaler (u2)
            _reserved_18_21: u4,
            vbate: Vbate, // VBAT enable (u1)
            tsvrefe: Tsvrefe, // Temperature sensor and VREFINT enable (u1)
            _padding_24_31: u8,
        };
        pub const ccr = mmio(base_address + 0x4, 32, Ccr);
    };
    /// Analog-to-digital converter
    pub const adc1 = struct {
        pub const base_address = 0x40012000;

        /// address: 0x40012000
        /// status register
        pub const Sr = packed struct {
            pub const Awd = enum(u1) {
                no_event = 0, // No analog watchdog event occurred
                event = 1, // Analog watchdog event occurred
            };
            pub const Eoc = enum(u1) {
                not_complete = 0, // Conversion is not complete
                complete = 1, // Conversion complete
            };
            pub const Jeoc = enum(u1) {
                not_complete = 0, // Conversion is not complete
                complete = 1, // Conversion complete
            };
            pub const Jstrt = enum(u1) {
                not_started = 0, // No injected channel conversion started
                started = 1, // Injected channel conversion has started
            };
            pub const Strt = enum(u1) {
                not_started = 0, // No regular channel conversion started
                started = 1, // Regular channel conversion has started
            };
            pub const Ovr = enum(u1) {
                no_overrun = 0, // No overrun occurred
                overrun = 1, // Overrun occurred
            };
            awd: Awd, // Analog watchdog flag (u1)
            eoc: Eoc, // Regular channel end of conversion (u1)
            jeoc: Jeoc, // Injected channel end of conversion (u1)
            jstrt: Jstrt, // Injected channel start flag (u1)
            strt: Strt, // Regular channel start flag (u1)
            ovr: Ovr, // Overrun (u1)
            _padding_6_31: u26,
        };
        pub const sr = mmio(base_address + 0x0, 32, Sr);

        /// address: 0x40012004
        /// control register 1
        pub const Cr1 = packed struct {
            pub const Eocie = enum(u1) {
                disabled = 0, // EOC interrupt disabled
                enabled = 1, // EOC interrupt enabled
            };
            pub const Awdie = enum(u1) {
                disabled = 0, // Analogue watchdog interrupt disabled
                enabled = 1, // Analogue watchdog interrupt enabled
            };
            pub const Jeocie = enum(u1) {
                disabled = 0, // JEOC interrupt disabled
                enabled = 1, // JEOC interrupt enabled
            };
            pub const Scan = enum(u1) {
                disabled = 0, // Scan mode disabled
                enabled = 1, // Scan mode enabled
            };
            pub const Awdsgl = enum(u1) {
                all_channels = 0, // Analog watchdog enabled on all channels
                single_channel = 1, // Analog watchdog enabled on a single channel
            };
            pub const Jauto = enum(u1) {
                disabled = 0, // Automatic injected group conversion disabled
                enabled = 1, // Automatic injected group conversion enabled
            };
            pub const Discen = enum(u1) {
                disabled = 0, // Discontinuous mode on regular channels disabled
                enabled = 1, // Discontinuous mode on regular channels enabled
            };
            pub const Jdiscen = enum(u1) {
                disabled = 0, // Discontinuous mode on injected channels disabled
                enabled = 1, // Discontinuous mode on injected channels enabled
            };
            pub const Jawden = enum(u1) {
                disabled = 0, // Analog watchdog disabled on injected channels
                enabled = 1, // Analog watchdog enabled on injected channels
            };
            pub const Awden = enum(u1) {
                disabled = 0, // Analog watchdog disabled on regular channels
                enabled = 1, // Analog watchdog enabled on regular channels
            };
            pub const Res = enum(u2) {
                twelve_bit = 0b00, // 12-bit (15 ADCCLK cycles)
                ten_bit = 0b01, // 10-bit (13 ADCCLK cycles)
                eight_bit = 0b10, // 8-bit (11 ADCCLK cycles)
                six_bit = 0b11, // 6-bit (9 ADCCLK cycles)
            };
            pub const Ovrie = enum(u1) {
                disabled = 0, // Overrun interrupt disabled
                enabled = 1, // Overrun interrupt enabled
            };
            awdch: u5, // Analog watchdog channel select bits
            eocie: Eocie, // Interrupt enable for EOC (u1)
            awdie: Awdie, // Analog watchdog interrupt enable (u1)
            jeocie: Jeocie, // Interrupt enable for injected channels (u1)
            scan: Scan, // Scan mode (u1)
            awdsgl: Awdsgl, // Enable the watchdog on a single channel in scan mode (u1)
            jauto: Jauto, // Automatic injected group conversion (u1)
            discen: Discen, // Discontinuous mode on regular channels (u1)
            jdiscen: Jdiscen, // Discontinuous mode on injected channels (u1)
            discnum: u3, // Discontinuous mode channel count
            _reserved_16_21: u6,
            jawden: Jawden, // Analog watchdog enable on injected channels (u1)
            awden: Awden, // Analog watchdog enable on regular channels (u1)
            res: Res, // Resolution (u2)
            ovrie: Ovrie, // Overrun interrupt enable (u1)
            _padding_27_31: u5,
        };
        pub const cr1 = mmio(base_address + 0x4, 32, Cr1);

        /// address: 0x40012008
        /// control register 2
        pub const Cr2 = packed struct {
            pub const Adon = enum(u1) {
                disabled = 0, // Disable ADC conversion and go to power down mode
                enabled = 1, // Enable ADC
            };
            pub const Cont = enum(u1) {
                single = 0, // Single conversion mode
                continuous = 1, // Continuous conversion mode
            };
            pub const Dma = enum(u1) {
                disabled = 0, // DMA mode disabled
                enabled = 1, // DMA mode enabled
            };
            pub const Dds = enum(u1) {
                single = 0, // No new DMA request is issued after the last transfer
                continuous = 1, // DMA requests are issued as long as data are converted and DMA=1
            };
            pub const Eocs = enum(u1) {
                each_sequence = 0, // The EOC bit is set at the end of each sequence of regular conversions
                each_conversion = 1, // The EOC bit is set at the end of each regular conversion
            };
            pub const Align = enum(u1) {
                right = 0, // Right alignment
                left = 1, // Left alignment
            };
            pub const Jextsel = enum(u4) {
                tim1_cc4 = 0b0000, // Timer 1 CC4 event
                tim1_trgo = 0b0001, // Timer 1 TRGO event
                tim2_cc1 = 0b0010, // Timer 2 CC1 event
                tim2_trgo = 0b0011, // Timer 2 TRGO event
                tim3_cc2 = 0b0100, // Timer 3 CC2 event
                tim3_cc4 = 0b0101, // Timer 3 CC4 event
                tim4_cc1 = 0b0110, // Timer 4 CC1 event
                tim4_cc2 = 0b0111, // Timer 4 CC2 event
                tim4_cc3 = 0b1000, // Timer 4 CC3 event
                tim4_trgo = 0b1001, // Timer 4 TRGO event
                tim5_cc4 = 0b1010, // Timer 5 CC4 event
                tim5_trgo = 0b1011, // Timer 5 TRGO event
                exti15 = 0b1111, // EXTI line 15
            };
            pub const Jexten = enum(u2) {
                disabled = 0b00, // Trigger detection disabled
                rising_edge = 0b01, // Trigger detection on the rising edge
                falling_edge = 0b10, // Trigger detection on the falling edge
                both_edges = 0b11, // Trigger detection on both the rising and falling edges
            };
            pub const Jswstartw = enum(u1) {
                start = 1, // Starts conversion of injected channels
            };
            pub const Extsel = enum(u4) {
                tim1_cc1 = 0b0000, // Timer 1 CC1 event
                tim1_cc2 = 0b0001, // Timer 1 CC2 event
                tim1_cc3 = 0b0010, // Timer 1 CC3 event
                tim2_cc2 = 0b0011, // Timer 2 CC2 event
                tim2_cc3 = 0b0100, // Timer 2 CC3 event
                tim2_cc4 = 0b0101, // Timer 2 CC4 event
                tim2_trgo = 0b0110, // Timer 2 TRGO event
                tim3_cc1 = 0b0111, // Timer 3 CC1 event
                tim3_trgo = 0b1000, // Timer 3 TRGO event
                tim4_cc4 = 0b1001, // Timer 4 CC4 event
                tim5_cc1 = 0b1010, // Timer 5 CC1 event
                tim5_cc2 = 0b1011, // Timer 5 CC2 event
                tim5_cc3 = 0b1100, // Timer 5 CC3 event
                exti11 = 0b1111, // EXTI line 11
            };
            pub const Exten = enum(u2) {
                disabled = 0b00, // Trigger detection disabled
                rising_edge = 0b01, // Trigger detection on the rising edge
                falling_edge = 0b10, // Trigger detection on the falling edge
                both_edges = 0b11, // Trigger detection on both the rising and falling edges
            };
            pub const Swstartw = enum(u1) {
                start = 1, // Starts conversion of regular channels
            };
            adon: Adon, // A/D Converter ON / OFF (u1)
            cont: Cont, // Continuous conversion (u1)
            _reserved_2_7: u6,
            dma: Dma, // Direct memory access mode (for single ADC mode) (u1)
            dds: Dds, // DMA disable selection (for single ADC mode) (u1)
            eocs: Eocs, // End of conversion selection (u1)
            @"align": Align, // Data alignment (u1)
            _reserved_12_15: u4,
            jextsel: Jextsel, // External event select for injected group (u4)
            jexten: Jexten, // External trigger enable for injected channels (u2)
            jswstart: Jswstartw, // Start conversion of injected channels (u1)
            _reserved_23_23: u1,
            extsel: Extsel, // External event select for regular group (u4)
            exten: Exten, // External trigger enable for regular channels (u2)
            swstart: Swstartw, // Start conversion of regular channels (u1)
            _padding_31_31: u1,
        };
        pub const cr2 = mmio(base_address + 0x8, 32, Cr2);

        /// address: 0x4001200c
        /// sample time register 1
        pub const Smpr1 = packed struct {
            pub const SmpxX = enum(u3) {
                cycles3 = 0b000, // 3 cycles
                cycles15 = 0b001, // 15 cycles
                cycles28 = 0b010, // 28 cycles
                cycles56 = 0b011, // 56 cycles
                cycles84 = 0b100, // 84 cycles
                cycles112 = 0b101, // 112 cycles
                cycles144 = 0b110, // 144 cycles
                cycles480 = 0b111, // 480 cycles
            };
            smp10: u3, // Channel 10 sampling time selection
            smp11: u3, // Channel 11 sampling time selection
            smp12: u3, // Channel 12 sampling time selection
            smp13: u3, // Channel 13 sampling time selection
            smp14: u3, // Channel 14 sampling time selection
            smp15: u3, // Channel 15 sampling time selection
            smp16: u3, // Channel 16 sampling time selection
            smp17: u3, // Channel 17 sampling time selection
            smp18: SmpxX, // Channel 18 sampling time selection (u3)
            _padding_27_31: u5,
        };
        pub const smpr1 = mmio(base_address + 0xc, 32, Smpr1);

        /// address: 0x40012010
        /// sample time register 2
        pub const Smpr2 = packed struct {
            pub const SmpxX = enum(u3) {
                cycles3 = 0b000, // 3 cycles
                cycles15 = 0b001, // 15 cycles
                cycles28 = 0b010, // 28 cycles
                cycles56 = 0b011, // 56 cycles
                cycles84 = 0b100, // 84 cycles
                cycles112 = 0b101, // 112 cycles
                cycles144 = 0b110, // 144 cycles
                cycles480 = 0b111, // 480 cycles
            };
            smp0: u3, // Channel 0 sampling time selection
            smp1: u3, // Channel 1 sampling time selection
            smp2: u3, // Channel 2 sampling time selection
            smp3: u3, // Channel 3 sampling time selection
            smp4: u3, // Channel 4 sampling time selection
            smp5: u3, // Channel 5 sampling time selection
            smp6: u3, // Channel 6 sampling time selection
            smp7: u3, // Channel 7 sampling time selection
            smp8: u3, // Channel 8 sampling time selection
            smp9: SmpxX, // Channel 9 sampling time selection (u3)
            _padding_30_31: u2,
        };
        pub const smpr2 = mmio(base_address + 0x10, 32, Smpr2);

        /// address: 0x40012014
        /// injected channel data offset register x
        pub const Jofr1 = packed struct {
            joffset: u12, // Data offset for injected channel x
            _padding_12_31: u20,
        };
        pub const jofr1 = mmio(base_address + 0x14, 32, Jofr1);

        /// address: 0x40012018
        /// injected channel data offset register x
        pub const Jofr2 = packed struct {
            joffset: u12, // Data offset for injected channel x
            _padding_12_31: u20,
        };
        pub const jofr2 = mmio(base_address + 0x18, 32, Jofr2);

        /// address: 0x4001201c
        /// injected channel data offset register x
        pub const Jofr3 = packed struct {
            joffset: u12, // Data offset for injected channel x
            _padding_12_31: u20,
        };
        pub const jofr3 = mmio(base_address + 0x1c, 32, Jofr3);

        /// address: 0x40012020
        /// injected channel data offset register x
        pub const Jofr4 = packed struct {
            joffset: u12, // Data offset for injected channel x
            _padding_12_31: u20,
        };
        pub const jofr4 = mmio(base_address + 0x20, 32, Jofr4);

        /// address: 0x40012024
        /// watchdog higher threshold register
        pub const Htr = packed struct {
            ht: u12, // Analog watchdog higher threshold
            _padding_12_31: u20,
        };
        pub const htr = mmio(base_address + 0x24, 32, Htr);

        /// address: 0x40012028
        /// watchdog lower threshold register
        pub const Ltr = packed struct {
            lt: u12, // Analog watchdog lower threshold
            _padding_12_31: u20,
        };
        pub const ltr = mmio(base_address + 0x28, 32, Ltr);

        /// address: 0x4001202c
        /// regular sequence register 1
        pub const Sqr1 = packed struct {
            sq13: u5, // 13th conversion in regular sequence
            sq14: u5, // 14th conversion in regular sequence
            sq15: u5, // 15th conversion in regular sequence
            sq16: u5, // 16th conversion in regular sequence
            l: u4, // Regular channel sequence length
            _padding_24_31: u8,
        };
        pub const sqr1 = mmio(base_address + 0x2c, 32, Sqr1);

        /// address: 0x40012030
        /// regular sequence register 2
        pub const Sqr2 = packed struct {
            sq7: u5, // 7th conversion in regular sequence
            sq8: u5, // 8th conversion in regular sequence
            sq9: u5, // 9th conversion in regular sequence
            sq10: u5, // 10th conversion in regular sequence
            sq11: u5, // 11th conversion in regular sequence
            sq12: u5, // 12th conversion in regular sequence
            _padding_30_31: u2,
        };
        pub const sqr2 = mmio(base_address + 0x30, 32, Sqr2);

        /// address: 0x40012034
        /// regular sequence register 3
        pub const Sqr3 = packed struct {
            sq1: u5, // 1st conversion in regular sequence
            sq2: u5, // 2nd conversion in regular sequence
            sq3: u5, // 3rd conversion in regular sequence
            sq4: u5, // 4th conversion in regular sequence
            sq5: u5, // 5th conversion in regular sequence
            sq6: u5, // 6th conversion in regular sequence
            _padding_30_31: u2,
        };
        pub const sqr3 = mmio(base_address + 0x34, 32, Sqr3);

        /// address: 0x40012038
        /// injected sequence register
        pub const Jsqr = packed struct {
            jsq1: u5, // 1st conversion in injected sequence
            jsq2: u5, // 2nd conversion in injected sequence
            jsq3: u5, // 3rd conversion in injected sequence
            jsq4: u5, // 4th conversion in injected sequence
            jl: u2, // Injected sequence length
            _padding_22_31: u10,
        };
        pub const jsqr = mmio(base_address + 0x38, 32, Jsqr);

        /// address: 0x4001203c
        /// injected data register x
        pub const Jdr1 = packed struct {
            jdata: u16, // Injected data
            _padding_16_31: u16,
        };
        pub const jdr1 = mmio(base_address + 0x3c, 32, Jdr1);

        /// address: 0x40012040
        /// injected data register x
        pub const Jdr2 = packed struct {
            jdata: u16, // Injected data
            _padding_16_31: u16,
        };
        pub const jdr2 = mmio(base_address + 0x40, 32, Jdr2);

        /// address: 0x40012044
        /// injected data register x
        pub const Jdr3 = packed struct {
            jdata: u16, // Injected data
            _padding_16_31: u16,
        };
        pub const jdr3 = mmio(base_address + 0x44, 32, Jdr3);

        /// address: 0x40012048
        /// injected data register x
        pub const Jdr4 = packed struct {
            jdata: u16, // Injected data
            _padding_16_31: u16,
        };
        pub const jdr4 = mmio(base_address + 0x48, 32, Jdr4);

        /// address: 0x4001204c
        /// regular data register
        pub const Dr = packed struct {
            data: u16, // Regular data
            _padding_16_31: u16,
        };
        pub const dr = mmio(base_address + 0x4c, 32, Dr);
    };
    /// Cryptographic processor
    pub const crc = struct {
        pub const base_address = 0x40023000;

        /// address: 0x40023000
        /// Data register
        pub const dr = @intToPtr(*volatile u32, base_address + 0x0);

        /// address: 0x40023004
        /// Independent Data register
        pub const idr = mmioInt(base_address + 0x4, 32, u8);

        /// address: 0x40023008
        /// Control register
        pub const Cr = packed struct {
            pub const Resetw = enum(u1) {
                reset = 1, // Resets the CRC calculation unit and sets the data register to 0xFFFF FFFF
            };
            reset: Resetw, // Control regidter (u1)
            _padding_1_31: u31,
        };
        pub const cr = mmio(base_address + 0x8, 32, Cr);
    };
    /// Debug support
    pub const dbgmcu = struct {
        pub const base_address = 0xe0042000;

        /// address: 0xe0042000
        /// IDCODE
        pub const Idcode = packed struct {
            dev_id: u12, // DEV_ID
            _reserved_12_15: u4,
            rev_id: u16, // REV_ID
        };
        pub const idcode = mmio(base_address + 0x0, 32, Idcode);

        /// address: 0xe0042004
        /// Control Register
        pub const Cr = packed struct {
            dbg_sleep: u1, // DBG_SLEEP
            dbg_stop: u1, // DBG_STOP
            dbg_standby: u1, // DBG_STANDBY
            _reserved_3_4: u2,
            trace_ioen: u1, // TRACE_IOEN
            trace_mode: u2, // TRACE_MODE
            _padding_8_31: u24,
        };
        pub const cr = mmio(base_address + 0x4, 32, Cr);

        /// address: 0xe0042008
        /// Debug MCU APB1 Freeze registe
        pub const Apb1Fz = packed struct {
            dbg_tim2_stop: u1, // DBG_TIM2_STOP
            dbg_tim3_stop: u1, // DBG_TIM3 _STOP
            dbg_tim4_stop: u1, // DBG_TIM4_STOP
            dbg_tim5_stop: u1, // DBG_TIM5_STOP
            _reserved_4_9: u6,
            dbg_rtc_stop: u1, // RTC stopped when Core is halted
            dbg_wwdg_stop: u1, // DBG_WWDG_STOP
            dbg_iwdg_stop: u1, // DBG_IWDEG_STOP
            _reserved_13_20: u8,
            dbg_i2c1_smbus_timeout: u1, // DBG_J2C1_SMBUS_TIMEOUT
            dbg_i2c2_smbus_timeout: u1, // DBG_J2C2_SMBUS_TIMEOUT
            dbg_i2c3smbus_timeout: u1, // DBG_J2C3SMBUS_TIMEOUT
            _padding_24_31: u8,
        };
        pub const apb1_fz = mmio(base_address + 0x8, 32, Apb1Fz);

        /// address: 0xe004200c
        /// Debug MCU APB2 Freeze registe
        pub const Apb2Fz = packed struct {
            dbg_tim1_stop: u1, // TIM1 counter stopped when core is halted
            _reserved_1_15: u15,
            dbg_tim9_stop: u1, // TIM9 counter stopped when core is halted
            dbg_tim10_stop: u1, // TIM10 counter stopped when core is halted
            dbg_tim11_stop: u1, // TIM11 counter stopped when core is halted
            _padding_19_31: u13,
        };
        pub const apb2_fz = mmio(base_address + 0xc, 32, Apb2Fz);
    };
    /// External interrupt/event controller
    pub const exti = struct {
        pub const base_address = 0x40013c00;

        /// address: 0x40013c00
        /// Interrupt mask register (EXTI_IMR)
        pub const Imr = packed struct {
            pub const Mr0 = enum(u1) {
                masked = 0, // Interrupt request line is masked
                unmasked = 1, // Interrupt request line is unmasked
            };
            mr0: Mr0, // Interrupt Mask on line 0 (u1)
            mr1: Mr0, // Interrupt Mask on line 1 (u1)
            mr2: Mr0, // Interrupt Mask on line 2 (u1)
            mr3: Mr0, // Interrupt Mask on line 3 (u1)
            mr4: Mr0, // Interrupt Mask on line 4 (u1)
            mr5: Mr0, // Interrupt Mask on line 5 (u1)
            mr6: Mr0, // Interrupt Mask on line 6 (u1)
            mr7: Mr0, // Interrupt Mask on line 7 (u1)
            mr8: Mr0, // Interrupt Mask on line 8 (u1)
            mr9: Mr0, // Interrupt Mask on line 9 (u1)
            mr10: Mr0, // Interrupt Mask on line 10 (u1)
            mr11: Mr0, // Interrupt Mask on line 11 (u1)
            mr12: Mr0, // Interrupt Mask on line 12 (u1)
            mr13: Mr0, // Interrupt Mask on line 13 (u1)
            mr14: Mr0, // Interrupt Mask on line 14 (u1)
            mr15: Mr0, // Interrupt Mask on line 15 (u1)
            mr16: Mr0, // Interrupt Mask on line 16 (u1)
            mr17: Mr0, // Interrupt Mask on line 17 (u1)
            mr18: Mr0, // Interrupt Mask on line 18 (u1)
            mr19: Mr0, // Interrupt Mask on line 19 (u1)
            mr20: Mr0, // Interrupt Mask on line 20 (u1)
            mr21: Mr0, // Interrupt Mask on line 21 (u1)
            mr22: Mr0, // Interrupt Mask on line 22 (u1)
            _padding_23_31: u9,
        };
        pub const imr = mmio(base_address + 0x0, 32, Imr);

        /// address: 0x40013c04
        /// Event mask register (EXTI_EMR)
        pub const Emr = packed struct {
            pub const Mr0 = enum(u1) {
                masked = 0, // Interrupt request line is masked
                unmasked = 1, // Interrupt request line is unmasked
            };
            mr0: Mr0, // Event Mask on line 0 (u1)
            mr1: Mr0, // Event Mask on line 1 (u1)
            mr2: Mr0, // Event Mask on line 2 (u1)
            mr3: Mr0, // Event Mask on line 3 (u1)
            mr4: Mr0, // Event Mask on line 4 (u1)
            mr5: Mr0, // Event Mask on line 5 (u1)
            mr6: Mr0, // Event Mask on line 6 (u1)
            mr7: Mr0, // Event Mask on line 7 (u1)
            mr8: Mr0, // Event Mask on line 8 (u1)
            mr9: Mr0, // Event Mask on line 9 (u1)
            mr10: Mr0, // Event Mask on line 10 (u1)
            mr11: Mr0, // Event Mask on line 11 (u1)
            mr12: Mr0, // Event Mask on line 12 (u1)
            mr13: Mr0, // Event Mask on line 13 (u1)
            mr14: Mr0, // Event Mask on line 14 (u1)
            mr15: Mr0, // Event Mask on line 15 (u1)
            mr16: Mr0, // Event Mask on line 16 (u1)
            mr17: Mr0, // Event Mask on line 17 (u1)
            mr18: Mr0, // Event Mask on line 18 (u1)
            mr19: Mr0, // Event Mask on line 19 (u1)
            mr20: Mr0, // Event Mask on line 20 (u1)
            mr21: Mr0, // Event Mask on line 21 (u1)
            mr22: Mr0, // Event Mask on line 22 (u1)
            _padding_23_31: u9,
        };
        pub const emr = mmio(base_address + 0x4, 32, Emr);

        /// address: 0x40013c08
        /// Rising Trigger selection register (EXTI_RTSR)
        pub const Rtsr = packed struct {
            pub const Tr0 = enum(u1) {
                disabled = 0, // Rising edge trigger is disabled
                enabled = 1, // Rising edge trigger is enabled
            };
            tr0: Tr0, // Rising trigger event configuration of line 0 (u1)
            tr1: Tr0, // Rising trigger event configuration of line 1 (u1)
            tr2: Tr0, // Rising trigger event configuration of line 2 (u1)
            tr3: Tr0, // Rising trigger event configuration of line 3 (u1)
            tr4: Tr0, // Rising trigger event configuration of line 4 (u1)
            tr5: Tr0, // Rising trigger event configuration of line 5 (u1)
            tr6: Tr0, // Rising trigger event configuration of line 6 (u1)
            tr7: Tr0, // Rising trigger event configuration of line 7 (u1)
            tr8: Tr0, // Rising trigger event configuration of line 8 (u1)
            tr9: Tr0, // Rising trigger event configuration of line 9 (u1)
            tr10: Tr0, // Rising trigger event configuration of line 10 (u1)
            tr11: Tr0, // Rising trigger event configuration of line 11 (u1)
            tr12: Tr0, // Rising trigger event configuration of line 12 (u1)
            tr13: Tr0, // Rising trigger event configuration of line 13 (u1)
            tr14: Tr0, // Rising trigger event configuration of line 14 (u1)
            tr15: Tr0, // Rising trigger event configuration of line 15 (u1)
            tr16: Tr0, // Rising trigger event configuration of line 16 (u1)
            tr17: Tr0, // Rising trigger event configuration of line 17 (u1)
            tr18: Tr0, // Rising trigger event configuration of line 18 (u1)
            tr19: Tr0, // Rising trigger event configuration of line 19 (u1)
            tr20: Tr0, // Rising trigger event configuration of line 20 (u1)
            tr21: Tr0, // Rising trigger event configuration of line 21 (u1)
            tr22: Tr0, // Rising trigger event configuration of line 22 (u1)
            _padding_23_31: u9,
        };
        pub const rtsr = mmio(base_address + 0x8, 32, Rtsr);

        /// address: 0x40013c0c
        /// Falling Trigger selection register (EXTI_FTSR)
        pub const Ftsr = packed struct {
            pub const Tr0 = enum(u1) {
                disabled = 0, // Falling edge trigger is disabled
                enabled = 1, // Falling edge trigger is enabled
            };
            tr0: Tr0, // Falling trigger event configuration of line 0 (u1)
            tr1: Tr0, // Falling trigger event configuration of line 1 (u1)
            tr2: Tr0, // Falling trigger event configuration of line 2 (u1)
            tr3: Tr0, // Falling trigger event configuration of line 3 (u1)
            tr4: Tr0, // Falling trigger event configuration of line 4 (u1)
            tr5: Tr0, // Falling trigger event configuration of line 5 (u1)
            tr6: Tr0, // Falling trigger event configuration of line 6 (u1)
            tr7: Tr0, // Falling trigger event configuration of line 7 (u1)
            tr8: Tr0, // Falling trigger event configuration of line 8 (u1)
            tr9: Tr0, // Falling trigger event configuration of line 9 (u1)
            tr10: Tr0, // Falling trigger event configuration of line 10 (u1)
            tr11: Tr0, // Falling trigger event configuration of line 11 (u1)
            tr12: Tr0, // Falling trigger event configuration of line 12 (u1)
            tr13: Tr0, // Falling trigger event configuration of line 13 (u1)
            tr14: Tr0, // Falling trigger event configuration of line 14 (u1)
            tr15: Tr0, // Falling trigger event configuration of line 15 (u1)
            tr16: Tr0, // Falling trigger event configuration of line 16 (u1)
            tr17: Tr0, // Falling trigger event configuration of line 17 (u1)
            tr18: Tr0, // Falling trigger event configuration of line 18 (u1)
            tr19: Tr0, // Falling trigger event configuration of line 19 (u1)
            tr20: Tr0, // Falling trigger event configuration of line 20 (u1)
            tr21: Tr0, // Falling trigger event configuration of line 21 (u1)
            tr22: Tr0, // Falling trigger event configuration of line 22 (u1)
            _padding_23_31: u9,
        };
        pub const ftsr = mmio(base_address + 0xc, 32, Ftsr);

        /// address: 0x40013c10
        /// Software interrupt event register (EXTI_SWIER)
        pub const Swier = packed struct {
            pub const Swier0w = enum(u1) {
                pend = 1, // Generates an interrupt request
            };
            swier0: Swier0w, // Software Interrupt on line 0 (u1)
            swier1: Swier0w, // Software Interrupt on line 1 (u1)
            swier2: Swier0w, // Software Interrupt on line 2 (u1)
            swier3: Swier0w, // Software Interrupt on line 3 (u1)
            swier4: Swier0w, // Software Interrupt on line 4 (u1)
            swier5: Swier0w, // Software Interrupt on line 5 (u1)
            swier6: Swier0w, // Software Interrupt on line 6 (u1)
            swier7: Swier0w, // Software Interrupt on line 7 (u1)
            swier8: Swier0w, // Software Interrupt on line 8 (u1)
            swier9: Swier0w, // Software Interrupt on line 9 (u1)
            swier10: Swier0w, // Software Interrupt on line 10 (u1)
            swier11: Swier0w, // Software Interrupt on line 11 (u1)
            swier12: Swier0w, // Software Interrupt on line 12 (u1)
            swier13: Swier0w, // Software Interrupt on line 13 (u1)
            swier14: Swier0w, // Software Interrupt on line 14 (u1)
            swier15: Swier0w, // Software Interrupt on line 15 (u1)
            swier16: Swier0w, // Software Interrupt on line 16 (u1)
            swier17: Swier0w, // Software Interrupt on line 17 (u1)
            swier18: Swier0w, // Software Interrupt on line 18 (u1)
            swier19: Swier0w, // Software Interrupt on line 19 (u1)
            swier20: Swier0w, // Software Interrupt on line 20 (u1)
            swier21: Swier0w, // Software Interrupt on line 21 (u1)
            swier22: Swier0w, // Software Interrupt on line 22 (u1)
            _padding_23_31: u9,
        };
        pub const swier = mmio(base_address + 0x10, 32, Swier);

        /// address: 0x40013c14
        /// Pending register (EXTI_PR)
        pub const Pr = packed struct {
            pub const Pr0 = enum(u1) {
                not_pending = 0, // No trigger request occurred
                pending = 1, // Selected trigger request occurred
                pub const clear = @intToEnum(Pr0, 1); // Clears pending bit
            };
            pr0: Pr0, // Pending bit 0 (u1)
            pr1: Pr0, // Pending bit 1 (u1)
            pr2: Pr0, // Pending bit 2 (u1)
            pr3: Pr0, // Pending bit 3 (u1)
            pr4: Pr0, // Pending bit 4 (u1)
            pr5: Pr0, // Pending bit 5 (u1)
            pr6: Pr0, // Pending bit 6 (u1)
            pr7: Pr0, // Pending bit 7 (u1)
            pr8: Pr0, // Pending bit 8 (u1)
            pr9: Pr0, // Pending bit 9 (u1)
            pr10: Pr0, // Pending bit 10 (u1)
            pr11: Pr0, // Pending bit 11 (u1)
            pr12: Pr0, // Pending bit 12 (u1)
            pr13: Pr0, // Pending bit 13 (u1)
            pr14: Pr0, // Pending bit 14 (u1)
            pr15: Pr0, // Pending bit 15 (u1)
            pr16: Pr0, // Pending bit 16 (u1)
            pr17: Pr0, // Pending bit 17 (u1)
            pr18: Pr0, // Pending bit 18 (u1)
            pr19: Pr0, // Pending bit 19 (u1)
            pr20: Pr0, // Pending bit 20 (u1)
            pr21: Pr0, // Pending bit 21 (u1)
            pr22: Pr0, // Pending bit 22 (u1)
            _padding_23_31: u9,
        };
        pub const pr = mmio(base_address + 0x14, 32, Pr);
    };
    /// FLASH
    pub const flash = struct {
        pub const base_address = 0x40023c00;

        /// address: 0x40023c00
        /// Flash access control register
        pub const Acr = packed struct {
            pub const Latency = enum(u4) {
                ws0 = 0b0000, // 0 wait states
                ws1 = 0b0001, // 1 wait states
                ws2 = 0b0010, // 2 wait states
                ws3 = 0b0011, // 3 wait states
                ws4 = 0b0100, // 4 wait states
                ws5 = 0b0101, // 5 wait states
                ws6 = 0b0110, // 6 wait states
                ws7 = 0b0111, // 7 wait states
                ws8 = 0b1000, // 8 wait states
                ws9 = 0b1001, // 9 wait states
                ws10 = 0b1010, // 10 wait states
                ws11 = 0b1011, // 11 wait states
                ws12 = 0b1100, // 12 wait states
                ws13 = 0b1101, // 13 wait states
                ws14 = 0b1110, // 14 wait states
                ws15 = 0b1111, // 15 wait states
            };
            pub const Prften = enum(u1) {
                disabled = 0, // Prefetch is disabled
                enabled = 1, // Prefetch is enabled
            };
            pub const Icen = enum(u1) {
                disabled = 0, // Instruction cache is disabled
                enabled = 1, // Instruction cache is enabled
            };
            pub const Dcen = enum(u1) {
                disabled = 0, // Data cache is disabled
                enabled = 1, // Data cache is enabled
            };
            pub const Icrst = enum(u1) {
                not_reset = 0, // Instruction cache is not reset
                reset = 1, // Instruction cache is reset
            };
            pub const Dcrst = enum(u1) {
                not_reset = 0, // Data cache is not reset
                reset = 1, // Data cache is reset
            };
            latency: Latency, // Latency (u4)
            _reserved_4_7: u4,
            prften: Prften, // Prefetch enable (u1)
            icen: Icen, // Instruction cache enable (u1)
            dcen: Dcen, // Data cache enable (u1)
            icrst: Icrst, // Instruction cache reset (u1)
            dcrst: Dcrst, // Data cache reset (u1)
            _padding_13_31: u19,
        };
        pub const acr = mmio(base_address + 0x0, 32, Acr);

        /// address: 0x40023c04
        /// Flash key register
        pub const Keyr = packed struct {
            key: u32, // FPEC key
        };
        pub const keyr = mmio(base_address + 0x4, 32, Keyr);

        /// address: 0x40023c08
        /// Flash option key register
        pub const Optkeyr = packed struct {
            optkey: u32, // Option byte key
        };
        pub const optkeyr = mmio(base_address + 0x8, 32, Optkeyr);

        /// address: 0x40023c0c
        /// Status register
        pub const Sr = packed struct {
            eop: u1, // End of operation
            operr: u1, // Operation error
            _reserved_2_3: u2,
            wrperr: u1, // Write protection error
            pgaerr: u1, // Programming alignment error
            pgperr: u1, // Programming parallelism error
            pgserr: u1, // Programming sequence error
            _reserved_8_15: u8,
            bsy: u1, // Busy
            _padding_17_31: u15,
        };
        pub const sr = mmio(base_address + 0xc, 32, Sr);

        /// address: 0x40023c10
        /// Control register
        pub const Cr = packed struct {
            pub const Pg = enum(u1) {
                program = 1, // Flash programming activated
            };
            pub const Ser = enum(u1) {
                sector_erase = 1, // Erase activated for selected sector
            };
            pub const Mer = enum(u1) {
                mass_erase = 1, // Erase activated for all user sectors
            };
            pub const Psize = enum(u2) {
                psize8 = 0b00, // Program x8
                psize16 = 0b01, // Program x16
                psize32 = 0b10, // Program x32
                psize64 = 0b11, // Program x64
            };
            pub const Strt = enum(u1) {
                start = 1, // Trigger an erase operation
            };
            pub const Eopie = enum(u1) {
                disabled = 0, // End of operation interrupt disabled
                enabled = 1, // End of operation interrupt enabled
            };
            pub const Errie = enum(u1) {
                disabled = 0, // Error interrupt generation disabled
                enabled = 1, // Error interrupt generation enabled
            };
            pub const Lock = enum(u1) {
                unlocked = 0, // FLASH_CR register is unlocked
                locked = 1, // FLASH_CR register is locked
            };
            pg: Pg, // Programming (u1)
            ser: Ser, // Sector Erase (u1)
            mer: Mer, // Mass Erase (u1)
            snb: u4, // Sector number
            _reserved_7_7: u1,
            psize: Psize, // Program size (u2)
            _reserved_10_15: u6,
            strt: Strt, // Start (u1)
            _reserved_17_23: u7,
            eopie: Eopie, // End of operation interrupt enable (u1)
            errie: Errie, // Error interrupt enable (u1)
            _reserved_26_30: u5,
            lock: Lock, // Lock (u1)
        };
        pub const cr = mmio(base_address + 0x10, 32, Cr);

        /// address: 0x40023c14
        /// Flash option control register
        pub const Optcr = packed struct {
            optlock: u1, // Option lock
            optstrt: u1, // Option start
            bor_lev: u2, // BOR reset Level
            _reserved_4_4: u1,
            wdg_sw: u1, // WDG_SW User option bytes
            nrst_stop: u1, // nRST_STOP User option bytes
            nrst_stdby: u1, // nRST_STDBY User option bytes
            rdp: u8, // Read protect
            nwrp: u12, // Not write protect
            _padding_28_31: u4,
        };
        pub const optcr = mmio(base_address + 0x14, 32, Optcr);
    };
    /// Independent watchdog
    pub const iwdg = struct {
        pub const base_address = 0x40003000;

        /// address: 0x40003000
        /// Key register
        pub const Kr = packed struct {
            pub const Key = enum(u16) {
                enable = 0b0101010101010101, // Enable access to PR, RLR and WINR registers (0x5555)
                reset = 0b1010101010101010, // Reset the watchdog value (0xAAAA)
                start = 0b1100110011001100, // Start the watchdog (0xCCCC)
            };
            key: Key, // Key value (u16)
            _padding_16_31: u16,
        };
        pub const kr = mmio(base_address + 0x0, 32, Kr);

        /// address: 0x40003004
        /// Prescaler register
        pub const pr = mmioInt(base_address + 0x4, 32, u3);

        /// address: 0x40003008
        /// Reload register
        pub const Rlr = packed struct {
            rl: u12, // Watchdog counter reload value
            _padding_12_31: u20,
        };
        pub const rlr = mmio(base_address + 0x8, 32, Rlr);

        /// address: 0x4000300c
        /// Status register
        pub const Sr = packed struct {
            pvu: u1, // Watchdog prescaler value update
            rvu: u1, // Watchdog counter reload value update
            _padding_2_31: u30,
        };
        pub const sr = mmio(base_address + 0xc, 32, Sr);
    };
    /// USB on the go full speed
    pub const otg_fs_device = struct {
        pub const base_address = 0x50000800;

        /// address: 0x50000800
        /// OTG_FS device configuration register (OTG_FS_DCFG)
        pub const Dcfg = packed struct {
            dspd: u2, // Device speed
            nzlsohsk: u1, // Non-zero-length status OUT handshake
            _reserved_3_3: u1,
            dad: u7, // Device address
            pfivl: u2, // Periodic frame interval
            _padding_13_31: u19,
        };
        pub const dcfg = mmio(base_address + 0x0, 32, Dcfg);

        /// address: 0x50000804
        /// OTG_FS device control register (OTG_FS_DCTL)
        pub const Dctl = packed struct {
            rwusig: u1, // Remote wakeup signaling
            sdis: u1, // Soft disconnect
            ginsts: u1, // Global IN NAK status
            gonsts: u1, // Global OUT NAK status
            tctl: u3, // Test control
            sginak: u1, // Set global IN NAK
            cginak: u1, // Clear global IN NAK
            sgonak: u1, // Set global OUT NAK
            cgonak: u1, // Clear global OUT NAK
            poprgdne: u1, // Power-on programming done
            _padding_12_31: u20,
        };
        pub const dctl = mmio(base_address + 0x4, 32, Dctl);

        /// address: 0x50000808
        /// OTG_FS device status register (OTG_FS_DSTS)
        pub const Dsts = packed struct {
            suspsts: u1, // Suspend status
            enumspd: u2, // Enumerated speed
            eerr: u1, // Erratic error
            _reserved_4_7: u4,
            fnsof: u14, // Frame number of the received SOF
            _padding_22_31: u10,
        };
        pub const dsts = mmio(base_address + 0x8, 32, Dsts);

        /// address: 0x50000810
        /// OTG_FS device IN endpoint common interrupt mask register (OTG_FS_DIEPMSK)
        pub const Diepmsk = packed struct {
            xfrcm: u1, // Transfer completed interrupt mask
            epdm: u1, // Endpoint disabled interrupt mask
            _reserved_2_2: u1,
            tom: u1, // Timeout condition mask (Non-isochronous endpoints)
            ittxfemsk: u1, // IN token received when TxFIFO empty mask
            inepnmm: u1, // IN token received with EP mismatch mask
            inepnem: u1, // IN endpoint NAK effective mask
            _padding_7_31: u25,
        };
        pub const diepmsk = mmio(base_address + 0x10, 32, Diepmsk);

        /// address: 0x50000814
        /// OTG_FS device OUT endpoint common interrupt mask register (OTG_FS_DOEPMSK)
        pub const Doepmsk = packed struct {
            xfrcm: u1, // Transfer completed interrupt mask
            epdm: u1, // Endpoint disabled interrupt mask
            _reserved_2_2: u1,
            stupm: u1, // SETUP phase done mask
            otepdm: u1, // OUT token received when endpoint disabled mask
            _padding_5_31: u27,
        };
        pub const doepmsk = mmio(base_address + 0x14, 32, Doepmsk);

        /// address: 0x50000818
        /// OTG_FS device all endpoints interrupt register (OTG_FS_DAINT)
        pub const Daint = packed struct {
            iepint: u16, // IN endpoint interrupt bits
            oepint: u16, // OUT endpoint interrupt bits
        };
        pub const daint = mmio(base_address + 0x18, 32, Daint);

        /// address: 0x5000081c
        /// OTG_FS all endpoints interrupt mask register (OTG_FS_DAINTMSK)
        pub const Daintmsk = packed struct {
            iepm: u16, // IN EP interrupt mask bits
            oepm: u16, // OUT EP interrupt mask bits
        };
        pub const daintmsk = mmio(base_address + 0x1c, 32, Daintmsk);

        /// address: 0x50000828
        /// OTG_FS device VBUS discharge time register
        pub const Dvbusdis = packed struct {
            vbusdt: u16, // Device VBUS discharge time
            _padding_16_31: u16,
        };
        pub const dvbusdis = mmio(base_address + 0x28, 32, Dvbusdis);

        /// address: 0x5000082c
        /// OTG_FS device VBUS pulsing time register
        pub const Dvbuspulse = packed struct {
            dvbusp: u12, // Device VBUS pulsing time
            _padding_12_31: u20,
        };
        pub const dvbuspulse = mmio(base_address + 0x2c, 32, Dvbuspulse);

        /// address: 0x50000834
        /// OTG_FS device IN endpoint FIFO empty interrupt mask register
        pub const Diepempmsk = packed struct {
            ineptxfem: u16, // IN EP Tx FIFO empty interrupt mask bits
            _padding_16_31: u16,
        };
        pub const diepempmsk = mmio(base_address + 0x34, 32, Diepempmsk);

        /// address: 0x50000900
        /// OTG_FS device control IN endpoint 0 control register (OTG_FS_DIEPCTL0)
        pub const Diepctl0 = packed struct {
            mpsiz: u2, // Maximum packet size
            _reserved_2_14: u13,
            usbaep: u1, // USB active endpoint
            _reserved_16_16: u1,
            naksts: u1, // NAK status
            eptyp: u2, // Endpoint type
            _reserved_20_20: u1,
            stall: u1, // STALL handshake
            txfnum: u4, // TxFIFO number
            cnak: u1, // Clear NAK
            snak: u1, // Set NAK
            _reserved_28_29: u2,
            epdis: u1, // Endpoint disable
            epena: u1, // Endpoint enable
        };
        pub const diepctl0 = mmio(base_address + 0x100, 32, Diepctl0);

        /// address: 0x50000920
        /// OTG_FS device endpoint %s IN control register
        pub const Diepctl1 = packed struct {
            mpsiz: u11, // MPSIZ
            _reserved_11_14: u4,
            usbaep: u1, // USBAEP
            eonum_dpid: u1, // EONUM/DPID
            naksts: u1, // NAKSTS
            eptyp: u2, // EPTYP
            _reserved_20_20: u1,
            stall: u1, // STALL
            txfnum: u4, // TXFNUM
            cnak: u1, // CNAK
            snak: u1, // SNAK
            sd0pid_sevnfrm: u1, // SD0PID/SEVNFRM
            soddfrm_sd1pid: u1, // SODDFRM/SD1PID
            epdis: u1, // EPDIS
            epena: u1, // EPENA
        };
        pub const diepctl1 = mmio(base_address + 0x120, 32, Diepctl1);

        /// address: 0x50000940
        /// OTG_FS device endpoint %s IN control register
        pub const Diepctl2 = packed struct {
            mpsiz: u11, // MPSIZ
            _reserved_11_14: u4,
            usbaep: u1, // USBAEP
            eonum_dpid: u1, // EONUM/DPID
            naksts: u1, // NAKSTS
            eptyp: u2, // EPTYP
            _reserved_20_20: u1,
            stall: u1, // STALL
            txfnum: u4, // TXFNUM
            cnak: u1, // CNAK
            snak: u1, // SNAK
            sd0pid_sevnfrm: u1, // SD0PID/SEVNFRM
            soddfrm_sd1pid: u1, // SODDFRM/SD1PID
            epdis: u1, // EPDIS
            epena: u1, // EPENA
        };
        pub const diepctl2 = mmio(base_address + 0x140, 32, Diepctl2);

        /// address: 0x50000960
        /// OTG_FS device endpoint %s IN control register
        pub const Diepctl3 = packed struct {
            mpsiz: u11, // MPSIZ
            _reserved_11_14: u4,
            usbaep: u1, // USBAEP
            eonum_dpid: u1, // EONUM/DPID
            naksts: u1, // NAKSTS
            eptyp: u2, // EPTYP
            _reserved_20_20: u1,
            stall: u1, // STALL
            txfnum: u4, // TXFNUM
            cnak: u1, // CNAK
            snak: u1, // SNAK
            sd0pid_sevnfrm: u1, // SD0PID/SEVNFRM
            soddfrm_sd1pid: u1, // SODDFRM/SD1PID
            epdis: u1, // EPDIS
            epena: u1, // EPENA
        };
        pub const diepctl3 = mmio(base_address + 0x160, 32, Diepctl3);

        /// address: 0x50000b00
        /// device endpoint-0 control register
        pub const Doepctl0 = packed struct {
            mpsiz: u2, // MPSIZ
            _reserved_2_14: u13,
            usbaep: u1, // USBAEP
            _reserved_16_16: u1,
            naksts: u1, // NAKSTS
            eptyp: u2, // EPTYP
            snpm: u1, // SNPM
            stall: u1, // STALL
            _reserved_22_25: u4,
            cnak: u1, // CNAK
            snak: u1, // SNAK
            _reserved_28_29: u2,
            epdis: u1, // EPDIS
            epena: u1, // EPENA
        };
        pub const doepctl0 = mmio(base_address + 0x300, 32, Doepctl0);

        /// address: 0x50000b20
        /// OTG_FS device endpoint %s OUT control register
        pub const Doepctl1 = packed struct {
            mpsiz: u11, // MPSIZ
            _reserved_11_14: u4,
            usbaep: u1, // USBAEP
            eonum_dpid: u1, // EONUM/DPID
            naksts: u1, // NAKSTS
            eptyp: u2, // EPTYP
            snpm: u1, // SNPM
            stall: u1, // STALL
            _reserved_22_25: u4,
            cnak: u1, // CNAK
            snak: u1, // SNAK
            sd0pid_sevnfrm: u1, // SD0PID/SEVNFRM
            soddfrm: u1, // SODDFRM
            epdis: u1, // EPDIS
            epena: u1, // EPENA
        };
        pub const doepctl1 = mmio(base_address + 0x320, 32, Doepctl1);

        /// address: 0x50000b40
        /// OTG_FS device endpoint %s OUT control register
        pub const Doepctl2 = packed struct {
            mpsiz: u11, // MPSIZ
            _reserved_11_14: u4,
            usbaep: u1, // USBAEP
            eonum_dpid: u1, // EONUM/DPID
            naksts: u1, // NAKSTS
            eptyp: u2, // EPTYP
            snpm: u1, // SNPM
            stall: u1, // STALL
            _reserved_22_25: u4,
            cnak: u1, // CNAK
            snak: u1, // SNAK
            sd0pid_sevnfrm: u1, // SD0PID/SEVNFRM
            soddfrm: u1, // SODDFRM
            epdis: u1, // EPDIS
            epena: u1, // EPENA
        };
        pub const doepctl2 = mmio(base_address + 0x340, 32, Doepctl2);

        /// address: 0x50000b60
        /// OTG_FS device endpoint %s OUT control register
        pub const Doepctl3 = packed struct {
            mpsiz: u11, // MPSIZ
            _reserved_11_14: u4,
            usbaep: u1, // USBAEP
            eonum_dpid: u1, // EONUM/DPID
            naksts: u1, // NAKSTS
            eptyp: u2, // EPTYP
            snpm: u1, // SNPM
            stall: u1, // STALL
            _reserved_22_25: u4,
            cnak: u1, // CNAK
            snak: u1, // SNAK
            sd0pid_sevnfrm: u1, // SD0PID/SEVNFRM
            soddfrm: u1, // SODDFRM
            epdis: u1, // EPDIS
            epena: u1, // EPENA
        };
        pub const doepctl3 = mmio(base_address + 0x360, 32, Doepctl3);

        /// address: 0x50000908
        /// device endpoint-x interrupt register
        pub const Diepint0 = packed struct {
            xfrc: u1, // XFRC
            epdisd: u1, // EPDISD
            _reserved_2_2: u1,
            toc: u1, // TOC
            ittxfe: u1, // ITTXFE
            _reserved_5_5: u1,
            inepne: u1, // INEPNE
            txfe: u1, // TXFE
            _padding_8_31: u24,
        };
        pub const diepint0 = mmio(base_address + 0x108, 32, Diepint0);

        /// address: 0x50000928
        /// device endpoint-1 interrupt register
        pub const Diepint1 = packed struct {
            xfrc: u1, // XFRC
            epdisd: u1, // EPDISD
            _reserved_2_2: u1,
            toc: u1, // TOC
            ittxfe: u1, // ITTXFE
            _reserved_5_5: u1,
            inepne: u1, // INEPNE
            txfe: u1, // TXFE
            _padding_8_31: u24,
        };
        pub const diepint1 = mmio(base_address + 0x128, 32, Diepint1);

        /// address: 0x50000948
        /// device endpoint-2 interrupt register
        pub const Diepint2 = packed struct {
            xfrc: u1, // XFRC
            epdisd: u1, // EPDISD
            _reserved_2_2: u1,
            toc: u1, // TOC
            ittxfe: u1, // ITTXFE
            _reserved_5_5: u1,
            inepne: u1, // INEPNE
            txfe: u1, // TXFE
            _padding_8_31: u24,
        };
        pub const diepint2 = mmio(base_address + 0x148, 32, Diepint2);

        /// address: 0x50000968
        /// device endpoint-3 interrupt register
        pub const Diepint3 = packed struct {
            xfrc: u1, // XFRC
            epdisd: u1, // EPDISD
            _reserved_2_2: u1,
            toc: u1, // TOC
            ittxfe: u1, // ITTXFE
            _reserved_5_5: u1,
            inepne: u1, // INEPNE
            txfe: u1, // TXFE
            _padding_8_31: u24,
        };
        pub const diepint3 = mmio(base_address + 0x168, 32, Diepint3);

        /// address: 0x50000b08
        /// device endpoint-0 interrupt register
        pub const Doepint0 = packed struct {
            xfrc: u1, // XFRC
            epdisd: u1, // EPDISD
            _reserved_2_2: u1,
            stup: u1, // STUP
            otepdis: u1, // OTEPDIS
            _reserved_5_5: u1,
            b2bstup: u1, // B2BSTUP
            _padding_7_31: u25,
        };
        pub const doepint0 = mmio(base_address + 0x308, 32, Doepint0);

        /// address: 0x50000b28
        /// device endpoint-1 interrupt register
        pub const Doepint1 = packed struct {
            xfrc: u1, // XFRC
            epdisd: u1, // EPDISD
            _reserved_2_2: u1,
            stup: u1, // STUP
            otepdis: u1, // OTEPDIS
            _reserved_5_5: u1,
            b2bstup: u1, // B2BSTUP
            _padding_7_31: u25,
        };
        pub const doepint1 = mmio(base_address + 0x328, 32, Doepint1);

        /// address: 0x50000b48
        /// device endpoint-2 interrupt register
        pub const Doepint2 = packed struct {
            xfrc: u1, // XFRC
            epdisd: u1, // EPDISD
            _reserved_2_2: u1,
            stup: u1, // STUP
            otepdis: u1, // OTEPDIS
            _reserved_5_5: u1,
            b2bstup: u1, // B2BSTUP
            _padding_7_31: u25,
        };
        pub const doepint2 = mmio(base_address + 0x348, 32, Doepint2);

        /// address: 0x50000b68
        /// device endpoint-3 interrupt register
        pub const Doepint3 = packed struct {
            xfrc: u1, // XFRC
            epdisd: u1, // EPDISD
            _reserved_2_2: u1,
            stup: u1, // STUP
            otepdis: u1, // OTEPDIS
            _reserved_5_5: u1,
            b2bstup: u1, // B2BSTUP
            _padding_7_31: u25,
        };
        pub const doepint3 = mmio(base_address + 0x368, 32, Doepint3);

        /// address: 0x50000910
        /// device endpoint-0 transfer size register
        pub const Dieptsiz0 = packed struct {
            xfrsiz: u7, // Transfer size
            _reserved_7_18: u12,
            pktcnt: u2, // Packet count
            _padding_21_31: u11,
        };
        pub const dieptsiz0 = mmio(base_address + 0x110, 32, Dieptsiz0);

        /// address: 0x50000b10
        /// device OUT endpoint-0 transfer size register
        pub const Doeptsiz0 = packed struct {
            xfrsiz: u7, // Transfer size
            _reserved_7_18: u12,
            pktcnt: u1, // Packet count
            _reserved_20_28: u9,
            stupcnt: u2, // SETUP packet count
            _padding_31_31: u1,
        };
        pub const doeptsiz0 = mmio(base_address + 0x310, 32, Doeptsiz0);

        /// address: 0x50000930
        /// device endpoint-1 transfer size register
        pub const Dieptsiz1 = packed struct {
            xfrsiz: u19, // Transfer size
            pktcnt: u10, // Packet count
            mcnt: u2, // Multi count
            _padding_31_31: u1,
        };
        pub const dieptsiz1 = mmio(base_address + 0x130, 32, Dieptsiz1);

        /// address: 0x50000950
        /// device endpoint-2 transfer size register
        pub const Dieptsiz2 = packed struct {
            xfrsiz: u19, // Transfer size
            pktcnt: u10, // Packet count
            mcnt: u2, // Multi count
            _padding_31_31: u1,
        };
        pub const dieptsiz2 = mmio(base_address + 0x150, 32, Dieptsiz2);

        /// address: 0x50000970
        /// device endpoint-3 transfer size register
        pub const Dieptsiz3 = packed struct {
            xfrsiz: u19, // Transfer size
            pktcnt: u10, // Packet count
            mcnt: u2, // Multi count
            _padding_31_31: u1,
        };
        pub const dieptsiz3 = mmio(base_address + 0x170, 32, Dieptsiz3);

        /// address: 0x50000918
        /// OTG_FS device IN endpoint transmit FIFO status register
        pub const Dtxfsts0 = packed struct {
            ineptfsav: u16, // IN endpoint TxFIFO space available
            _padding_16_31: u16,
        };
        pub const dtxfsts0 = mmio(base_address + 0x118, 32, Dtxfsts0);

        /// address: 0x50000938
        /// OTG_FS device IN endpoint transmit FIFO status register
        pub const Dtxfsts1 = packed struct {
            ineptfsav: u16, // IN endpoint TxFIFO space available
            _padding_16_31: u16,
        };
        pub const dtxfsts1 = mmio(base_address + 0x138, 32, Dtxfsts1);

        /// address: 0x50000958
        /// OTG_FS device IN endpoint transmit FIFO status register
        pub const Dtxfsts2 = packed struct {
            ineptfsav: u16, // IN endpoint TxFIFO space available
            _padding_16_31: u16,
        };
        pub const dtxfsts2 = mmio(base_address + 0x158, 32, Dtxfsts2);

        /// address: 0x50000978
        /// OTG_FS device IN endpoint transmit FIFO status register
        pub const Dtxfsts3 = packed struct {
            ineptfsav: u16, // IN endpoint TxFIFO space available
            _padding_16_31: u16,
        };
        pub const dtxfsts3 = mmio(base_address + 0x178, 32, Dtxfsts3);

        /// address: 0x50000b30
        /// device OUT endpoint-1 transfer size register
        pub const Doeptsiz1 = packed struct {
            xfrsiz: u19, // Transfer size
            pktcnt: u10, // Packet count
            rxdpid_stupcnt: u2, // Received data PID/SETUP packet count
            _padding_31_31: u1,
        };
        pub const doeptsiz1 = mmio(base_address + 0x330, 32, Doeptsiz1);

        /// address: 0x50000b50
        /// device OUT endpoint-2 transfer size register
        pub const Doeptsiz2 = packed struct {
            xfrsiz: u19, // Transfer size
            pktcnt: u10, // Packet count
            rxdpid_stupcnt: u2, // Received data PID/SETUP packet count
            _padding_31_31: u1,
        };
        pub const doeptsiz2 = mmio(base_address + 0x350, 32, Doeptsiz2);

        /// address: 0x50000b70
        /// device OUT endpoint-3 transfer size register
        pub const Doeptsiz3 = packed struct {
            xfrsiz: u19, // Transfer size
            pktcnt: u10, // Packet count
            rxdpid_stupcnt: u2, // Received data PID/SETUP packet count
            _padding_31_31: u1,
        };
        pub const doeptsiz3 = mmio(base_address + 0x370, 32, Doeptsiz3);
    };
    /// USB on the go full speed
    pub const otg_fs_global = struct {
        pub const base_address = 0x50000000;

        /// address: 0x50000000
        /// OTG_FS control and status register (OTG_FS_GOTGCTL)
        pub const Gotgctl = packed struct {
            srqscs: u1, // Session request success
            srq: u1, // Session request
            _reserved_2_7: u6,
            hngscs: u1, // Host negotiation success
            hnprq: u1, // HNP request
            hshnpen: u1, // Host set HNP enable
            dhnpen: u1, // Device HNP enabled
            _reserved_12_15: u4,
            cidsts: u1, // Connector ID status
            dbct: u1, // Long/short debounce time
            asvld: u1, // A-session valid
            bsvld: u1, // B-session valid
            _padding_20_31: u12,
        };
        pub const gotgctl = mmio(base_address + 0x0, 32, Gotgctl);

        /// address: 0x50000004
        /// OTG_FS interrupt register (OTG_FS_GOTGINT)
        pub const Gotgint = packed struct {
            _reserved_0_1: u2,
            sedet: u1, // Session end detected
            _reserved_3_7: u5,
            srsschg: u1, // Session request success status change
            hnsschg: u1, // Host negotiation success status change
            _reserved_10_16: u7,
            hngdet: u1, // Host negotiation detected
            adtochg: u1, // A-device timeout change
            dbcdne: u1, // Debounce done
            _padding_20_31: u12,
        };
        pub const gotgint = mmio(base_address + 0x4, 32, Gotgint);

        /// address: 0x50000008
        /// OTG_FS AHB configuration register (OTG_FS_GAHBCFG)
        pub const Gahbcfg = packed struct {
            gint: u1, // Global interrupt mask
            _reserved_1_6: u6,
            txfelvl: u1, // TxFIFO empty level
            ptxfelvl: u1, // Periodic TxFIFO empty level
            _padding_9_31: u23,
        };
        pub const gahbcfg = mmio(base_address + 0x8, 32, Gahbcfg);

        /// address: 0x5000000c
        /// OTG_FS USB configuration register (OTG_FS_GUSBCFG)
        pub const Gusbcfg = packed struct {
            tocal: u3, // FS timeout calibration
            _reserved_3_5: u3,
            physel: u1, // Full Speed serial transceiver select
            _reserved_7_7: u1,
            srpcap: u1, // SRP-capable
            hnpcap: u1, // HNP-capable
            trdt: u4, // USB turnaround time
            _reserved_14_28: u15,
            fhmod: u1, // Force host mode
            fdmod: u1, // Force device mode
            ctxpkt: u1, // Corrupt Tx packet
        };
        pub const gusbcfg = mmio(base_address + 0xc, 32, Gusbcfg);

        /// address: 0x50000010
        /// OTG_FS reset register (OTG_FS_GRSTCTL)
        pub const Grstctl = packed struct {
            csrst: u1, // Core soft reset
            hsrst: u1, // HCLK soft reset
            fcrst: u1, // Host frame counter reset
            _reserved_3_3: u1,
            rxfflsh: u1, // RxFIFO flush
            txfflsh: u1, // TxFIFO flush
            txfnum: u5, // TxFIFO number
            _reserved_11_30: u20,
            ahbidl: u1, // AHB master idle
        };
        pub const grstctl = mmio(base_address + 0x10, 32, Grstctl);

        /// address: 0x50000014
        /// OTG_FS core interrupt register (OTG_FS_GINTSTS)
        pub const Gintsts = packed struct {
            cmod: u1, // Current mode of operation
            mmis: u1, // Mode mismatch interrupt
            otgint: u1, // OTG interrupt
            sof: u1, // Start of frame
            rxflvl: u1, // RxFIFO non-empty
            nptxfe: u1, // Non-periodic TxFIFO empty
            ginakeff: u1, // Global IN non-periodic NAK effective
            goutnakeff: u1, // Global OUT NAK effective
            _reserved_8_9: u2,
            esusp: u1, // Early suspend
            usbsusp: u1, // USB suspend
            usbrst: u1, // USB reset
            enumdne: u1, // Enumeration done
            isoodrp: u1, // Isochronous OUT packet dropped interrupt
            eopf: u1, // End of periodic frame interrupt
            _reserved_16_17: u2,
            iepint: u1, // IN endpoint interrupt
            oepint: u1, // OUT endpoint interrupt
            iisoixfr: u1, // Incomplete isochronous IN transfer
            ipxfr_incompisoout: u1, // Incomplete periodic transfer(Host mode)/Incomplete isochronous OUT transfer(Device mode)
            _reserved_22_23: u2,
            hprtint: u1, // Host port interrupt
            hcint: u1, // Host channels interrupt
            ptxfe: u1, // Periodic TxFIFO empty
            _reserved_27_27: u1,
            cidschg: u1, // Connector ID status change
            discint: u1, // Disconnect detected interrupt
            srqint: u1, // Session request/new session detected interrupt
            wkupint: u1, // Resume/remote wakeup detected interrupt
        };
        pub const gintsts = mmio(base_address + 0x14, 32, Gintsts);

        /// address: 0x50000018
        /// OTG_FS interrupt mask register (OTG_FS_GINTMSK)
        pub const Gintmsk = packed struct {
            _reserved_0_0: u1,
            mmism: u1, // Mode mismatch interrupt mask
            otgint: u1, // OTG interrupt mask
            sofm: u1, // Start of frame mask
            rxflvlm: u1, // Receive FIFO non-empty mask
            nptxfem: u1, // Non-periodic TxFIFO empty mask
            ginakeffm: u1, // Global non-periodic IN NAK effective mask
            gonakeffm: u1, // Global OUT NAK effective mask
            _reserved_8_9: u2,
            esuspm: u1, // Early suspend mask
            usbsuspm: u1, // USB suspend mask
            usbrst: u1, // USB reset mask
            enumdnem: u1, // Enumeration done mask
            isoodrpm: u1, // Isochronous OUT packet dropped interrupt mask
            eopfm: u1, // End of periodic frame interrupt mask
            _reserved_16_16: u1,
            epmism: u1, // Endpoint mismatch interrupt mask
            iepint: u1, // IN endpoints interrupt mask
            oepint: u1, // OUT endpoints interrupt mask
            iisoixfrm: u1, // Incomplete isochronous IN transfer mask
            ipxfrm_iisooxfrm: u1, // Incomplete periodic transfer mask(Host mode)/Incomplete isochronous OUT transfer mask(Device mode)
            _reserved_22_23: u2,
            prtim: u1, // Host port interrupt mask
            hcim: u1, // Host channels interrupt mask
            ptxfem: u1, // Periodic TxFIFO empty mask
            _reserved_27_27: u1,
            cidschgm: u1, // Connector ID status change mask
            discint: u1, // Disconnect detected interrupt mask
            srqim: u1, // Session request/new session detected interrupt mask
            wuim: u1, // Resume/remote wakeup detected interrupt mask
        };
        pub const gintmsk = mmio(base_address + 0x18, 32, Gintmsk);

        /// address: 0x5000001c
        /// OTG_FS Receive status debug read(Device mode)
        pub const GrxstsrDevice = packed struct {
            epnum: u4, // Endpoint number
            bcnt: u11, // Byte count
            dpid: u2, // Data PID
            pktsts: u4, // Packet status
            frmnum: u4, // Frame number
            _padding_25_31: u7,
        };
        pub const grxstsr_device = mmio(base_address + 0x1c, 32, GrxstsrDevice);

        /// address: 0x5000001c
        /// OTG status debug read (host mode)
        pub const GrxstsrHost = packed struct {
            chnum: u4, // Channel number
            bcnt: u11, // Byte count
            dpid: u2, // Data PID
            pktsts: u4, // Packet status
            _padding_21_31: u11,
        };
        pub const grxstsr_host = mmio(base_address + 28, 32, GrxstsrHost);

        /// address: 0x50000024
        /// OTG_FS Receive FIFO size register (OTG_FS_GRXFSIZ)
        pub const Grxfsiz = packed struct {
            rxfd: u16, // RxFIFO depth
            _padding_16_31: u16,
        };
        pub const grxfsiz = mmio(base_address + 0x24, 32, Grxfsiz);

        /// address: 0x50000028
        /// OTG_FS non-periodic transmit FIFO size register (Device mode)
        pub const Dieptxf0 = packed struct {
            tx0fsa: u16, // Endpoint 0 transmit RAM start address
            tx0fd: u16, // Endpoint 0 TxFIFO depth
        };
        pub const dieptxf0 = mmio(base_address + 0x28, 32, Dieptxf0);

        /// address: 0x50000028
        /// OTG_FS non-periodic transmit FIFO size register (Host mode)
        pub const Hnptxfsiz = packed struct {
            nptxfsa: u16, // Non-periodic transmit RAM start address
            nptxfd: u16, // Non-periodic TxFIFO depth
        };
        pub const hnptxfsiz = mmio(base_address + 0x28, 32, Hnptxfsiz);

        /// address: 0x5000002c
        /// OTG_FS non-periodic transmit FIFO/queue status register (OTG_FS_GNPTXSTS)
        pub const Gnptxsts = packed struct {
            nptxfsav: u16, // Non-periodic TxFIFO space available
            nptqxsav: u8, // Non-periodic transmit request queue space available
            nptxqtop: u7, // Top of the non-periodic transmit request queue
            _padding_31_31: u1,
        };
        pub const gnptxsts = mmio(base_address + 0x2c, 32, Gnptxsts);

        /// address: 0x50000038
        /// OTG_FS general core configuration register (OTG_FS_GCCFG)
        pub const Gccfg = packed struct {
            _reserved_0_15: u16,
            pwrdwn: u1, // Power down
            _reserved_17_17: u1,
            vbusasen: u1, // Enable the VBUS sensing device
            vbusbsen: u1, // Enable the VBUS sensing device
            sofouten: u1, // SOF output enable
            novbussens: u1, // Vbus sensing disable option
            _padding_22_31: u10,
        };
        pub const gccfg = mmio(base_address + 0x38, 32, Gccfg);

        /// address: 0x5000003c
        /// core ID register
        pub const Cid = packed struct {
            product_id: u32, // Product ID field
        };
        pub const cid = mmio(base_address + 0x3c, 32, Cid);

        /// address: 0x50000100
        /// OTG_FS Host periodic transmit FIFO size register (OTG_FS_HPTXFSIZ)
        pub const Hptxfsiz = packed struct {
            ptxsa: u16, // Host periodic TxFIFO start address
            ptxfsiz: u16, // Host periodic TxFIFO depth
        };
        pub const hptxfsiz = mmio(base_address + 0x100, 32, Hptxfsiz);

        /// address: 0x50000104
        /// OTF_FS device IN endpoint transmit FIFO size register
        pub const Dieptxf1 = packed struct {
            ineptxsa: u16, // IN endpoint FIFO2 transmit RAM start address
            ineptxfd: u16, // IN endpoint TxFIFO depth
        };
        pub const dieptxf1 = mmio(base_address + 0x104, 32, Dieptxf1);

        /// address: 0x50000108
        /// OTF_FS device IN endpoint transmit FIFO size register
        pub const Dieptxf2 = packed struct {
            ineptxsa: u16, // IN endpoint FIFO2 transmit RAM start address
            ineptxfd: u16, // IN endpoint TxFIFO depth
        };
        pub const dieptxf2 = mmio(base_address + 0x108, 32, Dieptxf2);

        /// address: 0x5000010c
        /// OTF_FS device IN endpoint transmit FIFO size register
        pub const Dieptxf3 = packed struct {
            ineptxsa: u16, // IN endpoint FIFO2 transmit RAM start address
            ineptxfd: u16, // IN endpoint TxFIFO depth
        };
        pub const dieptxf3 = mmio(base_address + 0x10c, 32, Dieptxf3);

        /// address: 0x50000020
        /// OTG status read and pop (device mode)
        pub const GrxstspDevice = packed struct {
            epnum: u4, // Endpoint number
            bcnt: u11, // Byte count
            dpid: u2, // Data PID
            pktsts: u4, // Packet status
            frmnum: u4, // Frame number
            _padding_25_31: u7,
        };
        pub const grxstsp_device = mmio(base_address + 32, 32, GrxstspDevice);

        /// address: 0x50000020
        /// OTG status read and pop (host mode)
        pub const GrxstspHost = packed struct {
            chnum: u4, // Channel number
            bcnt: u11, // Byte count
            dpid: u2, // Data PID
            pktsts: u4, // Packet status
            _padding_21_31: u11,
        };
        pub const grxstsp_host = mmio(base_address + 32, 32, GrxstspHost);
    };
    /// USB on the go full speed
    pub const otg_fs_host = struct {
        pub const base_address = 0x50000400;

        /// address: 0x50000400
        /// OTG_FS host configuration register (OTG_FS_HCFG)
        pub const Hcfg = packed struct {
            fslspcs: u2, // FS/LS PHY clock select
            fslss: u1, // FS- and LS-only support
            _padding_3_31: u29,
        };
        pub const hcfg = mmio(base_address + 0x0, 32, Hcfg);

        /// address: 0x50000404
        /// OTG_FS Host frame interval register
        pub const Hfir = packed struct {
            frivl: u16, // Frame interval
            _padding_16_31: u16,
        };
        pub const hfir = mmio(base_address + 0x4, 32, Hfir);

        /// address: 0x50000408
        /// OTG_FS host frame number/frame time remaining register (OTG_FS_HFNUM)
        pub const Hfnum = packed struct {
            frnum: u16, // Frame number
            ftrem: u16, // Frame time remaining
        };
        pub const hfnum = mmio(base_address + 0x8, 32, Hfnum);

        /// address: 0x50000410
        /// OTG_FS_Host periodic transmit FIFO/queue status register (OTG_FS_HPTXSTS)
        pub const Hptxsts = packed struct {
            ptxfsavl: u16, // Periodic transmit data FIFO space available
            ptxqsav: u8, // Periodic transmit request queue space available
            ptxqtop: u8, // Top of the periodic transmit request queue
        };
        pub const hptxsts = mmio(base_address + 0x10, 32, Hptxsts);

        /// address: 0x50000414
        /// OTG_FS Host all channels interrupt register
        pub const haint = mmioInt(base_address + 0x14, 32, u16);

        /// address: 0x50000418
        /// OTG_FS host all channels interrupt mask register
        pub const Haintmsk = packed struct {
            haintm: u16, // Channel interrupt mask
            _padding_16_31: u16,
        };
        pub const haintmsk = mmio(base_address + 0x18, 32, Haintmsk);

        /// address: 0x50000440
        /// OTG_FS host port control and status register (OTG_FS_HPRT)
        pub const Hprt = packed struct {
            pcsts: u1, // Port connect status
            pcdet: u1, // Port connect detected
            pena: u1, // Port enable
            penchng: u1, // Port enable/disable change
            poca: u1, // Port overcurrent active
            pocchng: u1, // Port overcurrent change
            pres: u1, // Port resume
            psusp: u1, // Port suspend
            prst: u1, // Port reset
            _reserved_9_9: u1,
            plsts: u2, // Port line status
            ppwr: u1, // Port power
            ptctl: u4, // Port test control
            pspd: u2, // Port speed
            _padding_19_31: u13,
        };
        pub const hprt = mmio(base_address + 0x40, 32, Hprt);

        /// address: 0x50000500
        /// OTG_FS host channel-0 characteristics register (OTG_FS_HCCHAR0)
        pub const Hcchar0 = packed struct {
            mpsiz: u11, // Maximum packet size
            epnum: u4, // Endpoint number
            epdir: u1, // Endpoint direction
            _reserved_16_16: u1,
            lsdev: u1, // Low-speed device
            eptyp: u2, // Endpoint type
            mcnt: u2, // Multicount
            dad: u7, // Device address
            oddfrm: u1, // Odd frame
            chdis: u1, // Channel disable
            chena: u1, // Channel enable
        };
        pub const hcchar0 = mmio(base_address + 0x100, 32, Hcchar0);

        /// address: 0x50000520
        /// OTG_FS host channel-1 characteristics register (OTG_FS_HCCHAR1)
        pub const Hcchar1 = packed struct {
            mpsiz: u11, // Maximum packet size
            epnum: u4, // Endpoint number
            epdir: u1, // Endpoint direction
            _reserved_16_16: u1,
            lsdev: u1, // Low-speed device
            eptyp: u2, // Endpoint type
            mcnt: u2, // Multicount
            dad: u7, // Device address
            oddfrm: u1, // Odd frame
            chdis: u1, // Channel disable
            chena: u1, // Channel enable
        };
        pub const hcchar1 = mmio(base_address + 0x120, 32, Hcchar1);

        /// address: 0x50000540
        /// OTG_FS host channel-2 characteristics register (OTG_FS_HCCHAR2)
        pub const Hcchar2 = packed struct {
            mpsiz: u11, // Maximum packet size
            epnum: u4, // Endpoint number
            epdir: u1, // Endpoint direction
            _reserved_16_16: u1,
            lsdev: u1, // Low-speed device
            eptyp: u2, // Endpoint type
            mcnt: u2, // Multicount
            dad: u7, // Device address
            oddfrm: u1, // Odd frame
            chdis: u1, // Channel disable
            chena: u1, // Channel enable
        };
        pub const hcchar2 = mmio(base_address + 0x140, 32, Hcchar2);

        /// address: 0x50000560
        /// OTG_FS host channel-3 characteristics register (OTG_FS_HCCHAR3)
        pub const Hcchar3 = packed struct {
            mpsiz: u11, // Maximum packet size
            epnum: u4, // Endpoint number
            epdir: u1, // Endpoint direction
            _reserved_16_16: u1,
            lsdev: u1, // Low-speed device
            eptyp: u2, // Endpoint type
            mcnt: u2, // Multicount
            dad: u7, // Device address
            oddfrm: u1, // Odd frame
            chdis: u1, // Channel disable
            chena: u1, // Channel enable
        };
        pub const hcchar3 = mmio(base_address + 0x160, 32, Hcchar3);

        /// address: 0x50000580
        /// OTG_FS host channel-4 characteristics register (OTG_FS_HCCHAR4)
        pub const Hcchar4 = packed struct {
            mpsiz: u11, // Maximum packet size
            epnum: u4, // Endpoint number
            epdir: u1, // Endpoint direction
            _reserved_16_16: u1,
            lsdev: u1, // Low-speed device
            eptyp: u2, // Endpoint type
            mcnt: u2, // Multicount
            dad: u7, // Device address
            oddfrm: u1, // Odd frame
            chdis: u1, // Channel disable
            chena: u1, // Channel enable
        };
        pub const hcchar4 = mmio(base_address + 0x180, 32, Hcchar4);

        /// address: 0x500005a0
        /// OTG_FS host channel-5 characteristics register (OTG_FS_HCCHAR5)
        pub const Hcchar5 = packed struct {
            mpsiz: u11, // Maximum packet size
            epnum: u4, // Endpoint number
            epdir: u1, // Endpoint direction
            _reserved_16_16: u1,
            lsdev: u1, // Low-speed device
            eptyp: u2, // Endpoint type
            mcnt: u2, // Multicount
            dad: u7, // Device address
            oddfrm: u1, // Odd frame
            chdis: u1, // Channel disable
            chena: u1, // Channel enable
        };
        pub const hcchar5 = mmio(base_address + 0x1a0, 32, Hcchar5);

        /// address: 0x500005c0
        /// OTG_FS host channel-6 characteristics register (OTG_FS_HCCHAR6)
        pub const Hcchar6 = packed struct {
            mpsiz: u11, // Maximum packet size
            epnum: u4, // Endpoint number
            epdir: u1, // Endpoint direction
            _reserved_16_16: u1,
            lsdev: u1, // Low-speed device
            eptyp: u2, // Endpoint type
            mcnt: u2, // Multicount
            dad: u7, // Device address
            oddfrm: u1, // Odd frame
            chdis: u1, // Channel disable
            chena: u1, // Channel enable
        };
        pub const hcchar6 = mmio(base_address + 0x1c0, 32, Hcchar6);

        /// address: 0x500005e0
        /// OTG_FS host channel-7 characteristics register (OTG_FS_HCCHAR7)
        pub const Hcchar7 = packed struct {
            mpsiz: u11, // Maximum packet size
            epnum: u4, // Endpoint number
            epdir: u1, // Endpoint direction
            _reserved_16_16: u1,
            lsdev: u1, // Low-speed device
            eptyp: u2, // Endpoint type
            mcnt: u2, // Multicount
            dad: u7, // Device address
            oddfrm: u1, // Odd frame
            chdis: u1, // Channel disable
            chena: u1, // Channel enable
        };
        pub const hcchar7 = mmio(base_address + 0x1e0, 32, Hcchar7);

        /// address: 0x50000508
        /// OTG_FS host channel-0 interrupt register (OTG_FS_HCINT0)
        pub const Hcint0 = packed struct {
            xfrc: u1, // Transfer completed
            chh: u1, // Channel halted
            _reserved_2_2: u1,
            stall: u1, // STALL response received interrupt
            nak: u1, // NAK response received interrupt
            ack: u1, // ACK response received/transmitted interrupt
            _reserved_6_6: u1,
            txerr: u1, // Transaction error
            bberr: u1, // Babble error
            frmor: u1, // Frame overrun
            dterr: u1, // Data toggle error
            _padding_11_31: u21,
        };
        pub const hcint0 = mmio(base_address + 0x108, 32, Hcint0);

        /// address: 0x50000528
        /// OTG_FS host channel-1 interrupt register (OTG_FS_HCINT1)
        pub const Hcint1 = packed struct {
            xfrc: u1, // Transfer completed
            chh: u1, // Channel halted
            _reserved_2_2: u1,
            stall: u1, // STALL response received interrupt
            nak: u1, // NAK response received interrupt
            ack: u1, // ACK response received/transmitted interrupt
            _reserved_6_6: u1,
            txerr: u1, // Transaction error
            bberr: u1, // Babble error
            frmor: u1, // Frame overrun
            dterr: u1, // Data toggle error
            _padding_11_31: u21,
        };
        pub const hcint1 = mmio(base_address + 0x128, 32, Hcint1);

        /// address: 0x50000548
        /// OTG_FS host channel-2 interrupt register (OTG_FS_HCINT2)
        pub const Hcint2 = packed struct {
            xfrc: u1, // Transfer completed
            chh: u1, // Channel halted
            _reserved_2_2: u1,
            stall: u1, // STALL response received interrupt
            nak: u1, // NAK response received interrupt
            ack: u1, // ACK response received/transmitted interrupt
            _reserved_6_6: u1,
            txerr: u1, // Transaction error
            bberr: u1, // Babble error
            frmor: u1, // Frame overrun
            dterr: u1, // Data toggle error
            _padding_11_31: u21,
        };
        pub const hcint2 = mmio(base_address + 0x148, 32, Hcint2);

        /// address: 0x50000568
        /// OTG_FS host channel-3 interrupt register (OTG_FS_HCINT3)
        pub const Hcint3 = packed struct {
            xfrc: u1, // Transfer completed
            chh: u1, // Channel halted
            _reserved_2_2: u1,
            stall: u1, // STALL response received interrupt
            nak: u1, // NAK response received interrupt
            ack: u1, // ACK response received/transmitted interrupt
            _reserved_6_6: u1,
            txerr: u1, // Transaction error
            bberr: u1, // Babble error
            frmor: u1, // Frame overrun
            dterr: u1, // Data toggle error
            _padding_11_31: u21,
        };
        pub const hcint3 = mmio(base_address + 0x168, 32, Hcint3);

        /// address: 0x50000588
        /// OTG_FS host channel-4 interrupt register (OTG_FS_HCINT4)
        pub const Hcint4 = packed struct {
            xfrc: u1, // Transfer completed
            chh: u1, // Channel halted
            _reserved_2_2: u1,
            stall: u1, // STALL response received interrupt
            nak: u1, // NAK response received interrupt
            ack: u1, // ACK response received/transmitted interrupt
            _reserved_6_6: u1,
            txerr: u1, // Transaction error
            bberr: u1, // Babble error
            frmor: u1, // Frame overrun
            dterr: u1, // Data toggle error
            _padding_11_31: u21,
        };
        pub const hcint4 = mmio(base_address + 0x188, 32, Hcint4);

        /// address: 0x500005a8
        /// OTG_FS host channel-5 interrupt register (OTG_FS_HCINT5)
        pub const Hcint5 = packed struct {
            xfrc: u1, // Transfer completed
            chh: u1, // Channel halted
            _reserved_2_2: u1,
            stall: u1, // STALL response received interrupt
            nak: u1, // NAK response received interrupt
            ack: u1, // ACK response received/transmitted interrupt
            _reserved_6_6: u1,
            txerr: u1, // Transaction error
            bberr: u1, // Babble error
            frmor: u1, // Frame overrun
            dterr: u1, // Data toggle error
            _padding_11_31: u21,
        };
        pub const hcint5 = mmio(base_address + 0x1a8, 32, Hcint5);

        /// address: 0x500005c8
        /// OTG_FS host channel-6 interrupt register (OTG_FS_HCINT6)
        pub const Hcint6 = packed struct {
            xfrc: u1, // Transfer completed
            chh: u1, // Channel halted
            _reserved_2_2: u1,
            stall: u1, // STALL response received interrupt
            nak: u1, // NAK response received interrupt
            ack: u1, // ACK response received/transmitted interrupt
            _reserved_6_6: u1,
            txerr: u1, // Transaction error
            bberr: u1, // Babble error
            frmor: u1, // Frame overrun
            dterr: u1, // Data toggle error
            _padding_11_31: u21,
        };
        pub const hcint6 = mmio(base_address + 0x1c8, 32, Hcint6);

        /// address: 0x500005e8
        /// OTG_FS host channel-7 interrupt register (OTG_FS_HCINT7)
        pub const Hcint7 = packed struct {
            xfrc: u1, // Transfer completed
            chh: u1, // Channel halted
            _reserved_2_2: u1,
            stall: u1, // STALL response received interrupt
            nak: u1, // NAK response received interrupt
            ack: u1, // ACK response received/transmitted interrupt
            _reserved_6_6: u1,
            txerr: u1, // Transaction error
            bberr: u1, // Babble error
            frmor: u1, // Frame overrun
            dterr: u1, // Data toggle error
            _padding_11_31: u21,
        };
        pub const hcint7 = mmio(base_address + 0x1e8, 32, Hcint7);

        /// address: 0x5000050c
        /// OTG_FS host channel-0 mask register (OTG_FS_HCINTMSK0)
        pub const Hcintmsk0 = packed struct {
            xfrcm: u1, // Transfer completed mask
            chhm: u1, // Channel halted mask
            _reserved_2_2: u1,
            stallm: u1, // STALL response received interrupt mask
            nakm: u1, // NAK response received interrupt mask
            ackm: u1, // ACK response received/transmitted interrupt mask
            nyet: u1, // response received interrupt mask
            txerrm: u1, // Transaction error mask
            bberrm: u1, // Babble error mask
            frmorm: u1, // Frame overrun mask
            dterrm: u1, // Data toggle error mask
            _padding_11_31: u21,
        };
        pub const hcintmsk0 = mmio(base_address + 0x10c, 32, Hcintmsk0);

        /// address: 0x5000052c
        /// OTG_FS host channel-1 mask register (OTG_FS_HCINTMSK1)
        pub const Hcintmsk1 = packed struct {
            xfrcm: u1, // Transfer completed mask
            chhm: u1, // Channel halted mask
            _reserved_2_2: u1,
            stallm: u1, // STALL response received interrupt mask
            nakm: u1, // NAK response received interrupt mask
            ackm: u1, // ACK response received/transmitted interrupt mask
            nyet: u1, // response received interrupt mask
            txerrm: u1, // Transaction error mask
            bberrm: u1, // Babble error mask
            frmorm: u1, // Frame overrun mask
            dterrm: u1, // Data toggle error mask
            _padding_11_31: u21,
        };
        pub const hcintmsk1 = mmio(base_address + 0x12c, 32, Hcintmsk1);

        /// address: 0x5000054c
        /// OTG_FS host channel-2 mask register (OTG_FS_HCINTMSK2)
        pub const Hcintmsk2 = packed struct {
            xfrcm: u1, // Transfer completed mask
            chhm: u1, // Channel halted mask
            _reserved_2_2: u1,
            stallm: u1, // STALL response received interrupt mask
            nakm: u1, // NAK response received interrupt mask
            ackm: u1, // ACK response received/transmitted interrupt mask
            nyet: u1, // response received interrupt mask
            txerrm: u1, // Transaction error mask
            bberrm: u1, // Babble error mask
            frmorm: u1, // Frame overrun mask
            dterrm: u1, // Data toggle error mask
            _padding_11_31: u21,
        };
        pub const hcintmsk2 = mmio(base_address + 0x14c, 32, Hcintmsk2);

        /// address: 0x5000056c
        /// OTG_FS host channel-3 mask register (OTG_FS_HCINTMSK3)
        pub const Hcintmsk3 = packed struct {
            xfrcm: u1, // Transfer completed mask
            chhm: u1, // Channel halted mask
            _reserved_2_2: u1,
            stallm: u1, // STALL response received interrupt mask
            nakm: u1, // NAK response received interrupt mask
            ackm: u1, // ACK response received/transmitted interrupt mask
            nyet: u1, // response received interrupt mask
            txerrm: u1, // Transaction error mask
            bberrm: u1, // Babble error mask
            frmorm: u1, // Frame overrun mask
            dterrm: u1, // Data toggle error mask
            _padding_11_31: u21,
        };
        pub const hcintmsk3 = mmio(base_address + 0x16c, 32, Hcintmsk3);

        /// address: 0x5000058c
        /// OTG_FS host channel-4 mask register (OTG_FS_HCINTMSK4)
        pub const Hcintmsk4 = packed struct {
            xfrcm: u1, // Transfer completed mask
            chhm: u1, // Channel halted mask
            _reserved_2_2: u1,
            stallm: u1, // STALL response received interrupt mask
            nakm: u1, // NAK response received interrupt mask
            ackm: u1, // ACK response received/transmitted interrupt mask
            nyet: u1, // response received interrupt mask
            txerrm: u1, // Transaction error mask
            bberrm: u1, // Babble error mask
            frmorm: u1, // Frame overrun mask
            dterrm: u1, // Data toggle error mask
            _padding_11_31: u21,
        };
        pub const hcintmsk4 = mmio(base_address + 0x18c, 32, Hcintmsk4);

        /// address: 0x500005ac
        /// OTG_FS host channel-5 mask register (OTG_FS_HCINTMSK5)
        pub const Hcintmsk5 = packed struct {
            xfrcm: u1, // Transfer completed mask
            chhm: u1, // Channel halted mask
            _reserved_2_2: u1,
            stallm: u1, // STALL response received interrupt mask
            nakm: u1, // NAK response received interrupt mask
            ackm: u1, // ACK response received/transmitted interrupt mask
            nyet: u1, // response received interrupt mask
            txerrm: u1, // Transaction error mask
            bberrm: u1, // Babble error mask
            frmorm: u1, // Frame overrun mask
            dterrm: u1, // Data toggle error mask
            _padding_11_31: u21,
        };
        pub const hcintmsk5 = mmio(base_address + 0x1ac, 32, Hcintmsk5);

        /// address: 0x500005cc
        /// OTG_FS host channel-6 mask register (OTG_FS_HCINTMSK6)
        pub const Hcintmsk6 = packed struct {
            xfrcm: u1, // Transfer completed mask
            chhm: u1, // Channel halted mask
            _reserved_2_2: u1,
            stallm: u1, // STALL response received interrupt mask
            nakm: u1, // NAK response received interrupt mask
            ackm: u1, // ACK response received/transmitted interrupt mask
            nyet: u1, // response received interrupt mask
            txerrm: u1, // Transaction error mask
            bberrm: u1, // Babble error mask
            frmorm: u1, // Frame overrun mask
            dterrm: u1, // Data toggle error mask
            _padding_11_31: u21,
        };
        pub const hcintmsk6 = mmio(base_address + 0x1cc, 32, Hcintmsk6);

        /// address: 0x500005ec
        /// OTG_FS host channel-7 mask register (OTG_FS_HCINTMSK7)
        pub const Hcintmsk7 = packed struct {
            xfrcm: u1, // Transfer completed mask
            chhm: u1, // Channel halted mask
            _reserved_2_2: u1,
            stallm: u1, // STALL response received interrupt mask
            nakm: u1, // NAK response received interrupt mask
            ackm: u1, // ACK response received/transmitted interrupt mask
            nyet: u1, // response received interrupt mask
            txerrm: u1, // Transaction error mask
            bberrm: u1, // Babble error mask
            frmorm: u1, // Frame overrun mask
            dterrm: u1, // Data toggle error mask
            _padding_11_31: u21,
        };
        pub const hcintmsk7 = mmio(base_address + 0x1ec, 32, Hcintmsk7);

        /// address: 0x50000510
        /// OTG_FS host channel-0 transfer size register
        pub const Hctsiz0 = packed struct {
            xfrsiz: u19, // Transfer size
            pktcnt: u10, // Packet count
            dpid: u2, // Data PID
            _padding_31_31: u1,
        };
        pub const hctsiz0 = mmio(base_address + 0x110, 32, Hctsiz0);

        /// address: 0x50000530
        /// OTG_FS host channel-1 transfer size register
        pub const Hctsiz1 = packed struct {
            xfrsiz: u19, // Transfer size
            pktcnt: u10, // Packet count
            dpid: u2, // Data PID
            _padding_31_31: u1,
        };
        pub const hctsiz1 = mmio(base_address + 0x130, 32, Hctsiz1);

        /// address: 0x50000550
        /// OTG_FS host channel-2 transfer size register
        pub const Hctsiz2 = packed struct {
            xfrsiz: u19, // Transfer size
            pktcnt: u10, // Packet count
            dpid: u2, // Data PID
            _padding_31_31: u1,
        };
        pub const hctsiz2 = mmio(base_address + 0x150, 32, Hctsiz2);

        /// address: 0x50000570
        /// OTG_FS host channel-3 transfer size register
        pub const Hctsiz3 = packed struct {
            xfrsiz: u19, // Transfer size
            pktcnt: u10, // Packet count
            dpid: u2, // Data PID
            _padding_31_31: u1,
        };
        pub const hctsiz3 = mmio(base_address + 0x170, 32, Hctsiz3);

        /// address: 0x50000590
        /// OTG_FS host channel-x transfer size register
        pub const Hctsiz4 = packed struct {
            xfrsiz: u19, // Transfer size
            pktcnt: u10, // Packet count
            dpid: u2, // Data PID
            _padding_31_31: u1,
        };
        pub const hctsiz4 = mmio(base_address + 0x190, 32, Hctsiz4);

        /// address: 0x500005b0
        /// OTG_FS host channel-5 transfer size register
        pub const Hctsiz5 = packed struct {
            xfrsiz: u19, // Transfer size
            pktcnt: u10, // Packet count
            dpid: u2, // Data PID
            _padding_31_31: u1,
        };
        pub const hctsiz5 = mmio(base_address + 0x1b0, 32, Hctsiz5);

        /// address: 0x500005d0
        /// OTG_FS host channel-6 transfer size register
        pub const Hctsiz6 = packed struct {
            xfrsiz: u19, // Transfer size
            pktcnt: u10, // Packet count
            dpid: u2, // Data PID
            _padding_31_31: u1,
        };
        pub const hctsiz6 = mmio(base_address + 0x1d0, 32, Hctsiz6);

        /// address: 0x500005f0
        /// OTG_FS host channel-7 transfer size register
        pub const Hctsiz7 = packed struct {
            xfrsiz: u19, // Transfer size
            pktcnt: u10, // Packet count
            dpid: u2, // Data PID
            _padding_31_31: u1,
        };
        pub const hctsiz7 = mmio(base_address + 0x1f0, 32, Hctsiz7);
    };
    /// USB on the go full speed
    pub const otg_fs_pwrclk = struct {
        pub const base_address = 0x50000e00;

        /// address: 0x50000e00
        /// OTG_FS power and clock gating control register
        pub const Pcgcctl = packed struct {
            stppclk: u1, // Stop PHY clock
            gatehclk: u1, // Gate HCLK
            _reserved_2_3: u2,
            physusp: u1, // PHY Suspended
            _padding_5_31: u27,
        };
        pub const pcgcctl = mmio(base_address + 0x0, 32, Pcgcctl);
    };
    /// Power control
    pub const pwr = struct {
        pub const base_address = 0x40007000;

        /// address: 0x40007000
        /// power control register
        pub const Cr = packed struct {
            lpds: u1, // Low-power deep sleep
            pdds: u1, // Power down deepsleep
            cwuf: u1, // Clear wakeup flag
            csbf: u1, // Clear standby flag
            pvde: u1, // Power voltage detector enable
            pls: u3, // PVD level selection
            dbp: u1, // Disable backup domain write protection
            fpds: u1, // Flash power down in Stop mode
            _reserved_10_12: u3,
            adcdc1: u1, // ADCDC1
            vos: u2, // Regulator voltage scaling output selection
            _padding_16_31: u16,
        };
        pub const cr = mmio(base_address + 0x0, 32, Cr);

        /// address: 0x40007004
        /// power control/status register
        pub const Csr = packed struct {
            wuf: u1, // Wakeup flag
            sbf: u1, // Standby flag
            pvdo: u1, // PVD output
            brr: u1, // Backup regulator ready
            _reserved_4_7: u4,
            ewup: u1, // Enable WKUP pin
            bre: u1, // Backup regulator enable
            _reserved_10_13: u4,
            vosrdy: u1, // Regulator voltage scaling output selection ready bit
            _padding_15_31: u17,
        };
        pub const csr = mmio(base_address + 0x4, 32, Csr);
    };
    /// Reset and clock control
    pub const rcc = struct {
        pub const base_address = 0x40023800;

        /// address: 0x40023800
        /// clock control register
        pub const Cr = packed struct {
            pub const Hsion = enum(u1) {
                off = 0, // Clock Off
                on = 1, // Clock On
            };
            pub const Hsirdyr = enum(u1) {
                not_ready = 0, // Clock not ready
                ready = 1, // Clock ready
            };
            pub const Hsebyp = enum(u1) {
                not_bypassed = 0, // HSE crystal oscillator not bypassed
                bypassed = 1, // HSE crystal oscillator bypassed with external clock
            };
            pub const Csson = enum(u1) {
                off = 0, // Clock security system disabled (clock detector OFF)
                on = 1, // Clock security system enable (clock detector ON if the HSE is ready, OFF if not)
            };
            hsion: Hsion, // Internal high-speed clock enable (u1)
            hsirdy: Hsirdyr, // Internal high-speed clock ready flag (u1)
            _reserved_2_2: u1,
            hsitrim: u5, // Internal high-speed clock trimming
            hsical: u8, // Internal high-speed clock calibration
            hseon: Hsion, // HSE clock enable (u1)
            hserdy: Hsirdyr, // HSE clock ready flag (u1)
            hsebyp: Hsebyp, // HSE clock bypass (u1)
            csson: Csson, // Clock security system enable (u1)
            _reserved_20_23: u4,
            pllon: Hsion, // Main PLL (PLL) enable (u1)
            pllrdy: Hsirdyr, // Main PLL (PLL) clock ready flag (u1)
            plli2son: Hsion, // PLLI2S enable (u1)
            plli2srdy: Hsirdyr, // PLLI2S clock ready flag (u1)
            _padding_28_31: u4,
        };
        pub const cr = mmio(base_address + 0x0, 32, Cr);

        /// address: 0x40023804
        /// PLL configuration register
        pub const Pllcfgr = packed struct {
            pub const Pllp = enum(u2) {
                div2 = 0b00, // PLLP=2
                div4 = 0b01, // PLLP=4
                div6 = 0b10, // PLLP=6
                div8 = 0b11, // PLLP=8
            };
            pub const Pllsrc = enum(u1) {
                hsi = 0, // HSI clock selected as PLL and PLLI2S clock entry
                hse = 1, // HSE oscillator clock selected as PLL and PLLI2S clock entry
            };
            pllm: u6, // Division factor for the main PLL (PLL) and audio PLL (PLLI2S) input clock
            plln: u9, // Main PLL (PLL) multiplication factor for VCO
            _reserved_15_15: u1,
            pllp: Pllp, // Main PLL (PLL) division factor for main system clock (u2)
            _reserved_18_21: u4,
            pllsrc: Pllsrc, // Main PLL(PLL) and audio PLL (PLLI2S) entry clock source (u1)
            _reserved_23_23: u1,
            pllq: u4, // Main PLL (PLL) division factor for USB OTG FS, SDIO and random number generator clocks
            _padding_28_31: u4,
        };
        pub const pllcfgr = mmio(base_address + 0x4, 32, Pllcfgr);

        /// address: 0x40023808
        /// clock configuration register
        pub const Cfgr = packed struct {
            pub const Sw = enum(u2) {
                hsi = 0b00, // HSI selected as system clock
                hse = 0b01, // HSE selected as system clock
                pll = 0b10, // PLL selected as system clock
            };
            pub const Swsr = enum(u2) {
                hsi = 0b00, // HSI oscillator used as system clock
                hse = 0b01, // HSE oscillator used as system clock
                pll = 0b10, // PLL used as system clock
            };
            pub const Hpre = enum(u4) {
                div1 = 0b0000, // SYSCLK not divided
                div2 = 0b1000, // SYSCLK divided by 2
                div4 = 0b1001, // SYSCLK divided by 4
                div8 = 0b1010, // SYSCLK divided by 8
                div16 = 0b1011, // SYSCLK divided by 16
                div64 = 0b1100, // SYSCLK divided by 64
                div128 = 0b1101, // SYSCLK divided by 128
                div256 = 0b1110, // SYSCLK divided by 256
                div512 = 0b1111, // SYSCLK divided by 512
            };
            pub const Ppre1 = enum(u3) {
                div1 = 0b000, // HCLK not divided
                div2 = 0b100, // HCLK divided by 2
                div4 = 0b101, // HCLK divided by 4
                div8 = 0b110, // HCLK divided by 8
                div16 = 0b111, // HCLK divided by 16
            };
            pub const Mco1 = enum(u2) {
                hsi = 0b00, // HSI clock selected
                lse = 0b01, // LSE oscillator selected
                hse = 0b10, // HSE oscillator clock selected
                pll = 0b11, // PLL clock selected
            };
            pub const I2ssrc = enum(u1) {
                plli2_s = 0, // PLLI2S clock used as I2S clock source
                ckin = 1, // External clock mapped on the I2S_CKIN pin used as I2S clock source
            };
            pub const Mco1pre = enum(u3) {
                div1 = 0b000, // No division
                div2 = 0b100, // Division by 2
                div3 = 0b101, // Division by 3
                div4 = 0b110, // Division by 4
                div5 = 0b111, // Division by 5
            };
            pub const Mco2 = enum(u2) {
                sysclk = 0b00, // System clock (SYSCLK) selected
                plli2_s = 0b01, // PLLI2S clock selected
                hse = 0b10, // HSE oscillator clock selected
                pll = 0b11, // PLL clock selected
            };
            sw: Sw, // System clock switch (u2)
            sws: Swsr, // System clock switch status (u2)
            hpre: Hpre, // AHB prescaler (u4)
            _reserved_8_9: u2,
            ppre1: Ppre1, // APB Low speed prescaler (APB1) (u3)
            ppre2: Ppre1, // APB high-speed prescaler (APB2) (u3)
            rtcpre: u5, // HSE division factor for RTC clock
            mco1: Mco1, // Microcontroller clock output 1 (u2)
            i2ssrc: I2ssrc, // I2S clock selection (u1)
            mco1pre: Mco1pre, // MCO1 prescaler (u3)
            mco2pre: Mco1pre, // MCO2 prescaler (u3)
            mco2: Mco2, // Microcontroller clock output 2 (u2)
        };
        pub const cfgr = mmio(base_address + 0x8, 32, Cfgr);

        /// address: 0x4002380c
        /// clock interrupt register
        pub const Cir = packed struct {
            pub const Lsirdyfr = enum(u1) {
                not_interrupted = 0, // No clock ready interrupt
                interrupted = 1, // Clock ready interrupt
            };
            pub const Cssfr = enum(u1) {
                not_interrupted = 0, // No clock security interrupt caused by HSE clock failure
                interrupted = 1, // Clock security interrupt caused by HSE clock failure
            };
            pub const Lsirdyie = enum(u1) {
                disabled = 0, // Interrupt disabled
                enabled = 1, // Interrupt enabled
            };
            pub const Lsirdycw = enum(u1) {
                clear = 1, // Clear interrupt flag
            };
            pub const Csscw = enum(u1) {
                clear = 1, // Clear CSSF flag
            };
            lsirdyf: Lsirdyfr, // LSI ready interrupt flag (u1)
            lserdyf: Lsirdyfr, // LSE ready interrupt flag (u1)
            hsirdyf: Lsirdyfr, // HSI ready interrupt flag (u1)
            hserdyf: Lsirdyfr, // HSE ready interrupt flag (u1)
            pllrdyf: Lsirdyfr, // Main PLL (PLL) ready interrupt flag (u1)
            plli2srdyf: Lsirdyfr, // PLLI2S ready interrupt flag (u1)
            _reserved_6_6: u1,
            cssf: Cssfr, // Clock security system interrupt flag (u1)
            lsirdyie: Lsirdyie, // LSI ready interrupt enable (u1)
            lserdyie: Lsirdyie, // LSE ready interrupt enable (u1)
            hsirdyie: Lsirdyie, // HSI ready interrupt enable (u1)
            hserdyie: Lsirdyie, // HSE ready interrupt enable (u1)
            pllrdyie: Lsirdyie, // Main PLL (PLL) ready interrupt enable (u1)
            plli2srdyie: Lsirdyie, // PLLI2S ready interrupt enable (u1)
            _reserved_14_15: u2,
            lsirdyc: Lsirdycw, // LSI ready interrupt clear (u1)
            lserdyc: Lsirdycw, // LSE ready interrupt clear (u1)
            hsirdyc: Lsirdycw, // HSI ready interrupt clear (u1)
            hserdyc: Lsirdycw, // HSE ready interrupt clear (u1)
            pllrdyc: Lsirdycw, // Main PLL(PLL) ready interrupt clear (u1)
            plli2srdyc: Lsirdycw, // PLLI2S ready interrupt clear (u1)
            _reserved_22_22: u1,
            cssc: Csscw, // Clock security system interrupt clear (u1)
            _padding_24_31: u8,
        };
        pub const cir = mmio(base_address + 0xc, 32, Cir);

        /// address: 0x40023810
        /// AHB1 peripheral reset register
        pub const Ahb1rstr = packed struct {
            pub const Gpioarst = enum(u1) {
                reset = 1, // Reset the selected module
            };
            gpioarst: Gpioarst, // IO port A reset (u1)
            gpiobrst: Gpioarst, // IO port B reset (u1)
            gpiocrst: Gpioarst, // IO port C reset (u1)
            gpiodrst: Gpioarst, // IO port D reset (u1)
            gpioerst: Gpioarst, // IO port E reset (u1)
            _reserved_5_6: u2,
            gpiohrst: Gpioarst, // IO port H reset (u1)
            _reserved_8_11: u4,
            crcrst: Gpioarst, // CRC reset (u1)
            _reserved_13_20: u8,
            dma1rst: Gpioarst, // DMA2 reset (u1)
            dma2rst: Gpioarst, // DMA2 reset (u1)
            _padding_23_31: u9,
        };
        pub const ahb1rstr = mmio(base_address + 0x10, 32, Ahb1rstr);

        /// address: 0x40023814
        /// AHB2 peripheral reset register
        pub const Ahb2rstr = packed struct {
            pub const Otgfsrst = enum(u1) {
                reset = 1, // Reset the selected module
            };
            _reserved_0_6: u7,
            otgfsrst: Otgfsrst, // USB OTG FS module reset (u1)
            _padding_8_31: u24,
        };
        pub const ahb2rstr = mmio(base_address + 0x14, 32, Ahb2rstr);

        /// address: 0x40023820
        /// APB1 peripheral reset register
        pub const Apb1rstr = packed struct {
            pub const Tim2rst = enum(u1) {
                reset = 1, // Reset the selected module
            };
            tim2rst: Tim2rst, // TIM2 reset (u1)
            tim3rst: Tim2rst, // TIM3 reset (u1)
            tim4rst: Tim2rst, // TIM4 reset (u1)
            tim5rst: Tim2rst, // TIM5 reset (u1)
            _reserved_4_10: u7,
            wwdgrst: Tim2rst, // Window watchdog reset (u1)
            _reserved_12_13: u2,
            spi2rst: Tim2rst, // SPI 2 reset (u1)
            spi3rst: Tim2rst, // SPI 3 reset (u1)
            _reserved_16_16: u1,
            usart2rst: Tim2rst, // USART 2 reset (u1)
            _reserved_18_20: u3,
            i2c1rst: Tim2rst, // I2C 1 reset (u1)
            i2c2rst: Tim2rst, // I2C 2 reset (u1)
            i2c3rst: Tim2rst, // I2C3 reset (u1)
            _reserved_24_27: u4,
            pwrrst: Tim2rst, // Power interface reset (u1)
            _padding_29_31: u3,
        };
        pub const apb1rstr = mmio(base_address + 0x20, 32, Apb1rstr);

        /// address: 0x40023824
        /// APB2 peripheral reset register
        pub const Apb2rstr = packed struct {
            pub const Tim1rst = enum(u1) {
                reset = 1, // Reset the selected module
            };
            tim1rst: Tim1rst, // TIM1 reset (u1)
            _reserved_1_3: u3,
            usart1rst: Tim1rst, // USART1 reset (u1)
            usart6rst: Tim1rst, // USART6 reset (u1)
            _reserved_6_7: u2,
            adcrst: Tim1rst, // ADC interface reset (common to all ADCs) (u1)
            _reserved_9_10: u2,
            sdiorst: Tim1rst, // SDIO reset (u1)
            spi1rst: Tim1rst, // SPI 1 reset (u1)
            spi4rst: Tim1rst, // SPI4 reset (u1)
            syscfgrst: Tim1rst, // System configuration controller reset (u1)
            _reserved_15_15: u1,
            tim9rst: Tim1rst, // TIM9 reset (u1)
            tim10rst: Tim1rst, // TIM10 reset (u1)
            tim11rst: Tim1rst, // TIM11 reset (u1)
            _reserved_19_19: u1,
            spi5rst: Tim1rst, // SPI5 reset (u1)
            _padding_21_31: u11,
        };
        pub const apb2rstr = mmio(base_address + 0x24, 32, Apb2rstr);

        /// address: 0x40023830
        /// AHB1 peripheral clock register
        pub const Ahb1enr = packed struct {
            pub const Gpioaen = enum(u1) {
                disabled = 0, // The selected clock is disabled
                enabled = 1, // The selected clock is enabled
            };
            gpioaen: Gpioaen, // IO port A clock enable (u1)
            gpioben: Gpioaen, // IO port B clock enable (u1)
            gpiocen: Gpioaen, // IO port C clock enable (u1)
            gpioden: Gpioaen, // IO port D clock enable (u1)
            gpioeen: Gpioaen, // IO port E clock enable (u1)
            _reserved_5_6: u2,
            gpiohen: Gpioaen, // IO port H clock enable (u1)
            _reserved_8_11: u4,
            crcen: Gpioaen, // CRC clock enable (u1)
            _reserved_13_20: u8,
            dma1en: Gpioaen, // DMA1 clock enable (u1)
            dma2en: Gpioaen, // DMA2 clock enable (u1)
            _padding_23_31: u9,
        };
        pub const ahb1enr = mmio(base_address + 0x30, 32, Ahb1enr);

        /// address: 0x40023834
        /// AHB2 peripheral clock enable register
        pub const Ahb2enr = packed struct {
            pub const Otgfsen = enum(u1) {
                disabled = 0, // The selected clock is disabled
                enabled = 1, // The selected clock is enabled
            };
            _reserved_0_6: u7,
            otgfsen: Otgfsen, // USB OTG FS clock enable (u1)
            _padding_8_31: u24,
        };
        pub const ahb2enr = mmio(base_address + 0x34, 32, Ahb2enr);

        /// address: 0x40023840
        /// APB1 peripheral clock enable register
        pub const Apb1enr = packed struct {
            pub const Tim2en = enum(u1) {
                disabled = 0, // The selected clock is disabled
                enabled = 1, // The selected clock is enabled
            };
            tim2en: Tim2en, // TIM2 clock enable (u1)
            tim3en: Tim2en, // TIM3 clock enable (u1)
            tim4en: Tim2en, // TIM4 clock enable (u1)
            tim5en: Tim2en, // TIM5 clock enable (u1)
            _reserved_4_10: u7,
            wwdgen: Tim2en, // Window watchdog clock enable (u1)
            _reserved_12_13: u2,
            spi2en: Tim2en, // SPI2 clock enable (u1)
            spi3en: Tim2en, // SPI3 clock enable (u1)
            _reserved_16_16: u1,
            usart2en: Tim2en, // USART 2 clock enable (u1)
            _reserved_18_20: u3,
            i2c1en: Tim2en, // I2C1 clock enable (u1)
            i2c2en: Tim2en, // I2C2 clock enable (u1)
            i2c3en: Tim2en, // I2C3 clock enable (u1)
            _reserved_24_27: u4,
            pwren: Tim2en, // Power interface clock enable (u1)
            _padding_29_31: u3,
        };
        pub const apb1enr = mmio(base_address + 0x40, 32, Apb1enr);

        /// address: 0x40023844
        /// APB2 peripheral clock enable register
        pub const Apb2enr = packed struct {
            pub const Tim1en = enum(u1) {
                disabled = 0, // The selected clock is disabled
                enabled = 1, // The selected clock is enabled
            };
            tim1en: Tim1en, // TIM1 clock enable (u1)
            _reserved_1_3: u3,
            usart1en: Tim1en, // USART1 clock enable (u1)
            usart6en: Tim1en, // USART6 clock enable (u1)
            _reserved_6_7: u2,
            adc1en: Tim1en, // ADC1 clock enable (u1)
            _reserved_9_10: u2,
            sdioen: Tim1en, // SDIO clock enable (u1)
            spi1en: Tim1en, // SPI1 clock enable (u1)
            spi4en: Tim1en, // SPI4 clock enable (u1)
            syscfgen: Tim1en, // System configuration controller clock enable (u1)
            _reserved_15_15: u1,
            tim9en: Tim1en, // TIM9 clock enable (u1)
            tim10en: Tim1en, // TIM10 clock enable (u1)
            tim11en: Tim1en, // TIM11 clock enable (u1)
            _reserved_19_19: u1,
            spi5en: Tim1en, // SPI5 clock enable (u1)
            _padding_21_31: u11,
        };
        pub const apb2enr = mmio(base_address + 0x44, 32, Apb2enr);

        /// address: 0x40023850
        /// AHB1 peripheral clock enable in low power mode register
        pub const Ahb1lpenr = packed struct {
            pub const Gpioalpen = enum(u1) {
                disabled_in_sleep = 0, // Selected module is disabled during Sleep mode
                enabled_in_sleep = 1, // Selected module is enabled during Sleep mode
            };
            gpioalpen: Gpioalpen, // IO port A clock enable during sleep mode (u1)
            gpioblpen: Gpioalpen, // IO port B clock enable during Sleep mode (u1)
            gpioclpen: Gpioalpen, // IO port C clock enable during Sleep mode (u1)
            gpiodlpen: Gpioalpen, // IO port D clock enable during Sleep mode (u1)
            gpioelpen: Gpioalpen, // IO port E clock enable during Sleep mode (u1)
            _reserved_5_6: u2,
            gpiohlpen: Gpioalpen, // IO port H clock enable during Sleep mode (u1)
            _reserved_8_11: u4,
            crclpen: Gpioalpen, // CRC clock enable during Sleep mode (u1)
            _reserved_13_14: u2,
            flitflpen: Gpioalpen, // Flash interface clock enable during Sleep mode (u1)
            sram1lpen: Gpioalpen, // SRAM 1interface clock enable during Sleep mode (u1)
            _reserved_17_20: u4,
            dma1lpen: Gpioalpen, // DMA1 clock enable during Sleep mode (u1)
            dma2lpen: Gpioalpen, // DMA2 clock enable during Sleep mode (u1)
            _padding_23_31: u9,
        };
        pub const ahb1lpenr = mmio(base_address + 0x50, 32, Ahb1lpenr);

        /// address: 0x40023854
        /// AHB2 peripheral clock enable in low power mode register
        pub const Ahb2lpenr = packed struct {
            pub const Otgfslpen = enum(u1) {
                disabled_in_sleep = 0, // Selected module is disabled during Sleep mode
                enabled_in_sleep = 1, // Selected module is enabled during Sleep mode
            };
            _reserved_0_6: u7,
            otgfslpen: Otgfslpen, // USB OTG FS clock enable during Sleep mode (u1)
            _padding_8_31: u24,
        };
        pub const ahb2lpenr = mmio(base_address + 0x54, 32, Ahb2lpenr);

        /// address: 0x40023860
        /// APB1 peripheral clock enable in low power mode register
        pub const Apb1lpenr = packed struct {
            pub const Tim2lpen = enum(u1) {
                disabled_in_sleep = 0, // Selected module is disabled during Sleep mode
                enabled_in_sleep = 1, // Selected module is enabled during Sleep mode
            };
            tim2lpen: Tim2lpen, // TIM2 clock enable during Sleep mode (u1)
            tim3lpen: Tim2lpen, // TIM3 clock enable during Sleep mode (u1)
            tim4lpen: Tim2lpen, // TIM4 clock enable during Sleep mode (u1)
            tim5lpen: Tim2lpen, // TIM5 clock enable during Sleep mode (u1)
            _reserved_4_10: u7,
            wwdglpen: Tim2lpen, // Window watchdog clock enable during Sleep mode (u1)
            _reserved_12_13: u2,
            spi2lpen: Tim2lpen, // SPI2 clock enable during Sleep mode (u1)
            spi3lpen: Tim2lpen, // SPI3 clock enable during Sleep mode (u1)
            _reserved_16_16: u1,
            usart2lpen: Tim2lpen, // USART2 clock enable during Sleep mode (u1)
            _reserved_18_20: u3,
            i2c1lpen: Tim2lpen, // I2C1 clock enable during Sleep mode (u1)
            i2c2lpen: Tim2lpen, // I2C2 clock enable during Sleep mode (u1)
            i2c3lpen: Tim2lpen, // I2C3 clock enable during Sleep mode (u1)
            _reserved_24_27: u4,
            pwrlpen: Tim2lpen, // Power interface clock enable during Sleep mode (u1)
            _padding_29_31: u3,
        };
        pub const apb1lpenr = mmio(base_address + 0x60, 32, Apb1lpenr);

        /// address: 0x40023864
        /// APB2 peripheral clock enabled in low power mode register
        pub const Apb2lpenr = packed struct {
            pub const Tim1lpen = enum(u1) {
                disabled_in_sleep = 0, // Selected module is disabled during Sleep mode
                enabled_in_sleep = 1, // Selected module is enabled during Sleep mode
            };
            tim1lpen: Tim1lpen, // TIM1 clock enable during Sleep mode (u1)
            _reserved_1_3: u3,
            usart1lpen: Tim1lpen, // USART1 clock enable during Sleep mode (u1)
            usart6lpen: Tim1lpen, // USART6 clock enable during Sleep mode (u1)
            _reserved_6_7: u2,
            adc1lpen: Tim1lpen, // ADC1 clock enable during Sleep mode (u1)
            _reserved_9_10: u2,
            sdiolpen: Tim1lpen, // SDIO clock enable during Sleep mode (u1)
            spi1lpen: Tim1lpen, // SPI 1 clock enable during Sleep mode (u1)
            spi4lpen: Tim1lpen, // SPI4 clock enable during Sleep mode (u1)
            syscfglpen: Tim1lpen, // System configuration controller clock enable during Sleep mode (u1)
            _reserved_15_15: u1,
            tim9lpen: Tim1lpen, // TIM9 clock enable during sleep mode (u1)
            tim10lpen: Tim1lpen, // TIM10 clock enable during Sleep mode (u1)
            tim11lpen: Tim1lpen, // TIM11 clock enable during Sleep mode (u1)
            _reserved_19_19: u1,
            spi5lpen: Tim1lpen, // SPI5 clock enable during Sleep mode (u1)
            _padding_21_31: u11,
        };
        pub const apb2lpenr = mmio(base_address + 0x64, 32, Apb2lpenr);

        /// address: 0x40023870
        /// Backup domain control register
        pub const Bdcr = packed struct {
            pub const Lseon = enum(u1) {
                off = 0, // LSE oscillator Off
                on = 1, // LSE oscillator On
            };
            pub const Lserdyr = enum(u1) {
                not_ready = 0, // LSE oscillator not ready
                ready = 1, // LSE oscillator ready
            };
            pub const Lsebyp = enum(u1) {
                not_bypassed = 0, // LSE crystal oscillator not bypassed
                bypassed = 1, // LSE crystal oscillator bypassed with external clock
            };
            pub const Lsemod = enum(u1) {
                low = 0, // LSE oscillator low power mode selection
                high = 1, // LSE oscillator high drive mode selection
            };
            pub const Rtcsel = enum(u2) {
                no_clock = 0b00, // No clock
                lse = 0b01, // LSE oscillator clock used as RTC clock
                lsi = 0b10, // LSI oscillator clock used as RTC clock
                hse = 0b11, // HSE oscillator clock divided by a prescaler used as RTC clock
            };
            pub const Rtcen = enum(u1) {
                disabled = 0, // RTC clock disabled
                enabled = 1, // RTC clock enabled
            };
            pub const Bdrst = enum(u1) {
                disabled = 0, // Reset not activated
                enabled = 1, // Reset the entire RTC domain
            };
            lseon: Lseon, // External low-speed oscillator enable (u1)
            lserdy: Lserdyr, // External low-speed oscillator ready (u1)
            lsebyp: Lsebyp, // External low-speed oscillator bypass (u1)
            lsemod: Lsemod, // External low speed oscillator (u1)
            _reserved_4_7: u4,
            rtcsel: Rtcsel, // RTC clock source selection (u2)
            _reserved_10_14: u5,
            rtcen: Rtcen, // RTC clock enable (u1)
            bdrst: Bdrst, // Backup domain software reset (u1)
            _padding_17_31: u15,
        };
        pub const bdcr = mmio(base_address + 0x70, 32, Bdcr);

        /// address: 0x40023874
        /// clock control & status register
        pub const Csr = packed struct {
            pub const Lsion = enum(u1) {
                off = 0, // LSI oscillator Off
                on = 1, // LSI oscillator On
            };
            pub const Lsirdyr = enum(u1) {
                not_ready = 0, // LSI oscillator not ready
                ready = 1, // LSI oscillator ready
            };
            pub const Rmvfw = enum(u1) {
                clear = 1, // Clears the reset flag
            };
            pub const Borrstfr = enum(u1) {
                no_reset = 0, // No reset has occured
                reset = 1, // A reset has occured
            };
            lsion: Lsion, // Internal low-speed oscillator enable (u1)
            lsirdy: Lsirdyr, // Internal low-speed oscillator ready (u1)
            _reserved_2_23: u22,
            rmvf: Rmvfw, // Remove reset flag (u1)
            borrstf: Borrstfr, // BOR reset flag (u1)
            padrstf: Borrstfr, // PIN reset flag (u1)
            porrstf: Borrstfr, // POR/PDR reset flag (u1)
            sftrstf: Borrstfr, // Software reset flag (u1)
            wdgrstf: Borrstfr, // Independent watchdog reset flag (u1)
            wwdgrstf: Borrstfr, // Window watchdog reset flag (u1)
            lpwrrstf: Borrstfr, // Low-power reset flag (u1)
        };
        pub const csr = mmio(base_address + 0x74, 32, Csr);

        /// address: 0x40023880
        /// spread spectrum clock generation register
        pub const Sscgr = packed struct {
            pub const Spreadsel = enum(u1) {
                center = 0, // Center spread
                down = 1, // Down spread
            };
            pub const Sscgen = enum(u1) {
                disabled = 0, // Spread spectrum modulation disabled
                enabled = 1, // Spread spectrum modulation enabled
            };
            modper: u13, // Modulation period
            incstep: u15, // Incrementation step
            _reserved_28_29: u2,
            spreadsel: Spreadsel, // Spread Select (u1)
            sscgen: Sscgen, // Spread spectrum modulation enable (u1)
        };
        pub const sscgr = mmio(base_address + 0x80, 32, Sscgr);

        /// address: 0x40023884
        /// PLLI2S configuration register
        pub const Plli2scfgr = packed struct {
            plli2sm: u6, // Division factor for the audio PLL (PLLI2S) input clock
            plli2sn: u9, // PLLI2S multiplication factor for VCO
            _reserved_15_27: u13,
            plli2sr: u3, // PLLI2S division factor for I2S clocks
            _padding_31_31: u1,
        };
        pub const plli2scfgr = mmio(base_address + 0x84, 32, Plli2scfgr);

        /// address: 0x4002388c
        /// RCC Dedicated Clock Configuration Register
        pub const Dckcfgr = packed struct {
            pub const Timpre = enum(u1) {
                mul2 = 0, // If the APB prescaler is configured 1, TIMxCLK = PCLKx. Otherwise, TIMxCLK = 2xPCLKx
                mul4 = 1, // If the APB prescaler is configured 1, 2 or 4, TIMxCLK = HCLK. Otherwise, TIMxCLK = 4xPCLKx
            };
            _reserved_0_23: u24,
            timpre: Timpre, // Timers clocks prescalers selection (u1)
            _padding_25_31: u7,
        };
        pub const dckcfgr = mmio(base_address + 140, 32, Dckcfgr);
    };
    /// Real-time clock
    pub const rtc = struct {
        pub const base_address = 0x40002800;

        /// address: 0x40002800
        /// time register
        pub const Tr = packed struct {
            pub const Pm = enum(u1) {
                am = 0, // AM or 24-hour format
                pm = 1, // PM
            };
            su: u4, // Second units in BCD format
            st: u3, // Second tens in BCD format
            _reserved_7_7: u1,
            mnu: u4, // Minute units in BCD format
            mnt: u3, // Minute tens in BCD format
            _reserved_15_15: u1,
            hu: u4, // Hour units in BCD format
            ht: u2, // Hour tens in BCD format
            pm: Pm, // AM/PM notation (u1)
            _padding_23_31: u9,
        };
        pub const tr = mmio(base_address + 0x0, 32, Tr);

        /// address: 0x40002804
        /// date register
        pub const Dr = packed struct {
            du: u4, // Date units in BCD format
            dt: u2, // Date tens in BCD format
            _reserved_6_7: u2,
            mu: u4, // Month units in BCD format
            mt: u1, // Month tens in BCD format
            wdu: u3, // Week day units
            yu: u4, // Year units in BCD format
            yt: u4, // Year tens in BCD format
            _padding_24_31: u8,
        };
        pub const dr = mmio(base_address + 0x4, 32, Dr);

        /// address: 0x40002808
        /// control register
        pub const Cr = packed struct {
            pub const Wucksel = enum(u3) {
                div16 = 0b000, // RTC/16 clock is selected
                div8 = 0b001, // RTC/8 clock is selected
                div4 = 0b010, // RTC/4 clock is selected
                div2 = 0b011, // RTC/2 clock is selected
                clock_spare = 0b100, // ck_spre (usually 1 Hz) clock is selected
                clock_spare_with_offset = 0b110, // ck_spre (usually 1 Hz) clock is selected and 2^16 is added to the WUT counter value
            };
            pub const Tsedge = enum(u1) {
                rising_edge = 0, // RTC_TS input rising edge generates a time-stamp event
                falling_edge = 1, // RTC_TS input falling edge generates a time-stamp event
            };
            pub const Refckon = enum(u1) {
                disabled = 0, // RTC_REFIN detection disabled
                enabled = 1, // RTC_REFIN detection enabled
            };
            pub const Bypshad = enum(u1) {
                shadow_reg = 0, // Calendar values (when reading from RTC_SSR, RTC_TR, and RTC_DR) are taken from the shadow registers, which are updated once every two RTCCLK cycles
                bypass_shadow_reg = 1, // Calendar values (when reading from RTC_SSR, RTC_TR, and RTC_DR) are taken directly from the calendar counters
            };
            pub const Fmt = enum(u1) {
                twenty_four_hour = 0, // 24 hour/day format
                am_pm = 1, // AM/PM hour format
            };
            pub const Alrae = enum(u1) {
                disabled = 0, // Alarm A disabled
                enabled = 1, // Alarm A enabled
            };
            pub const Alrbe = enum(u1) {
                disabled = 0, // Alarm B disabled
                enabled = 1, // Alarm B enabled
            };
            pub const Wute = enum(u1) {
                disabled = 0, // Wakeup timer disabled
                enabled = 1, // Wakeup timer enabled
            };
            pub const Tse = enum(u1) {
                disabled = 0, // Timestamp disabled
                enabled = 1, // Timestamp enabled
            };
            pub const Alraie = enum(u1) {
                disabled = 0, // Alarm A interrupt disabled
                enabled = 1, // Alarm A interrupt enabled
            };
            pub const Alrbie = enum(u1) {
                disabled = 0, // Alarm B Interrupt disabled
                enabled = 1, // Alarm B Interrupt enabled
            };
            pub const Wutie = enum(u1) {
                disabled = 0, // Wakeup timer interrupt disabled
                enabled = 1, // Wakeup timer interrupt enabled
            };
            pub const Tsie = enum(u1) {
                disabled = 0, // Time-stamp Interrupt disabled
                enabled = 1, // Time-stamp Interrupt enabled
            };
            pub const Add1hw = enum(u1) {
                add1 = 1, // Adds 1 hour to the current time. This can be used for summer time change outside initialization mode
            };
            pub const Sub1hw = enum(u1) {
                sub1 = 1, // Subtracts 1 hour to the current time. This can be used for winter time change outside initialization mode
            };
            pub const Bkp = enum(u1) {
                dst_not_changed = 0, // Daylight Saving Time change has not been performed
                dst_changed = 1, // Daylight Saving Time change has been performed
            };
            pub const Cosel = enum(u1) {
                cal_freq_512_hz = 0, // Calibration output is 512 Hz (with default prescaler setting)
                cal_freq_1_hz = 1, // Calibration output is 1 Hz (with default prescaler setting)
            };
            pub const Pol = enum(u1) {
                high = 0, // The pin is high when ALRAF/ALRBF/WUTF is asserted (depending on OSEL[1:0])
                low = 1, // The pin is low when ALRAF/ALRBF/WUTF is asserted (depending on OSEL[1:0])
            };
            pub const Osel = enum(u2) {
                disabled = 0b00, // Output disabled
                alarm_a = 0b01, // Alarm A output enabled
                alarm_b = 0b10, // Alarm B output enabled
                wakeup = 0b11, // Wakeup output enabled
            };
            pub const Coe = enum(u1) {
                disabled = 0, // Calibration output disabled
                enabled = 1, // Calibration output enabled
            };
            wucksel: Wucksel, // Wakeup clock selection (u3)
            tsedge: Tsedge, // Time-stamp event active edge (u1)
            refckon: Refckon, // Reference clock detection enable (50 or 60 Hz) (u1)
            bypshad: Bypshad, // Bypass the shadow registers (u1)
            fmt: Fmt, // Hour format (u1)
            dce: u1, // Coarse digital calibration enable
            alrae: Alrae, // Alarm A enable (u1)
            alrbe: Alrbe, // Alarm B enable (u1)
            wute: Wute, // Wakeup timer enable (u1)
            tse: Tse, // Time stamp enable (u1)
            alraie: Alraie, // Alarm A interrupt enable (u1)
            alrbie: Alrbie, // Alarm B interrupt enable (u1)
            wutie: Wutie, // Wakeup timer interrupt enable (u1)
            tsie: Tsie, // Time-stamp interrupt enable (u1)
            add1h: Add1hw, // Add 1 hour (summer time change) (u1)
            sub1h: Sub1hw, // Subtract 1 hour (winter time change) (u1)
            bkp: Bkp, // Backup (u1)
            cosel: Cosel, // Calibration Output selection (u1)
            pol: Pol, // Output polarity (u1)
            osel: Osel, // Output selection (u2)
            coe: Coe, // Calibration output enable (u1)
            _padding_24_31: u8,
        };
        pub const cr = mmio(base_address + 0x8, 32, Cr);

        /// address: 0x4000280c
        /// initialization and status register
        pub const Isr = packed struct {
            pub const Alrawfr = enum(u1) {
                update_not_allowed = 0, // Alarm update not allowed
                update_allowed = 1, // Alarm update allowed
            };
            pub const Wutwfr = enum(u1) {
                update_not_allowed = 0, // Wakeup timer configuration update not allowed
                update_allowed = 1, // Wakeup timer configuration update allowed
            };
            pub const Shpfr = enum(u1) {
                no_shift_pending = 0, // No shift operation is pending
                shift_pending = 1, // A shift operation is pending
            };
            pub const Initsr = enum(u1) {
                not_initalized = 0, // Calendar has not been initialized
                initalized = 1, // Calendar has been initialized
            };
            pub const Rsf = enum(u1) {
                not_synced = 0, // Calendar shadow registers not yet synchronized
                synced = 1, // Calendar shadow registers synchronized
                pub const clear = @intToEnum(Rsf, 0); // This flag is cleared by software by writing 0
            };
            pub const Initfr = enum(u1) {
                not_allowed = 0, // Calendar registers update is not allowed
                allowed = 1, // Calendar registers update is allowed
            };
            pub const Init = enum(u1) {
                free_running_mode = 0, // Free running mode
                init_mode = 1, // Initialization mode used to program time and date register (RTC_TR and RTC_DR), and prescaler register (RTC_PRER). Counters are stopped and start counting from the new value when INIT is reset.
            };
            pub const Alraf = enum(u1) {
                match = 1, // This flag is set by hardware when the time/date registers (RTC_TR and RTC_DR) match the Alarm A register (RTC_ALRMAR)
                clear = 0, // This flag is cleared by software by writing 0
            };
            pub const Alrbf = enum(u1) {
                match = 1, // This flag is set by hardware when the time/date registers (RTC_TR and RTC_DR) match the Alarm B register (RTC_ALRMBR)
                clear = 0, // This flag is cleared by software by writing 0
            };
            pub const Wutf = enum(u1) {
                zero = 1, // This flag is set by hardware when the wakeup auto-reload counter reaches 0
                clear = 0, // This flag is cleared by software by writing 0
            };
            pub const Tsf = enum(u1) {
                timestamp_event = 1, // This flag is set by hardware when a time-stamp event occurs
                clear = 0, // This flag is cleared by software by writing 0
            };
            pub const Tsovf = enum(u1) {
                overflow = 1, // This flag is set by hardware when a time-stamp event occurs while TSF is already set
                clear = 0, // This flag is cleared by software by writing 0
            };
            pub const Tamp1f = enum(u1) {
                tampered = 1, // This flag is set by hardware when a tamper detection event is detected on the RTC_TAMPx input
                clear = 0, // Flag cleared by software writing 0
            };
            pub const Recalpfr = enum(u1) {
                pending = 1, // The RECALPF status flag is automatically set to 1 when software writes to the RTC_CALR register, indicating that the RTC_CALR register is blocked. When the new calibration settings are taken into account, this bit returns to 0
            };
            alrawf: Alrawfr, // Alarm A write flag (u1)
            alrbwf: Alrawfr, // Alarm B write flag (u1)
            wutwf: Wutwfr, // Wakeup timer write flag (u1)
            shpf: Shpfr, // Shift operation pending (u1)
            inits: Initsr, // Initialization status flag (u1)
            rsf: Rsf, // Registers synchronization flag (u1)
            initf: Initfr, // Initialization flag (u1)
            init: Init, // Initialization mode (u1)
            alraf: Alraf, // Alarm A flag (u1)
            alrbf: Alrbf, // Alarm B flag (u1)
            wutf: Wutf, // Wakeup timer flag (u1)
            tsf: Tsf, // Time-stamp flag (u1)
            tsovf: Tsovf, // Time-stamp overflow flag (u1)
            tamp1f: Tamp1f, // Tamper detection flag (u1)
            tamp2f: Tamp1f, // TAMPER2 detection flag (u1)
            _reserved_15_15: u1,
            recalpf: Recalpfr, // Recalibration pending Flag (u1)
            _padding_17_31: u15,
        };
        pub const isr = mmio(base_address + 0xc, 32, Isr);

        /// address: 0x40002810
        /// prescaler register
        pub const Prer = packed struct {
            prediv_s: u15, // Synchronous prescaler factor
            _reserved_15_15: u1,
            prediv_a: u7, // Asynchronous prescaler factor
            _padding_23_31: u9,
        };
        pub const prer = mmio(base_address + 0x10, 32, Prer);

        /// address: 0x40002814
        /// wakeup timer register
        pub const Wutr = packed struct {
            wut: u16, // Wakeup auto-reload value bits
            _padding_16_31: u16,
        };
        pub const wutr = mmio(base_address + 0x14, 32, Wutr);

        /// address: 0x40002818
        /// calibration register
        pub const Calibr = packed struct {
            dc: u5, // Digital calibration
            _reserved_5_6: u2,
            dcs: u1, // Digital calibration sign
            _padding_8_31: u24,
        };
        pub const calibr = mmio(base_address + 0x18, 32, Calibr);

        /// address: 0x4000281c
        /// Alarm register
        pub const Alrmar = packed struct {
            pub const Msk1 = enum(u1) {
                mask = 0, // Alarm set if the date/day match
                not_mask = 1, // Date/day dont care in Alarm comparison
            };
            pub const Pm = enum(u1) {
                am = 0, // AM or 24-hour format
                pm = 1, // PM
            };
            pub const Wdsel = enum(u1) {
                date_units = 0, // DU[3:0] represents the date units
                week_day = 1, // DU[3:0] represents the week day. DT[1:0] is dont care.
            };
            su: u4, // Second units in BCD format
            st: u3, // Second tens in BCD format
            msk1: Msk1, // Alarm seconds mask (u1)
            mnu: u4, // Minute units in BCD format
            mnt: u3, // Minute tens in BCD format
            msk2: Msk1, // Alarm minutes mask (u1)
            hu: u4, // Hour units in BCD format
            ht: u2, // Hour tens in BCD format
            pm: Pm, // AM/PM notation (u1)
            msk3: Msk1, // Alarm hours mask (u1)
            du: u4, // Date units or day in BCD format
            dt: u2, // Date tens in BCD format
            wdsel: Wdsel, // Week day selection (u1)
            msk4: Msk1, // Alarm date mask (u1)
        };
        pub const alrmar = mmio(base_address + 0x1c, 32, Alrmar);

        /// address: 0x40002820
        /// Alarm register
        pub const Alrmbr = packed struct {
            pub const Msk1 = enum(u1) {
                mask = 0, // Alarm set if the date/day match
                not_mask = 1, // Date/day dont care in Alarm comparison
            };
            pub const Pm = enum(u1) {
                am = 0, // AM or 24-hour format
                pm = 1, // PM
            };
            pub const Wdsel = enum(u1) {
                date_units = 0, // DU[3:0] represents the date units
                week_day = 1, // DU[3:0] represents the week day. DT[1:0] is dont care.
            };
            su: u4, // Second units in BCD format
            st: u3, // Second tens in BCD format
            msk1: Msk1, // Alarm seconds mask (u1)
            mnu: u4, // Minute units in BCD format
            mnt: u3, // Minute tens in BCD format
            msk2: Msk1, // Alarm minutes mask (u1)
            hu: u4, // Hour units in BCD format
            ht: u2, // Hour tens in BCD format
            pm: Pm, // AM/PM notation (u1)
            msk3: Msk1, // Alarm hours mask (u1)
            du: u4, // Date units or day in BCD format
            dt: u2, // Date tens in BCD format
            wdsel: Wdsel, // Week day selection (u1)
            msk4: Msk1, // Alarm date mask (u1)
        };
        pub const alrmbr = mmio(base_address + 0x20, 32, Alrmbr);

        /// address: 0x40002824
        /// write protection register
        pub const Wpr = packed struct {
            key: u8, // Write protection key
            _padding_8_31: u24,
        };
        pub const wpr = mmio(base_address + 0x24, 32, Wpr);

        /// address: 0x40002828
        /// sub second register
        pub const Ssr = packed struct {
            ss: u16, // Sub second value
            _padding_16_31: u16,
        };
        pub const ssr = mmio(base_address + 0x28, 32, Ssr);

        /// address: 0x4000282c
        /// shift control register
        pub const Shiftr = packed struct {
            pub const Add1sw = enum(u1) {
                add1 = 1, // Add one second to the clock/calendar
            };
            subfs: u15, // Subtract a fraction of a second
            _reserved_15_30: u16,
            add1s: Add1sw, // Add one second (u1)
        };
        pub const shiftr = mmio(base_address + 0x2c, 32, Shiftr);

        /// address: 0x4000283c
        /// calibration register
        pub const Calr = packed struct {
            pub const Calw16 = enum(u1) {
                sixteen_second = 1, // When CALW16 is set to 1, the 16-second calibration cycle period is selected.This bit must not be set to 1 if CALW8=1
            };
            pub const Calw8 = enum(u1) {
                eight_second = 1, // When CALW8 is set to 1, the 8-second calibration cycle period is selected
            };
            pub const Calp = enum(u1) {
                no_change = 0, // No RTCCLK pulses are added
                increase_freq = 1, // One RTCCLK pulse is effectively inserted every 2^11 pulses (frequency increased by 488.5 ppm)
            };
            calm: u9, // Calibration minus
            _reserved_9_12: u4,
            calw16: Calw16, // Use a 16-second calibration cycle period (u1)
            calw8: Calw8, // Use an 8-second calibration cycle period (u1)
            calp: Calp, // Increase frequency of RTC by 488.5 ppm (u1)
            _padding_16_31: u16,
        };
        pub const calr = mmio(base_address + 0x3c, 32, Calr);

        /// address: 0x40002840
        /// tamper and alternate function configuration register
        pub const Tafcr = packed struct {
            tamp1e: u1, // Tamper 1 detection enable
            tamp1trg: u1, // Active level for tamper 1
            tampie: u1, // Tamper interrupt enable
            tamp2e: u1, // Tamper 2 detection enable
            tamp2trg: u1, // Active level for tamper 2
            _reserved_5_6: u2,
            tampts: u1, // Activate timestamp on tamper detection event
            tampfreq: u3, // Tamper sampling frequency
            tampflt: u2, // Tamper filter count
            tampprch: u2, // Tamper precharge duration
            tamppudis: u1, // TAMPER pull-up disable
            tamp1insel: u1, // TAMPER1 mapping
            tsinsel: u1, // TIMESTAMP mapping
            alarmouttype: u1, // AFO_ALARM output type
            _padding_19_31: u13,
        };
        pub const tafcr = mmio(base_address + 0x40, 32, Tafcr);

        /// address: 0x40002844
        /// Alarm sub-second register
        pub const Alrmassr = packed struct {
            ss: u15, // Sub seconds value
            _reserved_15_23: u9,
            maskss: u4, // Mask the most-significant bits starting at this bit
            _padding_28_31: u4,
        };
        pub const alrmassr = mmio(base_address + 0x44, 32, Alrmassr);

        /// address: 0x40002848
        /// Alarm sub-second register
        pub const Alrmbssr = packed struct {
            ss: u15, // Sub seconds value
            _reserved_15_23: u9,
            maskss: u4, // Mask the most-significant bits starting at this bit
            _padding_28_31: u4,
        };
        pub const alrmbssr = mmio(base_address + 0x48, 32, Alrmbssr);

        /// address: 0x40002850
        /// backup register
        pub const Bkp0r = packed struct {
            bkp: u32, // BKP
        };
        pub const bkp0r = mmio(base_address + 0x50, 32, Bkp0r);

        /// address: 0x40002854
        /// backup register
        pub const Bkp1r = packed struct {
            bkp: u32, // BKP
        };
        pub const bkp1r = mmio(base_address + 0x54, 32, Bkp1r);

        /// address: 0x40002858
        /// backup register
        pub const Bkp2r = packed struct {
            bkp: u32, // BKP
        };
        pub const bkp2r = mmio(base_address + 0x58, 32, Bkp2r);

        /// address: 0x4000285c
        /// backup register
        pub const Bkp3r = packed struct {
            bkp: u32, // BKP
        };
        pub const bkp3r = mmio(base_address + 0x5c, 32, Bkp3r);

        /// address: 0x40002860
        /// backup register
        pub const Bkp4r = packed struct {
            bkp: u32, // BKP
        };
        pub const bkp4r = mmio(base_address + 0x60, 32, Bkp4r);

        /// address: 0x40002864
        /// backup register
        pub const Bkp5r = packed struct {
            bkp: u32, // BKP
        };
        pub const bkp5r = mmio(base_address + 0x64, 32, Bkp5r);

        /// address: 0x40002868
        /// backup register
        pub const Bkp6r = packed struct {
            bkp: u32, // BKP
        };
        pub const bkp6r = mmio(base_address + 0x68, 32, Bkp6r);

        /// address: 0x4000286c
        /// backup register
        pub const Bkp7r = packed struct {
            bkp: u32, // BKP
        };
        pub const bkp7r = mmio(base_address + 0x6c, 32, Bkp7r);

        /// address: 0x40002870
        /// backup register
        pub const Bkp8r = packed struct {
            bkp: u32, // BKP
        };
        pub const bkp8r = mmio(base_address + 0x70, 32, Bkp8r);

        /// address: 0x40002874
        /// backup register
        pub const Bkp9r = packed struct {
            bkp: u32, // BKP
        };
        pub const bkp9r = mmio(base_address + 0x74, 32, Bkp9r);

        /// address: 0x40002878
        /// backup register
        pub const Bkp10r = packed struct {
            bkp: u32, // BKP
        };
        pub const bkp10r = mmio(base_address + 0x78, 32, Bkp10r);

        /// address: 0x4000287c
        /// backup register
        pub const Bkp11r = packed struct {
            bkp: u32, // BKP
        };
        pub const bkp11r = mmio(base_address + 0x7c, 32, Bkp11r);

        /// address: 0x40002880
        /// backup register
        pub const Bkp12r = packed struct {
            bkp: u32, // BKP
        };
        pub const bkp12r = mmio(base_address + 0x80, 32, Bkp12r);

        /// address: 0x40002884
        /// backup register
        pub const Bkp13r = packed struct {
            bkp: u32, // BKP
        };
        pub const bkp13r = mmio(base_address + 0x84, 32, Bkp13r);

        /// address: 0x40002888
        /// backup register
        pub const Bkp14r = packed struct {
            bkp: u32, // BKP
        };
        pub const bkp14r = mmio(base_address + 0x88, 32, Bkp14r);

        /// address: 0x4000288c
        /// backup register
        pub const Bkp15r = packed struct {
            bkp: u32, // BKP
        };
        pub const bkp15r = mmio(base_address + 0x8c, 32, Bkp15r);

        /// address: 0x40002890
        /// backup register
        pub const Bkp16r = packed struct {
            bkp: u32, // BKP
        };
        pub const bkp16r = mmio(base_address + 0x90, 32, Bkp16r);

        /// address: 0x40002894
        /// backup register
        pub const Bkp17r = packed struct {
            bkp: u32, // BKP
        };
        pub const bkp17r = mmio(base_address + 0x94, 32, Bkp17r);

        /// address: 0x40002898
        /// backup register
        pub const Bkp18r = packed struct {
            bkp: u32, // BKP
        };
        pub const bkp18r = mmio(base_address + 0x98, 32, Bkp18r);

        /// address: 0x4000289c
        /// backup register
        pub const Bkp19r = packed struct {
            bkp: u32, // BKP
        };
        pub const bkp19r = mmio(base_address + 0x9c, 32, Bkp19r);

        /// address: 0x40002830
        /// time stamp time register
        pub const Tstr = packed struct {
            pub const Pm = enum(u1) {
                am = 0, // AM or 24-hour format
                pm = 1, // PM
            };
            su: u4, // Second units in BCD format
            st: u3, // Second tens in BCD format
            _reserved_7_7: u1,
            mnu: u4, // Minute units in BCD format
            mnt: u3, // Minute tens in BCD format
            _reserved_15_15: u1,
            hu: u4, // Hour units in BCD format
            ht: u2, // Hour tens in BCD format
            pm: Pm, // AM/PM notation (u1)
            _padding_23_31: u9,
        };
        pub const tstr = mmio(base_address + 0x30, 32, Tstr);

        /// address: 0x40002834
        /// time stamp date register
        pub const Tsdr = packed struct {
            du: u4, // Date units in BCD format
            dt: u2, // Date tens in BCD format
            _reserved_6_7: u2,
            mu: u4, // Month units in BCD format
            mt: u1, // Month tens in BCD format
            wdu: u3, // Week day units
            yu: u4, // Year units in BCD format
            yt: u4, // Year tens in BCD format
            _padding_24_31: u8,
        };
        pub const tsdr = mmio(base_address + 0x34, 32, Tsdr);

        /// address: 0x40002838
        /// timestamp sub second register
        pub const Tsssr = packed struct {
            ss: u16, // Sub second value
            _padding_16_31: u16,
        };
        pub const tsssr = mmio(base_address + 0x38, 32, Tsssr);
    };
    /// Secure digital input/output interface
    pub const sdio = struct {
        pub const base_address = 0x40012c00;

        /// address: 0x40012c00
        /// power control register
        pub const Power = packed struct {
            pub const Pwrctrl = enum(u2) {
                power_off = 0b00, // Power off
                power_on = 0b11, // Power on
            };
            pwrctrl: Pwrctrl, // PWRCTRL (u2)
            _padding_2_31: u30,
        };
        pub const power = mmio(base_address + 0x0, 32, Power);

        /// address: 0x40012c04
        /// SDI clock control register
        pub const Clkcr = packed struct {
            pub const Clken = enum(u1) {
                disabled = 0, // Disable clock
                enabled = 1, // Enable clock
            };
            pub const Pwrsav = enum(u1) {
                disabled = 1, // SDIO_CK is only enabled when the bus is active
                enabled = 0, // SDIO_CK clock is always enabled
            };
            pub const Bypass = enum(u1) {
                disabled = 0, // SDIOCLK is divided according to the CLKDIV value before driving the SDIO_CK output signal.
                enabled = 1, // SDIOCLK directly drives the SDIO_CK output signal
            };
            pub const Widbus = enum(u2) {
                bus_width1 = 0b00, // 1 lane wide bus
                bus_width4 = 0b01, // 4 lane wide bus
                bus_width8 = 0b10, // 8 lane wide bus
            };
            pub const Negedge = enum(u1) {
                rising = 0, // SDIO_CK generated on the rising edge
                falling = 1, // SDIO_CK generated on the falling edge
            };
            pub const HwfcEn = enum(u1) {
                disabled = 0, // HW Flow Control is disabled
                enabled = 1, // HW Flow Control is enabled
            };
            clkdiv: u8, // Clock divide factor
            clken: Clken, // Clock enable bit (u1)
            pwrsav: Pwrsav, // Power saving configuration bit (u1)
            bypass: Bypass, // Clock divider bypass enable bit (u1)
            widbus: Widbus, // Wide bus mode enable bit (u2)
            negedge: Negedge, // SDIO_CK dephasing selection bit (u1)
            hwfc_en: HwfcEn, // HW Flow Control enable (u1)
            _padding_15_31: u17,
        };
        pub const clkcr = mmio(base_address + 0x4, 32, Clkcr);

        /// address: 0x40012c08
        /// argument register
        pub const Arg = packed struct {
            cmdarg: u32, // Command argument
        };
        pub const arg = mmio(base_address + 0x8, 32, Arg);

        /// address: 0x40012c0c
        /// command register
        pub const Cmd = packed struct {
            pub const Waitresp = enum(u2) {
                no_response = 0b00, // No response
                short_response = 0b01, // Short response
                no_response2 = 0b10, // No reponse
                long_response = 0b11, // Long reponse
            };
            pub const Waitint = enum(u1) {
                disabled = 0, // Don't wait for interrupt request
                enabled = 1, // Wait for interrupt request
            };
            pub const Waitpend = enum(u1) {
                disabled = 0, // Don't wait for data end
                enabled = 1, // Wait for end of data transfer signal before sending command
            };
            pub const Cpsmen = enum(u1) {
                disabled = 0, // Command path state machine disabled
                enabled = 1, // Command path state machine enabled
            };
            pub const Sdiosuspend = enum(u1) {
                disabled = 0, // Next command is not a SDIO suspend command
                enabled = 1, // Next command send is a SDIO suspend command
            };
            pub const Encmdcompl = enum(u1) {
                disabled = 0, // Command complete signal disabled
                enabled = 1, // Command complete signal enabled
            };
            pub const Nien = enum(u1) {
                disabled = 0, // Interrupts to the CE-ATA not disabled
                enabled = 1, // Interrupt to the CE-ATA are disabled
            };
            pub const CeAtacmd = enum(u1) {
                disabled = 0, // CE-ATA command disabled
                enabled = 1, // CE-ATA command enabled
            };
            cmdindex: u6, // Command index
            waitresp: Waitresp, // Wait for response bits (u2)
            waitint: Waitint, // CPSM waits for interrupt request (u1)
            waitpend: Waitpend, // CPSM Waits for ends of data transfer (CmdPend internal signal). (u1)
            cpsmen: Cpsmen, // Command path state machine (CPSM) Enable bit (u1)
            sdiosuspend: Sdiosuspend, // SD I/O suspend command (u1)
            encmdcompl: Encmdcompl, // Enable CMD completion (u1)
            nien: Nien, // not Interrupt Enable (u1)
            ce_atacmd: CeAtacmd, // CE-ATA command (u1)
            _padding_15_31: u17,
        };
        pub const cmd = mmio(base_address + 0xc, 32, Cmd);

        /// address: 0x40012c10
        /// command response register
        pub const respcmd = mmioInt(base_address + 0x10, 32, u6);

        /// address: 0x40012c14
        /// response 1..4 register
        pub const Resp1 = packed struct {
            cardstatus1: u32, // Card Status
        };
        pub const resp1 = mmio(base_address + 0x14, 32, Resp1);

        /// address: 0x40012c18
        /// response 1..4 register
        pub const Resp2 = packed struct {
            cardstatus2: u32, // Card Status
        };
        pub const resp2 = mmio(base_address + 0x18, 32, Resp2);

        /// address: 0x40012c1c
        /// response 1..4 register
        pub const Resp3 = packed struct {
            cardstatus3: u32, // Card Status
        };
        pub const resp3 = mmio(base_address + 0x1c, 32, Resp3);

        /// address: 0x40012c20
        /// response 1..4 register
        pub const Resp4 = packed struct {
            cardstatus4: u32, // Card Status
        };
        pub const resp4 = mmio(base_address + 0x20, 32, Resp4);

        /// address: 0x40012c24
        /// data timer register
        pub const Dtimer = packed struct {
            datatime: u32, // Data timeout period
        };
        pub const dtimer = mmio(base_address + 0x24, 32, Dtimer);

        /// address: 0x40012c28
        /// data length register
        pub const Dlen = packed struct {
            datalength: u25, // Data length value
            _padding_25_31: u7,
        };
        pub const dlen = mmio(base_address + 0x28, 32, Dlen);

        /// address: 0x40012c2c
        /// data control register
        pub const Dctrl = packed struct {
            pub const Dten = enum(u1) {
                disabled = 0, // Disabled
                enabled = 1, // Start transfer
            };
            pub const Dtdir = enum(u1) {
                controller_to_card = 0, // From controller to card
                card_to_controller = 1, // From card to controller
            };
            pub const Dtmode = enum(u1) {
                block_mode = 0, // Bloack data transfer
                stream_mode = 1, // Stream or SDIO multibyte data transfer
            };
            pub const Dmaen = enum(u1) {
                disabled = 0, // Dma disabled
                enabled = 1, // Dma enabled
            };
            pub const Rwstart = enum(u1) {
                disabled = 0, // Don't start read wait operation
                enabled = 1, // Read wait operation starts
            };
            pub const Rwstop = enum(u1) {
                disabled = 0, // Read wait in progress if RWSTART is enabled
                enabled = 1, // Enable for read wait stop if RWSTART is enabled
            };
            pub const Rwmod = enum(u1) {
                d2 = 0, // Read wait control stopping using SDIO_D2
                ck = 1, // Read wait control using SDIO_CK
            };
            pub const Sdioen = enum(u1) {
                disabled = 0, // SDIO operations disabled
                enabled = 1, // SDIO operations enabled
            };
            dten: Dten, // DTEN (u1)
            dtdir: Dtdir, // Data transfer direction selection (u1)
            dtmode: Dtmode, // Data transfer mode selection 1: Stream or SDIO multibyte data transfer. (u1)
            dmaen: Dmaen, // DMA enable bit (u1)
            dblocksize: u4, // Data block size
            rwstart: Rwstart, // Read wait start (u1)
            rwstop: Rwstop, // Read wait stop (u1)
            rwmod: Rwmod, // Read wait mode (u1)
            sdioen: Sdioen, // SD I/O enable functions (u1)
            _padding_12_31: u20,
        };
        pub const dctrl = mmio(base_address + 0x2c, 32, Dctrl);

        /// address: 0x40012c30
        /// data counter register
        pub const Dcount = packed struct {
            datacount: u25, // Data count value
            _padding_25_31: u7,
        };
        pub const dcount = mmio(base_address + 0x30, 32, Dcount);

        /// address: 0x40012c34
        /// status register
        pub const Sta = packed struct {
            pub const Ccrcfail = enum(u1) {
                not_failed = 0, // Command response received, crc check passed
                failed = 1, // Command response received, crc check failed
            };
            pub const Dcrcfail = enum(u1) {
                not_failed = 0, // No Data block sent/received crc check fail
                failed = 1, // Data block sent/received crc failed
            };
            pub const Ctimeout = enum(u1) {
                no_timeout = 0, // No Command timeout
                timeout = 1, // Command timeout
            };
            pub const Dtimeout = enum(u1) {
                no_timeout = 0, // No data timeout
                timeout = 1, // Data timeout
            };
            pub const Txunderr = enum(u1) {
                no_underrun = 0, // No transmit FIFO underrun error
                underrun = 1, // Transmit FIFO underrun error
            };
            pub const Rxoverr = enum(u1) {
                no_overrun = 0, // No FIFO overrun error
                overrun = 1, // Receive FIFO overrun error
            };
            pub const Cmdrend = enum(u1) {
                not_done = 0, // Command not done
                done = 1, // Command response received (CRC check passed)
            };
            pub const Cmdsent = enum(u1) {
                not_sent = 0, // Command not sent
                sent = 1, // Command sent (no response required)
            };
            pub const Dataend = enum(u1) {
                done = 1, // Data end (DCOUNT, is zero)
                not_done = 0, // Not done
            };
            pub const Stbiterr = enum(u1) {
                detected = 0, // No start bit detected error
                not_detected = 1, // Start bit not detected error
            };
            pub const Dbckend = enum(u1) {
                not_transferred = 0, // Data block not sent/received (CRC check failed)
                transferred = 1, // Data block sent/received (CRC check passed)
            };
            pub const Cmdact = enum(u1) {
                not_in_progress = 0, // Command transfer not in progress
                in_progress = 1, // Command tranfer in progress
            };
            pub const Txact = enum(u1) {
                not_in_progress = 0, // Data transmit is not in progress
                in_progress = 1, // Data transmit in progress
            };
            pub const Rxact = enum(u1) {
                not_in_progress = 0, // Data receive not in progress
                in_progress = 1, // Data receive in progress
            };
            pub const Txfifohe = enum(u1) {
                not_half_empty = 0, // Transmit FIFO not half empty
                half_empty = 1, // Transmit FIFO half empty. At least 8 words can be written into the FIFO
            };
            pub const Rxfifohf = enum(u1) {
                not_half_full = 0, // Receive FIFO not half full
                half_full = 1, // Receive FIFO half full. At least 8 words in the FIFO
            };
            pub const Txfifof = enum(u1) {
                not_full = 0, // Transmit FIFO not full
                full = 1, // Transmit FIFO full
            };
            pub const Rxfifof = enum(u1) {
                not_full = 0, // Transmit FIFO not full
                full = 1, // Receive FIFO full. When HW Flow Control is enabled, RXFIFOF signals becomes activated 2 words before the FIFO is full.
            };
            pub const Txfifoe = enum(u1) {
                not_empty = 0, // Transmit FIFO not empty
                empty = 1, // Transmit FIFO empty. When HW Flow Control is enabled, TXFIFOE signals becomes activated when the FIFO contains 2 words.
            };
            pub const Rxfifoe = enum(u1) {
                not_empty = 0, // Receive FIFO not empty
                empty = 1, // Receive FIFO empty
            };
            pub const Txdavl = enum(u1) {
                not_available = 0, // Data not available in transmit FIFO
                available = 1, // Data available in transmit FIFO
            };
            pub const Rxdavl = enum(u1) {
                not_available = 0, // Data not available in receive FIFO
                available = 1, // Data available in receive FIFO
            };
            pub const Sdioit = enum(u1) {
                not_received = 0, // SDIO interrupt not receieved
                received = 1, // SDIO interrupt received
            };
            pub const Ceataend = enum(u1) {
                not_received = 0, // Completion signal not received
                received = 1, // CE-ATA command completion signal received for CMD61
            };
            ccrcfail: Ccrcfail, // Command response received (CRC check failed) (u1)
            dcrcfail: Dcrcfail, // Data block sent/received (CRC check failed) (u1)
            ctimeout: Ctimeout, // Command response timeout (u1)
            dtimeout: Dtimeout, // Data timeout (u1)
            txunderr: Txunderr, // Transmit FIFO underrun error (u1)
            rxoverr: Rxoverr, // Received FIFO overrun error (u1)
            cmdrend: Cmdrend, // Command response received (CRC check passed) (u1)
            cmdsent: Cmdsent, // Command sent (no response required) (u1)
            dataend: Dataend, // Data end (data counter, SDIDCOUNT, is zero) (u1)
            stbiterr: Stbiterr, // Start bit not detected on all data signals in wide bus mode (u1)
            dbckend: Dbckend, // Data block sent/received (CRC check passed) (u1)
            cmdact: Cmdact, // Command transfer in progress (u1)
            txact: Txact, // Data transmit in progress (u1)
            rxact: Rxact, // Data receive in progress (u1)
            txfifohe: Txfifohe, // Transmit FIFO half empty: at least 8 words can be written into the FIFO (u1)
            rxfifohf: Rxfifohf, // Receive FIFO half full: there are at least 8 words in the FIFO (u1)
            txfifof: Txfifof, // Transmit FIFO full (u1)
            rxfifof: Rxfifof, // Receive FIFO full (u1)
            txfifoe: Txfifoe, // Transmit FIFO empty (u1)
            rxfifoe: Rxfifoe, // Receive FIFO empty (u1)
            txdavl: Txdavl, // Data available in transmit FIFO (u1)
            rxdavl: Rxdavl, // Data available in receive FIFO (u1)
            sdioit: Sdioit, // SDIO interrupt received (u1)
            ceataend: Ceataend, // CE-ATA command completion signal received for CMD61 (u1)
            _padding_24_31: u8,
        };
        pub const sta = mmio(base_address + 0x34, 32, Sta);

        /// address: 0x40012c38
        /// interrupt clear register
        pub const Icr = packed struct {
            pub const Ccrcfailcw = enum(u1) {
                clear = 1, // Clear flag
            };
            ccrcfailc: Ccrcfailcw, // CCRCFAIL flag clear bit (u1)
            dcrcfailc: Ccrcfailcw, // DCRCFAIL flag clear bit (u1)
            ctimeoutc: Ccrcfailcw, // CTIMEOUT flag clear bit (u1)
            dtimeoutc: Ccrcfailcw, // DTIMEOUT flag clear bit (u1)
            txunderrc: Ccrcfailcw, // TXUNDERR flag clear bit (u1)
            rxoverrc: Ccrcfailcw, // RXOVERR flag clear bit (u1)
            cmdrendc: Ccrcfailcw, // CMDREND flag clear bit (u1)
            cmdsentc: Ccrcfailcw, // CMDSENT flag clear bit (u1)
            dataendc: Ccrcfailcw, // DATAEND flag clear bit (u1)
            stbiterrc: Ccrcfailcw, // STBITERR flag clear bit (u1)
            dbckendc: Ccrcfailcw, // DBCKEND flag clear bit (u1)
            _reserved_11_21: u11,
            sdioitc: Ccrcfailcw, // SDIOIT flag clear bit (u1)
            ceataendc: Ccrcfailcw, // CEATAEND flag clear bit (u1)
            _padding_24_31: u8,
        };
        pub const icr = mmio(base_address + 0x38, 32, Icr);

        /// address: 0x40012c3c
        /// mask register
        pub const Mask = packed struct {
            pub const Ccrcfailie = enum(u1) {
                disabled = 0, // Interrupt disabled
                enabled = 1, // Interrupt enabled
            };
            ccrcfailie: Ccrcfailie, // Command CRC fail interrupt enable (u1)
            dcrcfailie: Ccrcfailie, // Data CRC fail interrupt enable (u1)
            ctimeoutie: Ccrcfailie, // Command timeout interrupt enable (u1)
            dtimeoutie: Ccrcfailie, // Data timeout interrupt enable (u1)
            txunderrie: Ccrcfailie, // Tx FIFO underrun error interrupt enable (u1)
            rxoverrie: Ccrcfailie, // Rx FIFO overrun error interrupt enable (u1)
            cmdrendie: Ccrcfailie, // Command response received interrupt enable (u1)
            cmdsentie: Ccrcfailie, // Command sent interrupt enable (u1)
            dataendie: Ccrcfailie, // Data end interrupt enable (u1)
            stbiterrie: Ccrcfailie, // Start bit error interrupt enable (u1)
            dbckendie: Ccrcfailie, // Data block end interrupt enable (u1)
            cmdactie: Ccrcfailie, // Command acting interrupt enable (u1)
            txactie: Ccrcfailie, // Data transmit acting interrupt enable (u1)
            rxactie: Ccrcfailie, // Data receive acting interrupt enable (u1)
            txfifoheie: Ccrcfailie, // Tx FIFO half empty interrupt enable (u1)
            rxfifohfie: Ccrcfailie, // Rx FIFO half full interrupt enable (u1)
            txfifofie: Ccrcfailie, // Tx FIFO full interrupt enable (u1)
            rxfifofie: Ccrcfailie, // Rx FIFO full interrupt enable (u1)
            txfifoeie: Ccrcfailie, // Tx FIFO empty interrupt enable (u1)
            rxfifoeie: Ccrcfailie, // Rx FIFO empty interrupt enable (u1)
            txdavlie: Ccrcfailie, // Data available in Tx FIFO interrupt enable (u1)
            rxdavlie: Ccrcfailie, // Data available in Rx FIFO interrupt enable (u1)
            sdioitie: Ccrcfailie, // SDIO mode interrupt received interrupt enable (u1)
            ceataendie: Ccrcfailie, // CE-ATA command completion signal received interrupt enable (u1)
            _padding_24_31: u8,
        };
        pub const mask = mmio(base_address + 0x3c, 32, Mask);

        /// address: 0x40012c48
        /// FIFO counter register
        pub const Fifocnt = packed struct {
            fifocount: u24, // Remaining number of words to be written to or read from the FIFO.
            _padding_24_31: u8,
        };
        pub const fifocnt = mmio(base_address + 0x48, 32, Fifocnt);

        /// address: 0x40012c80
        /// data FIFO register
        pub const Fifo = packed struct {
            fifodata: u32, // Receive and transmit FIFO data
        };
        pub const fifo = mmio(base_address + 0x80, 32, Fifo);
    };
    /// System configuration controller
    pub const syscfg = struct {
        pub const base_address = 0x40013800;

        /// address: 0x40013800
        /// memory remap register
        pub const Memrm = packed struct {
            mem_mode: u2, // MEM_MODE
            _padding_2_31: u30,
        };
        pub const memrm = mmio(base_address + 0x0, 32, Memrm);

        /// address: 0x40013804
        /// peripheral mode configuration register
        pub const Pmc = packed struct {
            _reserved_0_15: u16,
            adc1dc2: u1, // ADC1DC2
            _padding_17_31: u15,
        };
        pub const pmc = mmio(base_address + 0x4, 32, Pmc);

        /// address: 0x40013808
        /// external interrupt configuration register 1
        pub const Exticr1 = packed struct {
            exti0: u4, // EXTI x configuration (x = 0 to 3)
            exti1: u4, // EXTI x configuration (x = 0 to 3)
            exti2: u4, // EXTI x configuration (x = 0 to 3)
            exti3: u4, // EXTI x configuration (x = 0 to 3)
            _padding_16_31: u16,
        };
        pub const exticr1 = mmio(base_address + 0x8, 32, Exticr1);

        /// address: 0x4001380c
        /// external interrupt configuration register 2
        pub const Exticr2 = packed struct {
            exti4: u4, // EXTI x configuration (x = 4 to 7)
            exti5: u4, // EXTI x configuration (x = 4 to 7)
            exti6: u4, // EXTI x configuration (x = 4 to 7)
            exti7: u4, // EXTI x configuration (x = 4 to 7)
            _padding_16_31: u16,
        };
        pub const exticr2 = mmio(base_address + 0xc, 32, Exticr2);

        /// address: 0x40013810
        /// external interrupt configuration register 3
        pub const Exticr3 = packed struct {
            exti8: u4, // EXTI x configuration (x = 8 to 11)
            exti9: u4, // EXTI x configuration (x = 8 to 11)
            exti10: u4, // EXTI10
            exti11: u4, // EXTI x configuration (x = 8 to 11)
            _padding_16_31: u16,
        };
        pub const exticr3 = mmio(base_address + 0x10, 32, Exticr3);

        /// address: 0x40013814
        /// external interrupt configuration register 4
        pub const Exticr4 = packed struct {
            exti12: u4, // EXTI x configuration (x = 12 to 15)
            exti13: u4, // EXTI x configuration (x = 12 to 15)
            exti14: u4, // EXTI x configuration (x = 12 to 15)
            exti15: u4, // EXTI x configuration (x = 12 to 15)
            _padding_16_31: u16,
        };
        pub const exticr4 = mmio(base_address + 0x14, 32, Exticr4);

        /// address: 0x40013820
        /// Compensation cell control register
        pub const Cmpcr = packed struct {
            cmp_pd: u1, // Compensation cell power-down
            _reserved_1_7: u7,
            ready: u1, // READY
            _padding_9_31: u23,
        };
        pub const cmpcr = mmio(base_address + 0x20, 32, Cmpcr);
    };
    /// Advanced-timers
    pub const tim1 = struct {
        pub const base_address = 0x40010000;

        /// address: 0x40010000
        /// control register 1
        pub const Cr1 = packed struct {
            pub const Cen = enum(u1) {
                disabled = 0, // Counter disabled
                enabled = 1, // Counter enabled
            };
            pub const Udis = enum(u1) {
                enabled = 0, // Update event enabled
                disabled = 1, // Update event disabled
            };
            pub const Urs = enum(u1) {
                any_event = 0, // Any of counter overflow/underflow, setting UG, or update through slave mode, generates an update interrupt or DMA request
                counter_only = 1, // Only counter overflow/underflow generates an update interrupt or DMA request
            };
            pub const Opm = enum(u1) {
                disabled = 0, // Counter is not stopped at update event
                enabled = 1, // Counter stops counting at the next update event (clearing the CEN bit)
            };
            pub const Dir = enum(u1) {
                up = 0, // Counter used as upcounter
                down = 1, // Counter used as downcounter
            };
            pub const Cms = enum(u2) {
                edge_aligned = 0b00, // The counter counts up or down depending on the direction bit
                center_aligned1 = 0b01, // The counter counts up and down alternatively. Output compare interrupt flags are set only when the counter is counting down.
                center_aligned2 = 0b10, // The counter counts up and down alternatively. Output compare interrupt flags are set only when the counter is counting up.
                center_aligned3 = 0b11, // The counter counts up and down alternatively. Output compare interrupt flags are set both when the counter is counting up or down.
            };
            pub const Arpe = enum(u1) {
                disabled = 0, // TIMx_APRR register is not buffered
                enabled = 1, // TIMx_APRR register is buffered
            };
            pub const Ckd = enum(u2) {
                div1 = 0b00, // t_DTS = t_CK_INT
                div2 = 0b01, // t_DTS = 2  t_CK_INT
                div4 = 0b10, // t_DTS = 4  t_CK_INT
            };
            cen: Cen, // Counter enable (u1)
            udis: Udis, // Update disable (u1)
            urs: Urs, // Update request source (u1)
            opm: Opm, // One-pulse mode (u1)
            dir: Dir, // Direction (u1)
            cms: Cms, // Center-aligned mode selection (u2)
            arpe: Arpe, // Auto-reload preload enable (u1)
            ckd: Ckd, // Clock division (u2)
            _padding_10_31: u22,
        };
        pub const cr1 = mmio(base_address + 0x0, 32, Cr1);

        /// address: 0x40010004
        /// control register 2
        pub const Cr2 = packed struct {
            pub const Ccds = enum(u1) {
                on_compare = 0, // CCx DMA request sent when CCx event occurs
                on_update = 1, // CCx DMA request sent when update event occurs
            };
            pub const Mms = enum(u3) {
                reset = 0b000, // The UG bit from the TIMx_EGR register is used as trigger output
                enable = 0b001, // The counter enable signal, CNT_EN, is used as trigger output
                update = 0b010, // The update event is selected as trigger output
                compare_pulse = 0b011, // The trigger output send a positive pulse when the CC1IF flag it to be set, as soon as a capture or a compare match occurred
                compare_oc1 = 0b100, // OC1REF signal is used as trigger output
                compare_oc2 = 0b101, // OC2REF signal is used as trigger output
                compare_oc3 = 0b110, // OC3REF signal is used as trigger output
                compare_oc4 = 0b111, // OC4REF signal is used as trigger output
            };
            pub const Ti1s = enum(u1) {
                normal = 0, // The TIMx_CH1 pin is connected to TI1 input
                xor = 1, // The TIMx_CH1, CH2, CH3 pins are connected to TI1 input
            };
            ccpc: u1, // Capture/compare preloaded control
            _reserved_1_1: u1,
            ccus: u1, // Capture/compare control update selection
            ccds: Ccds, // Capture/compare DMA selection (u1)
            mms: Mms, // Master mode selection (u3)
            ti1s: Ti1s, // TI1 selection (u1)
            ois1: u1, // Output Idle state 1
            ois1n: u1, // Output Idle state 1
            ois2: u1, // Output Idle state 2
            ois2n: u1, // Output Idle state 2
            ois3: u1, // Output Idle state 3
            ois3n: u1, // Output Idle state 3
            ois4: u1, // Output Idle state 4
            _padding_15_31: u17,
        };
        pub const cr2 = mmio(base_address + 0x4, 32, Cr2);

        /// address: 0x40010008
        /// slave mode control register
        pub const Smcr = packed struct {
            pub const Sms = enum(u3) {
                disabled = 0b000, // Slave mode disabled - if CEN = 1 then the prescaler is clocked directly by the internal clock.
                encoder_mode_1 = 0b001, // Encoder mode 1 - Counter counts up/down on TI2FP1 edge depending on TI1FP2 level.
                encoder_mode_2 = 0b010, // Encoder mode 2 - Counter counts up/down on TI1FP2 edge depending on TI2FP1 level.
                encoder_mode_3 = 0b011, // Encoder mode 3 - Counter counts up/down on both TI1FP1 and TI2FP2 edges depending on the level of the other input.
                reset_mode = 0b100, // Reset Mode - Rising edge of the selected trigger input (TRGI) reinitializes the counter and generates an update of the registers.
                gated_mode = 0b101, // Gated Mode - The counter clock is enabled when the trigger input (TRGI) is high. The counter stops (but is not reset) as soon as the trigger becomes low. Both start and stop of the counter are controlled.
                trigger_mode = 0b110, // Trigger Mode - The counter starts at a rising edge of the trigger TRGI (but it is not reset). Only the start of the counter is controlled.
                ext_clock_mode = 0b111, // External Clock Mode 1 - Rising edges of the selected trigger (TRGI) clock the counter.
            };
            pub const Ts = enum(u3) {
                itr0 = 0b000, // Internal Trigger 0 (ITR0)
                itr1 = 0b001, // Internal Trigger 1 (ITR1)
                itr2 = 0b010, // Internal Trigger 2 (ITR2)
                ti1_f_ed = 0b100, // TI1 Edge Detector (TI1F_ED)
                ti1_fp1 = 0b101, // Filtered Timer Input 1 (TI1FP1)
                ti2_fp2 = 0b110, // Filtered Timer Input 2 (TI2FP2)
                etrf = 0b111, // External Trigger input (ETRF)
            };
            pub const Msm = enum(u1) {
                no_sync = 0, // No action
                sync = 1, // The effect of an event on the trigger input (TRGI) is delayed to allow a perfect synchronization between the current timer and its slaves (through TRGO). It is useful if we want to synchronize several timers on a single external event.
            };
            pub const Etf = enum(u4) {
                no_filter = 0b0000, // No filter, sampling is done at fDTS
                fck_int_n2 = 0b0001, // fSAMPLING=fCK_INT, N=2
                fck_int_n4 = 0b0010, // fSAMPLING=fCK_INT, N=4
                fck_int_n8 = 0b0011, // fSAMPLING=fCK_INT, N=8
                fdts_div2_n6 = 0b0100, // fSAMPLING=fDTS/2, N=6
                fdts_div2_n8 = 0b0101, // fSAMPLING=fDTS/2, N=8
                fdts_div4_n6 = 0b0110, // fSAMPLING=fDTS/4, N=6
                fdts_div4_n8 = 0b0111, // fSAMPLING=fDTS/4, N=8
                fdts_div8_n6 = 0b1000, // fSAMPLING=fDTS/8, N=6
                fdts_div8_n8 = 0b1001, // fSAMPLING=fDTS/8, N=8
                fdts_div16_n5 = 0b1010, // fSAMPLING=fDTS/16, N=5
                fdts_div16_n6 = 0b1011, // fSAMPLING=fDTS/16, N=6
                fdts_div16_n8 = 0b1100, // fSAMPLING=fDTS/16, N=8
                fdts_div32_n5 = 0b1101, // fSAMPLING=fDTS/32, N=5
                fdts_div32_n6 = 0b1110, // fSAMPLING=fDTS/32, N=6
                fdts_div32_n8 = 0b1111, // fSAMPLING=fDTS/32, N=8
            };
            pub const Etps = enum(u2) {
                div1 = 0b00, // Prescaler OFF
                div2 = 0b01, // ETRP frequency divided by 2
                div4 = 0b10, // ETRP frequency divided by 4
                div8 = 0b11, // ETRP frequency divided by 8
            };
            pub const Ece = enum(u1) {
                disabled = 0, // External clock mode 2 disabled
                enabled = 1, // External clock mode 2 enabled. The counter is clocked by any active edge on the ETRF signal.
            };
            pub const Etp = enum(u1) {
                not_inverted = 0, // ETR is noninverted, active at high level or rising edge
                inverted = 1, // ETR is inverted, active at low level or falling edge
            };
            sms: Sms, // Slave mode selection (u3)
            _reserved_3_3: u1,
            ts: Ts, // Trigger selection (u3)
            msm: Msm, // Master/Slave mode (u1)
            etf: Etf, // External trigger filter (u4)
            etps: Etps, // External trigger prescaler (u2)
            ece: Ece, // External clock enable (u1)
            etp: Etp, // External trigger polarity (u1)
            _padding_16_31: u16,
        };
        pub const smcr = mmio(base_address + 0x8, 32, Smcr);

        /// address: 0x4001000c
        /// DMA/Interrupt enable register
        pub const Dier = packed struct {
            pub const Uie = enum(u1) {
                disabled = 0, // Update interrupt disabled
                enabled = 1, // Update interrupt enabled
            };
            pub const Cc1ie = enum(u1) {
                disabled = 0, // CCx interrupt disabled
                enabled = 1, // CCx interrupt enabled
            };
            pub const Tie = enum(u1) {
                disabled = 0, // Trigger interrupt disabled
                enabled = 1, // Trigger interrupt enabled
            };
            pub const Ude = enum(u1) {
                disabled = 0, // Update DMA request disabled
                enabled = 1, // Update DMA request enabled
            };
            pub const Cc1de = enum(u1) {
                disabled = 0, // CCx DMA request disabled
                enabled = 1, // CCx DMA request enabled
            };
            pub const Tde = enum(u1) {
                disabled = 0, // Trigger DMA request disabled
                enabled = 1, // Trigger DMA request enabled
            };
            uie: Uie, // Update interrupt enable (u1)
            cc1ie: Cc1ie, // Capture/Compare 1 interrupt enable (u1)
            cc2ie: Cc1ie, // Capture/Compare 2 interrupt enable (u1)
            cc3ie: Cc1ie, // Capture/Compare 3 interrupt enable (u1)
            cc4ie: Cc1ie, // Capture/Compare 4 interrupt enable (u1)
            comie: u1, // COM interrupt enable
            tie: Tie, // Trigger interrupt enable (u1)
            bie: u1, // Break interrupt enable
            ude: Ude, // Update DMA request enable (u1)
            cc1de: Cc1de, // Capture/Compare 1 DMA request enable (u1)
            cc2de: Cc1de, // Capture/Compare 2 DMA request enable (u1)
            cc3de: Cc1de, // Capture/Compare 3 DMA request enable (u1)
            cc4de: Cc1de, // Capture/Compare 4 DMA request enable (u1)
            comde: u1, // COM DMA request enable
            tde: Tde, // Trigger DMA request enable (u1)
            _padding_15_31: u17,
        };
        pub const dier = mmio(base_address + 0xc, 32, Dier);

        /// address: 0x40010010
        /// status register
        pub const Sr = packed struct {
            pub const Uif = enum(u1) {
                clear = 0, // No update occurred
                update_pending = 1, // Update interrupt pending.
            };
            pub const Cc1if = enum(u1) {
                match = 1, // If CC1 is an output: The content of the counter TIMx_CNT matches the content of the TIMx_CCR1 register. If CC1 is an input: The counter value has been captured in TIMx_CCR1 register.
                clear = 0, // Clear flag
            };
            pub const Tif = enum(u1) {
                no_trigger = 0, // No trigger event occurred
                trigger = 1, // Trigger interrupt pending
                pub const clear = @intToEnum(Tif, 0); // Clear flag
            };
            pub const Cc1of = enum(u1) {
                overcapture = 1, // The counter value has been captured in TIMx_CCRx register while CCxIF flag was already set
                clear = 0, // Clear flag
            };
            uif: Uif, // Update interrupt flag (u1)
            cc1if: Cc1if, // Capture/compare 1 interrupt flag (u1)
            cc2if: Cc1if, // Capture/Compare 2 interrupt flag (u1)
            cc3if: Cc1if, // Capture/Compare 3 interrupt flag (u1)
            cc4if: Cc1if, // Capture/Compare 4 interrupt flag (u1)
            comif: u1, // COM interrupt flag
            tif: Tif, // Trigger interrupt flag (u1)
            bif: u1, // Break interrupt flag
            _reserved_8_8: u1,
            cc1of: Cc1of, // Capture/Compare 1 overcapture flag (u1)
            cc2of: Cc1of, // Capture/compare 2 overcapture flag (u1)
            cc3of: Cc1of, // Capture/Compare 3 overcapture flag (u1)
            cc4of: Cc1of, // Capture/Compare 4 overcapture flag (u1)
            _padding_13_31: u19,
        };
        pub const sr = mmio(base_address + 0x10, 32, Sr);

        /// address: 0x40010014
        /// event generation register
        pub const Egr = packed struct {
            pub const Ug = enum(u1) {
                update = 1, // Re-initializes the timer counter and generates an update of the registers.
            };
            pub const Cc1gw = enum(u1) {
                trigger = 1, // If CC1 is an output: CC1IF flag is set, Corresponding interrupt or DMA request is sent if enabled. If CC1 is an input: The current value of the counter is captured in TIMx_CCR1 register.
            };
            pub const Tgw = enum(u1) {
                trigger = 1, // The TIF flag is set in TIMx_SR register. Related interrupt or DMA transfer can occur if enabled.
            };
            ug: Ug, // Update generation (u1)
            cc1g: Cc1gw, // Capture/compare 1 generation (u1)
            cc2g: Cc1gw, // Capture/compare 2 generation (u1)
            cc3g: Cc1gw, // Capture/compare 3 generation (u1)
            cc4g: Cc1gw, // Capture/compare 4 generation (u1)
            comg: u1, // Capture/Compare control update generation
            tg: Tgw, // Trigger generation (u1)
            bg: u1, // Break generation
            _padding_8_31: u24,
        };
        pub const egr = mmio(base_address + 0x14, 32, Egr);

        /// address: 0x40010018
        /// capture/compare mode register 1 (output mode)
        pub const Ccmr1Output = packed struct {
            pub const Cc1s = enum(u2) {
                output = 0b00, // CC1 channel is configured as output
            };
            pub const Oc1pe = enum(u1) {
                disabled = 0, // Preload register on CCR1 disabled. New values written to CCR1 are taken into account immediately
                enabled = 1, // Preload register on CCR1 enabled. Preload value is loaded into active register on each update event
            };
            pub const Oc1m = enum(u3) {
                frozen = 0b000, // The comparison between the output compare register TIMx_CCRy and the counter TIMx_CNT has no effect on the outputs
                active_on_match = 0b001, // Set channel to active level on match. OCyREF signal is forced high when the counter matches the capture/compare register
                inactive_on_match = 0b010, // Set channel to inactive level on match. OCyREF signal is forced low when the counter matches the capture/compare register
                toggle = 0b011, // OCyREF toggles when TIMx_CNT=TIMx_CCRy
                force_inactive = 0b100, // OCyREF is forced low
                force_active = 0b101, // OCyREF is forced high
                pwm_mode1 = 0b110, // In upcounting, channel is active as long as TIMx_CNT<TIMx_CCRy else inactive. In downcounting, channel is inactive as long as TIMx_CNT>TIMx_CCRy else active
                pwm_mode2 = 0b111, // Inversely to PwmMode1
            };
            pub const Cc2s = enum(u2) {
                output = 0b00, // CC2 channel is configured as output
            };
            pub const Oc2pe = enum(u1) {
                disabled = 0, // Preload register on CCR2 disabled. New values written to CCR2 are taken into account immediately
                enabled = 1, // Preload register on CCR2 enabled. Preload value is loaded into active register on each update event
            };
            cc1s: Cc1s, // Capture/Compare 1 selection (u2)
            oc1fe: u1, // Output Compare 1 fast enable
            oc1pe: Oc1pe, // Output Compare 1 preload enable (u1)
            oc1m: Oc1m, // Output Compare 1 mode (u3)
            oc1ce: u1, // Output Compare 1 clear enable
            cc2s: Cc2s, // Capture/Compare 2 selection (u2)
            oc2fe: u1, // Output Compare 2 fast enable
            oc2pe: Oc2pe, // Output Compare 2 preload enable (u1)
            oc2m: Oc1m, // Output Compare 2 mode (u3)
            oc2ce: u1, // Output Compare 2 clear enable
            _padding_16_31: u16,
        };
        pub const ccmr1_output = mmio(base_address + 0x18, 32, Ccmr1Output);

        /// address: 0x40010018
        /// capture/compare mode register 1 (input mode)
        pub const Ccmr1Input = packed struct {
            pub const Cc1s = enum(u2) {
                ti1 = 0b01, // CC1 channel is configured as input, IC1 is mapped on TI1
                ti2 = 0b10, // CC1 channel is configured as input, IC1 is mapped on TI2
                trc = 0b11, // CC1 channel is configured as input, IC1 is mapped on TRC
            };
            pub const Ic1f = enum(u4) {
                no_filter = 0b0000, // No filter, sampling is done at fDTS
                fck_int_n2 = 0b0001, // fSAMPLING=fCK_INT, N=2
                fck_int_n4 = 0b0010, // fSAMPLING=fCK_INT, N=4
                fck_int_n8 = 0b0011, // fSAMPLING=fCK_INT, N=8
                fdts_div2_n6 = 0b0100, // fSAMPLING=fDTS/2, N=6
                fdts_div2_n8 = 0b0101, // fSAMPLING=fDTS/2, N=8
                fdts_div4_n6 = 0b0110, // fSAMPLING=fDTS/4, N=6
                fdts_div4_n8 = 0b0111, // fSAMPLING=fDTS/4, N=8
                fdts_div8_n6 = 0b1000, // fSAMPLING=fDTS/8, N=6
                fdts_div8_n8 = 0b1001, // fSAMPLING=fDTS/8, N=8
                fdts_div16_n5 = 0b1010, // fSAMPLING=fDTS/16, N=5
                fdts_div16_n6 = 0b1011, // fSAMPLING=fDTS/16, N=6
                fdts_div16_n8 = 0b1100, // fSAMPLING=fDTS/16, N=8
                fdts_div32_n5 = 0b1101, // fSAMPLING=fDTS/32, N=5
                fdts_div32_n6 = 0b1110, // fSAMPLING=fDTS/32, N=6
                fdts_div32_n8 = 0b1111, // fSAMPLING=fDTS/32, N=8
            };
            pub const Cc2s = enum(u2) {
                ti2 = 0b01, // CC2 channel is configured as input, IC2 is mapped on TI2
                ti1 = 0b10, // CC2 channel is configured as input, IC2 is mapped on TI1
                trc = 0b11, // CC2 channel is configured as input, IC2 is mapped on TRC
            };
            cc1s: Cc1s, // Capture/Compare 1 selection (u2)
            ic1psc: u2, // Input capture 1 prescaler
            ic1f: Ic1f, // Input capture 1 filter (u4)
            cc2s: Cc2s, // Capture/Compare 2 selection (u2)
            ic2psc: u2, // Input capture 2 prescaler
            ic2f: u4, // Input capture 2 filter
            _padding_16_31: u16,
        };
        pub const ccmr1_input = mmio(base_address + 0x18, 32, Ccmr1Input);

        /// address: 0x4001001c
        /// capture/compare mode register 2 (output mode)
        pub const Ccmr2Output = packed struct {
            pub const Cc3s = enum(u2) {
                output = 0b00, // CC3 channel is configured as output
            };
            pub const Oc3pe = enum(u1) {
                disabled = 0, // Preload register on CCR3 disabled. New values written to CCR3 are taken into account immediately
                enabled = 1, // Preload register on CCR3 enabled. Preload value is loaded into active register on each update event
            };
            pub const Oc3m = enum(u3) {
                frozen = 0b000, // The comparison between the output compare register TIMx_CCRy and the counter TIMx_CNT has no effect on the outputs
                active_on_match = 0b001, // Set channel to active level on match. OCyREF signal is forced high when the counter matches the capture/compare register
                inactive_on_match = 0b010, // Set channel to inactive level on match. OCyREF signal is forced low when the counter matches the capture/compare register
                toggle = 0b011, // OCyREF toggles when TIMx_CNT=TIMx_CCRy
                force_inactive = 0b100, // OCyREF is forced low
                force_active = 0b101, // OCyREF is forced high
                pwm_mode1 = 0b110, // In upcounting, channel is active as long as TIMx_CNT<TIMx_CCRy else inactive. In downcounting, channel is inactive as long as TIMx_CNT>TIMx_CCRy else active
                pwm_mode2 = 0b111, // Inversely to PwmMode1
            };
            pub const Cc4s = enum(u2) {
                output = 0b00, // CC4 channel is configured as output
            };
            pub const Oc4pe = enum(u1) {
                disabled = 0, // Preload register on CCR4 disabled. New values written to CCR4 are taken into account immediately
                enabled = 1, // Preload register on CCR4 enabled. Preload value is loaded into active register on each update event
            };
            cc3s: Cc3s, // Capture/Compare 3 selection (u2)
            oc3fe: u1, // Output compare 3 fast enable
            oc3pe: Oc3pe, // Output compare 3 preload enable (u1)
            oc3m: Oc3m, // Output compare 3 mode (u3)
            oc3ce: u1, // Output compare 3 clear enable
            cc4s: Cc4s, // Capture/Compare 4 selection (u2)
            oc4fe: u1, // Output compare 4 fast enable
            oc4pe: Oc4pe, // Output compare 4 preload enable (u1)
            oc4m: Oc3m, // Output compare 4 mode (u3)
            oc4ce: u1, // Output compare 4 clear enable
            _padding_16_31: u16,
        };
        pub const ccmr2_output = mmio(base_address + 0x1c, 32, Ccmr2Output);

        /// address: 0x4001001c
        /// capture/compare mode register 2 (input mode)
        pub const Ccmr2Input = packed struct {
            pub const Cc3s = enum(u2) {
                ti3 = 0b01, // CC3 channel is configured as input, IC3 is mapped on TI3
                ti4 = 0b10, // CC3 channel is configured as input, IC3 is mapped on TI4
                trc = 0b11, // CC3 channel is configured as input, IC3 is mapped on TRC
            };
            pub const Cc4s = enum(u2) {
                ti4 = 0b01, // CC4 channel is configured as input, IC4 is mapped on TI4
                ti3 = 0b10, // CC4 channel is configured as input, IC4 is mapped on TI3
                trc = 0b11, // CC4 channel is configured as input, IC4 is mapped on TRC
            };
            cc3s: Cc3s, // Capture/compare 3 selection (u2)
            ic3psc: u2, // Input capture 3 prescaler
            ic3f: u4, // Input capture 3 filter
            cc4s: Cc4s, // Capture/Compare 4 selection (u2)
            ic4psc: u2, // Input capture 4 prescaler
            ic4f: u4, // Input capture 4 filter
            _padding_16_31: u16,
        };
        pub const ccmr2_input = mmio(base_address + 0x1c, 32, Ccmr2Input);

        /// address: 0x40010020
        /// capture/compare enable register
        pub const Ccer = packed struct {
            cc1e: u1, // Capture/Compare 1 output enable
            cc1p: u1, // Capture/Compare 1 output Polarity
            cc1ne: u1, // Capture/Compare 1 complementary output enable
            cc1np: u1, // Capture/Compare 1 output Polarity
            cc2e: u1, // Capture/Compare 2 output enable
            cc2p: u1, // Capture/Compare 2 output Polarity
            cc2ne: u1, // Capture/Compare 2 complementary output enable
            cc2np: u1, // Capture/Compare 2 output Polarity
            cc3e: u1, // Capture/Compare 3 output enable
            cc3p: u1, // Capture/Compare 3 output Polarity
            cc3ne: u1, // Capture/Compare 3 complementary output enable
            cc3np: u1, // Capture/Compare 3 output Polarity
            cc4e: u1, // Capture/Compare 4 output enable
            cc4p: u1, // Capture/Compare 3 output Polarity
            _padding_14_31: u18,
        };
        pub const ccer = mmio(base_address + 0x20, 32, Ccer);

        /// address: 0x40010024
        /// counter
        pub const cnt = mmioInt(base_address + 0x24, 32, u16);

        /// address: 0x40010028
        /// prescaler
        pub const psc = mmioInt(base_address + 0x28, 32, u16);

        /// address: 0x4001002c
        /// auto-reload register
        pub const arr = mmioInt(base_address + 0x2c, 32, u16);

        /// address: 0x40010034
        /// capture/compare register
        pub const Ccr1 = packed struct {
            ccr: u16, // Capture/Compare value
            _padding_16_31: u16,
        };
        pub const ccr1 = mmio(base_address + 0x34, 32, Ccr1);

        /// address: 0x40010038
        /// capture/compare register
        pub const Ccr2 = packed struct {
            ccr: u16, // Capture/Compare value
            _padding_16_31: u16,
        };
        pub const ccr2 = mmio(base_address + 0x38, 32, Ccr2);

        /// address: 0x4001003c
        /// capture/compare register
        pub const Ccr3 = packed struct {
            ccr: u16, // Capture/Compare value
            _padding_16_31: u16,
        };
        pub const ccr3 = mmio(base_address + 0x3c, 32, Ccr3);

        /// address: 0x40010040
        /// capture/compare register
        pub const Ccr4 = packed struct {
            ccr: u16, // Capture/Compare value
            _padding_16_31: u16,
        };
        pub const ccr4 = mmio(base_address + 0x40, 32, Ccr4);

        /// address: 0x40010048
        /// DMA control register
        pub const Dcr = packed struct {
            dba: u5, // DMA base address
            _reserved_5_7: u3,
            dbl: u5, // DMA burst length
            _padding_13_31: u19,
        };
        pub const dcr = mmio(base_address + 0x48, 32, Dcr);

        /// address: 0x4001004c
        /// DMA address for full transfer
        pub const Dmar = packed struct {
            dmab: u16, // DMA register for burst accesses
            _padding_16_31: u16,
        };
        pub const dmar = mmio(base_address + 0x4c, 32, Dmar);

        /// address: 0x40010030
        /// repetition counter register
        pub const Rcr = packed struct {
            rep: u8, // Repetition counter value
            _padding_8_31: u24,
        };
        pub const rcr = mmio(base_address + 0x30, 32, Rcr);

        /// address: 0x40010044
        /// break and dead-time register
        pub const Bdtr = packed struct {
            pub const Ossi = enum(u1) {
                disabled = 0, // When inactive, OC/OCN outputs are disabled
                idle_level = 1, // When inactive, OC/OCN outputs are forced to idle level
            };
            pub const Ossr = enum(u1) {
                disabled = 0, // When inactive, OC/OCN outputs are disabled
                idle_level = 1, // When inactive, OC/OCN outputs are enabled with their inactive level
            };
            pub const Moe = enum(u1) {
                disabled_idle = 0, // OC/OCN are disabled or forced idle depending on OSSI
                enabled = 1, // OC/OCN are enabled if CCxE/CCxNE are set
            };
            dtg: u8, // Dead-time generator setup
            lock: u2, // Lock configuration
            ossi: Ossi, // Off-state selection for Idle mode (u1)
            ossr: Ossr, // Off-state selection for Run mode (u1)
            bke: u1, // Break enable
            bkp: u1, // Break polarity
            aoe: u1, // Automatic output enable
            moe: Moe, // Main output enable (u1)
            _padding_16_31: u16,
        };
        pub const bdtr = mmio(base_address + 0x44, 32, Bdtr);
    };
    /// General-purpose-timers
    pub const tim10 = struct {
        pub const base_address = 0x40014400;

        /// address: 0x40014400
        /// control register 1
        pub const Cr1 = packed struct {
            pub const Cen = enum(u1) {
                disabled = 0, // Counter disabled
                enabled = 1, // Counter enabled
            };
            pub const Udis = enum(u1) {
                enabled = 0, // Update event enabled
                disabled = 1, // Update event disabled
            };
            pub const Urs = enum(u1) {
                any_event = 0, // Any of counter overflow/underflow, setting UG, or update through slave mode, generates an update interrupt or DMA request
                counter_only = 1, // Only counter overflow/underflow generates an update interrupt or DMA request
            };
            pub const Opm = enum(u1) {
                disabled = 0, // Counter is not stopped at update event
                enabled = 1, // Counter stops counting at the next update event (clearing the CEN bit)
            };
            pub const Arpe = enum(u1) {
                disabled = 0, // TIMx_APRR register is not buffered
                enabled = 1, // TIMx_APRR register is buffered
            };
            pub const Ckd = enum(u2) {
                div1 = 0b00, // t_DTS = t_CK_INT
                div2 = 0b01, // t_DTS = 2  t_CK_INT
                div4 = 0b10, // t_DTS = 4  t_CK_INT
            };
            cen: Cen, // Counter enable (u1)
            udis: Udis, // Update disable (u1)
            urs: Urs, // Update request source (u1)
            opm: Opm, // One-pulse mode (u1)
            _reserved_4_6: u3,
            arpe: Arpe, // Auto-reload preload enable (u1)
            ckd: Ckd, // Clock division (u2)
            _padding_10_31: u22,
        };
        pub const cr1 = mmio(base_address + 0x0, 32, Cr1);

        /// address: 0x4001440c
        /// DMA/Interrupt enable register
        pub const Dier = packed struct {
            pub const Uie = enum(u1) {
                disabled = 0, // Update interrupt disabled
                enabled = 1, // Update interrupt enabled
            };
            uie: Uie, // Update interrupt enable (u1)
            cc1ie: u1, // Capture/Compare 1 interrupt enable
            _padding_2_31: u30,
        };
        pub const dier = mmio(base_address + 0xc, 32, Dier);

        /// address: 0x40014410
        /// status register
        pub const Sr = packed struct {
            pub const Uif = enum(u1) {
                clear = 0, // No update occurred
                update_pending = 1, // Update interrupt pending.
            };
            uif: Uif, // Update interrupt flag (u1)
            cc1if: u1, // Capture/compare 1 interrupt flag
            _reserved_2_8: u7,
            cc1of: u1, // Capture/Compare 1 overcapture flag
            _padding_10_31: u22,
        };
        pub const sr = mmio(base_address + 0x10, 32, Sr);

        /// address: 0x40014414
        /// event generation register
        pub const Egr = packed struct {
            pub const Ug = enum(u1) {
                update = 1, // Re-initializes the timer counter and generates an update of the registers.
            };
            ug: Ug, // Update generation (u1)
            cc1g: u1, // Capture/compare 1 generation
            _padding_2_31: u30,
        };
        pub const egr = mmio(base_address + 0x14, 32, Egr);

        /// address: 0x40014418
        /// capture/compare mode register 1 (output mode)
        pub const Ccmr1Output = packed struct {
            pub const Oc1m = enum(u3) {
                frozen = 0b000, // The comparison between the output compare register TIMx_CCRy and the counter TIMx_CNT has no effect on the outputs
                active_on_match = 0b001, // Set channel to active level on match. OCyREF signal is forced high when the counter matches the capture/compare register
                inactive_on_match = 0b010, // Set channel to inactive level on match. OCyREF signal is forced low when the counter matches the capture/compare register
                toggle = 0b011, // OCyREF toggles when TIMx_CNT=TIMx_CCRy
                force_inactive = 0b100, // OCyREF is forced low
                force_active = 0b101, // OCyREF is forced high
                pwm_mode1 = 0b110, // In upcounting, channel is active as long as TIMx_CNT<TIMx_CCRy else inactive. In downcounting, channel is inactive as long as TIMx_CNT>TIMx_CCRy else active
                pwm_mode2 = 0b111, // Inversely to PwmMode1
            };
            cc1s: u2, // Capture/Compare 1 selection
            oc1fe: u1, // Output Compare 1 fast enable
            oc1pe: u1, // Output Compare 1 preload enable
            oc1m: Oc1m, // Output Compare 1 mode (u3)
            _padding_7_31: u25,
        };
        pub const ccmr1_output = mmio(base_address + 0x18, 32, Ccmr1Output);

        /// address: 0x40014418
        /// capture/compare mode register 1 (input mode)
        pub const Ccmr1Input = packed struct {
            cc1s: u2, // Capture/Compare 1 selection
            ic1psc: u2, // Input capture 1 prescaler
            ic1f: u4, // Input capture 1 filter
            _padding_8_31: u24,
        };
        pub const ccmr1_input = mmio(base_address + 0x18, 32, Ccmr1Input);

        /// address: 0x40014420
        /// capture/compare enable register
        pub const Ccer = packed struct {
            cc1e: u1, // Capture/Compare 1 output enable
            cc1p: u1, // Capture/Compare 1 output Polarity
            _reserved_2_2: u1,
            cc1np: u1, // Capture/Compare 1 output Polarity
            _padding_4_31: u28,
        };
        pub const ccer = mmio(base_address + 0x20, 32, Ccer);

        /// address: 0x40014424
        /// counter
        pub const cnt = mmioInt(base_address + 0x24, 32, u16);

        /// address: 0x40014428
        /// prescaler
        pub const psc = mmioInt(base_address + 0x28, 32, u16);

        /// address: 0x4001442c
        /// auto-reload register
        pub const arr = mmioInt(base_address + 0x2c, 32, u16);

        /// address: 0x40014434
        /// capture/compare register
        pub const Ccr1 = packed struct {
            ccr: u16, // Capture/Compare value
            _padding_16_31: u16,
        };
        pub const ccr1 = mmio(base_address + 0x34, 32, Ccr1);
    };
    /// General-purpose-timers
    pub const tim11 = struct {
        pub const base_address = 0x40014800;

        /// address: 0x40014800
        /// control register 1
        pub const Cr1 = packed struct {
            pub const Cen = enum(u1) {
                disabled = 0, // Counter disabled
                enabled = 1, // Counter enabled
            };
            pub const Udis = enum(u1) {
                enabled = 0, // Update event enabled
                disabled = 1, // Update event disabled
            };
            pub const Urs = enum(u1) {
                any_event = 0, // Any of counter overflow/underflow, setting UG, or update through slave mode, generates an update interrupt or DMA request
                counter_only = 1, // Only counter overflow/underflow generates an update interrupt or DMA request
            };
            pub const Opm = enum(u1) {
                disabled = 0, // Counter is not stopped at update event
                enabled = 1, // Counter stops counting at the next update event (clearing the CEN bit)
            };
            pub const Arpe = enum(u1) {
                disabled = 0, // TIMx_APRR register is not buffered
                enabled = 1, // TIMx_APRR register is buffered
            };
            pub const Ckd = enum(u2) {
                div1 = 0b00, // t_DTS = t_CK_INT
                div2 = 0b01, // t_DTS = 2  t_CK_INT
                div4 = 0b10, // t_DTS = 4  t_CK_INT
            };
            cen: Cen, // Counter enable (u1)
            udis: Udis, // Update disable (u1)
            urs: Urs, // Update request source (u1)
            opm: Opm, // One-pulse mode (u1)
            _reserved_4_6: u3,
            arpe: Arpe, // Auto-reload preload enable (u1)
            ckd: Ckd, // Clock division (u2)
            _padding_10_31: u22,
        };
        pub const cr1 = mmio(base_address + 0x0, 32, Cr1);

        /// address: 0x4001480c
        /// DMA/Interrupt enable register
        pub const Dier = packed struct {
            pub const Uie = enum(u1) {
                disabled = 0, // Update interrupt disabled
                enabled = 1, // Update interrupt enabled
            };
            uie: Uie, // Update interrupt enable (u1)
            cc1ie: u1, // Capture/Compare 1 interrupt enable
            _padding_2_31: u30,
        };
        pub const dier = mmio(base_address + 0xc, 32, Dier);

        /// address: 0x40014810
        /// status register
        pub const Sr = packed struct {
            pub const Uif = enum(u1) {
                clear = 0, // No update occurred
                update_pending = 1, // Update interrupt pending.
            };
            uif: Uif, // Update interrupt flag (u1)
            cc1if: u1, // Capture/compare 1 interrupt flag
            _reserved_2_8: u7,
            cc1of: u1, // Capture/Compare 1 overcapture flag
            _padding_10_31: u22,
        };
        pub const sr = mmio(base_address + 0x10, 32, Sr);

        /// address: 0x40014814
        /// event generation register
        pub const Egr = packed struct {
            pub const Ug = enum(u1) {
                update = 1, // Re-initializes the timer counter and generates an update of the registers.
            };
            ug: Ug, // Update generation (u1)
            cc1g: u1, // Capture/compare 1 generation
            _padding_2_31: u30,
        };
        pub const egr = mmio(base_address + 0x14, 32, Egr);

        /// address: 0x40014818
        /// capture/compare mode register 1 (output mode)
        pub const Ccmr1Output = packed struct {
            pub const Oc1m = enum(u3) {
                frozen = 0b000, // The comparison between the output compare register TIMx_CCRy and the counter TIMx_CNT has no effect on the outputs
                active_on_match = 0b001, // Set channel to active level on match. OCyREF signal is forced high when the counter matches the capture/compare register
                inactive_on_match = 0b010, // Set channel to inactive level on match. OCyREF signal is forced low when the counter matches the capture/compare register
                toggle = 0b011, // OCyREF toggles when TIMx_CNT=TIMx_CCRy
                force_inactive = 0b100, // OCyREF is forced low
                force_active = 0b101, // OCyREF is forced high
                pwm_mode1 = 0b110, // In upcounting, channel is active as long as TIMx_CNT<TIMx_CCRy else inactive. In downcounting, channel is inactive as long as TIMx_CNT>TIMx_CCRy else active
                pwm_mode2 = 0b111, // Inversely to PwmMode1
            };
            cc1s: u2, // Capture/Compare 1 selection
            oc1fe: u1, // Output Compare 1 fast enable
            oc1pe: u1, // Output Compare 1 preload enable
            oc1m: Oc1m, // Output Compare 1 mode (u3)
            _padding_7_31: u25,
        };
        pub const ccmr1_output = mmio(base_address + 0x18, 32, Ccmr1Output);

        /// address: 0x40014818
        /// capture/compare mode register 1 (input mode)
        pub const Ccmr1Input = packed struct {
            cc1s: u2, // Capture/Compare 1 selection
            ic1psc: u2, // Input capture 1 prescaler
            ic1f: u4, // Input capture 1 filter
            _padding_8_31: u24,
        };
        pub const ccmr1_input = mmio(base_address + 0x18, 32, Ccmr1Input);

        /// address: 0x40014820
        /// capture/compare enable register
        pub const Ccer = packed struct {
            cc1e: u1, // Capture/Compare 1 output enable
            cc1p: u1, // Capture/Compare 1 output Polarity
            _reserved_2_2: u1,
            cc1np: u1, // Capture/Compare 1 output Polarity
            _padding_4_31: u28,
        };
        pub const ccer = mmio(base_address + 0x20, 32, Ccer);

        /// address: 0x40014824
        /// counter
        pub const cnt = mmioInt(base_address + 0x24, 32, u16);

        /// address: 0x40014828
        /// prescaler
        pub const psc = mmioInt(base_address + 0x28, 32, u16);

        /// address: 0x4001482c
        /// auto-reload register
        pub const arr = mmioInt(base_address + 0x2c, 32, u16);

        /// address: 0x40014834
        /// capture/compare register
        pub const Ccr1 = packed struct {
            ccr: u16, // Capture/Compare value
            _padding_16_31: u16,
        };
        pub const ccr1 = mmio(base_address + 0x34, 32, Ccr1);

        /// address: 0x40014850
        /// option register
        pub const Or = packed struct {
            rmp: u2, // Input 1 remapping capability
            _padding_2_31: u30,
        };
        pub const @"or" = mmio(base_address + 0x50, 32, Or);
    };
    /// General purpose timers
    pub const tim2 = struct {
        pub const base_address = 0x40000000;

        /// address: 0x40000000
        /// control register 1
        pub const Cr1 = packed struct {
            pub const Cen = enum(u1) {
                disabled = 0, // Counter disabled
                enabled = 1, // Counter enabled
            };
            pub const Udis = enum(u1) {
                enabled = 0, // Update event enabled
                disabled = 1, // Update event disabled
            };
            pub const Urs = enum(u1) {
                any_event = 0, // Any of counter overflow/underflow, setting UG, or update through slave mode, generates an update interrupt or DMA request
                counter_only = 1, // Only counter overflow/underflow generates an update interrupt or DMA request
            };
            pub const Opm = enum(u1) {
                disabled = 0, // Counter is not stopped at update event
                enabled = 1, // Counter stops counting at the next update event (clearing the CEN bit)
            };
            pub const Dir = enum(u1) {
                up = 0, // Counter used as upcounter
                down = 1, // Counter used as downcounter
            };
            pub const Cms = enum(u2) {
                edge_aligned = 0b00, // The counter counts up or down depending on the direction bit
                center_aligned1 = 0b01, // The counter counts up and down alternatively. Output compare interrupt flags are set only when the counter is counting down.
                center_aligned2 = 0b10, // The counter counts up and down alternatively. Output compare interrupt flags are set only when the counter is counting up.
                center_aligned3 = 0b11, // The counter counts up and down alternatively. Output compare interrupt flags are set both when the counter is counting up or down.
            };
            pub const Arpe = enum(u1) {
                disabled = 0, // TIMx_APRR register is not buffered
                enabled = 1, // TIMx_APRR register is buffered
            };
            pub const Ckd = enum(u2) {
                div1 = 0b00, // t_DTS = t_CK_INT
                div2 = 0b01, // t_DTS = 2  t_CK_INT
                div4 = 0b10, // t_DTS = 4  t_CK_INT
            };
            cen: Cen, // Counter enable (u1)
            udis: Udis, // Update disable (u1)
            urs: Urs, // Update request source (u1)
            opm: Opm, // One-pulse mode (u1)
            dir: Dir, // Direction (u1)
            cms: Cms, // Center-aligned mode selection (u2)
            arpe: Arpe, // Auto-reload preload enable (u1)
            ckd: Ckd, // Clock division (u2)
            _padding_10_31: u22,
        };
        pub const cr1 = mmio(base_address + 0x0, 32, Cr1);

        /// address: 0x40000004
        /// control register 2
        pub const Cr2 = packed struct {
            pub const Ccds = enum(u1) {
                on_compare = 0, // CCx DMA request sent when CCx event occurs
                on_update = 1, // CCx DMA request sent when update event occurs
            };
            pub const Mms = enum(u3) {
                reset = 0b000, // The UG bit from the TIMx_EGR register is used as trigger output
                enable = 0b001, // The counter enable signal, CNT_EN, is used as trigger output
                update = 0b010, // The update event is selected as trigger output
                compare_pulse = 0b011, // The trigger output send a positive pulse when the CC1IF flag it to be set, as soon as a capture or a compare match occurred
                compare_oc1 = 0b100, // OC1REF signal is used as trigger output
                compare_oc2 = 0b101, // OC2REF signal is used as trigger output
                compare_oc3 = 0b110, // OC3REF signal is used as trigger output
                compare_oc4 = 0b111, // OC4REF signal is used as trigger output
            };
            pub const Ti1s = enum(u1) {
                normal = 0, // The TIMx_CH1 pin is connected to TI1 input
                xor = 1, // The TIMx_CH1, CH2, CH3 pins are connected to TI1 input
            };
            _reserved_0_2: u3,
            ccds: Ccds, // Capture/compare DMA selection (u1)
            mms: Mms, // Master mode selection (u3)
            ti1s: Ti1s, // TI1 selection (u1)
            _padding_8_31: u24,
        };
        pub const cr2 = mmio(base_address + 0x4, 32, Cr2);

        /// address: 0x40000008
        /// slave mode control register
        pub const Smcr = packed struct {
            pub const Sms = enum(u3) {
                disabled = 0b000, // Slave mode disabled - if CEN = 1 then the prescaler is clocked directly by the internal clock.
                encoder_mode_1 = 0b001, // Encoder mode 1 - Counter counts up/down on TI2FP1 edge depending on TI1FP2 level.
                encoder_mode_2 = 0b010, // Encoder mode 2 - Counter counts up/down on TI1FP2 edge depending on TI2FP1 level.
                encoder_mode_3 = 0b011, // Encoder mode 3 - Counter counts up/down on both TI1FP1 and TI2FP2 edges depending on the level of the other input.
                reset_mode = 0b100, // Reset Mode - Rising edge of the selected trigger input (TRGI) reinitializes the counter and generates an update of the registers.
                gated_mode = 0b101, // Gated Mode - The counter clock is enabled when the trigger input (TRGI) is high. The counter stops (but is not reset) as soon as the trigger becomes low. Both start and stop of the counter are controlled.
                trigger_mode = 0b110, // Trigger Mode - The counter starts at a rising edge of the trigger TRGI (but it is not reset). Only the start of the counter is controlled.
                ext_clock_mode = 0b111, // External Clock Mode 1 - Rising edges of the selected trigger (TRGI) clock the counter.
            };
            pub const Ts = enum(u3) {
                itr0 = 0b000, // Internal Trigger 0 (ITR0)
                itr1 = 0b001, // Internal Trigger 1 (ITR1)
                itr2 = 0b010, // Internal Trigger 2 (ITR2)
                ti1_f_ed = 0b100, // TI1 Edge Detector (TI1F_ED)
                ti1_fp1 = 0b101, // Filtered Timer Input 1 (TI1FP1)
                ti2_fp2 = 0b110, // Filtered Timer Input 2 (TI2FP2)
                etrf = 0b111, // External Trigger input (ETRF)
            };
            pub const Msm = enum(u1) {
                no_sync = 0, // No action
                sync = 1, // The effect of an event on the trigger input (TRGI) is delayed to allow a perfect synchronization between the current timer and its slaves (through TRGO). It is useful if we want to synchronize several timers on a single external event.
            };
            pub const Etf = enum(u4) {
                no_filter = 0b0000, // No filter, sampling is done at fDTS
                fck_int_n2 = 0b0001, // fSAMPLING=fCK_INT, N=2
                fck_int_n4 = 0b0010, // fSAMPLING=fCK_INT, N=4
                fck_int_n8 = 0b0011, // fSAMPLING=fCK_INT, N=8
                fdts_div2_n6 = 0b0100, // fSAMPLING=fDTS/2, N=6
                fdts_div2_n8 = 0b0101, // fSAMPLING=fDTS/2, N=8
                fdts_div4_n6 = 0b0110, // fSAMPLING=fDTS/4, N=6
                fdts_div4_n8 = 0b0111, // fSAMPLING=fDTS/4, N=8
                fdts_div8_n6 = 0b1000, // fSAMPLING=fDTS/8, N=6
                fdts_div8_n8 = 0b1001, // fSAMPLING=fDTS/8, N=8
                fdts_div16_n5 = 0b1010, // fSAMPLING=fDTS/16, N=5
                fdts_div16_n6 = 0b1011, // fSAMPLING=fDTS/16, N=6
                fdts_div16_n8 = 0b1100, // fSAMPLING=fDTS/16, N=8
                fdts_div32_n5 = 0b1101, // fSAMPLING=fDTS/32, N=5
                fdts_div32_n6 = 0b1110, // fSAMPLING=fDTS/32, N=6
                fdts_div32_n8 = 0b1111, // fSAMPLING=fDTS/32, N=8
            };
            pub const Etps = enum(u2) {
                div1 = 0b00, // Prescaler OFF
                div2 = 0b01, // ETRP frequency divided by 2
                div4 = 0b10, // ETRP frequency divided by 4
                div8 = 0b11, // ETRP frequency divided by 8
            };
            pub const Ece = enum(u1) {
                disabled = 0, // External clock mode 2 disabled
                enabled = 1, // External clock mode 2 enabled. The counter is clocked by any active edge on the ETRF signal.
            };
            pub const Etp = enum(u1) {
                not_inverted = 0, // ETR is noninverted, active at high level or rising edge
                inverted = 1, // ETR is inverted, active at low level or falling edge
            };
            sms: Sms, // Slave mode selection (u3)
            _reserved_3_3: u1,
            ts: Ts, // Trigger selection (u3)
            msm: Msm, // Master/Slave mode (u1)
            etf: Etf, // External trigger filter (u4)
            etps: Etps, // External trigger prescaler (u2)
            ece: Ece, // External clock enable (u1)
            etp: Etp, // External trigger polarity (u1)
            _padding_16_31: u16,
        };
        pub const smcr = mmio(base_address + 0x8, 32, Smcr);

        /// address: 0x4000000c
        /// DMA/Interrupt enable register
        pub const Dier = packed struct {
            pub const Uie = enum(u1) {
                disabled = 0, // Update interrupt disabled
                enabled = 1, // Update interrupt enabled
            };
            pub const Cc1ie = enum(u1) {
                disabled = 0, // CCx interrupt disabled
                enabled = 1, // CCx interrupt enabled
            };
            pub const Tie = enum(u1) {
                disabled = 0, // Trigger interrupt disabled
                enabled = 1, // Trigger interrupt enabled
            };
            pub const Ude = enum(u1) {
                disabled = 0, // Update DMA request disabled
                enabled = 1, // Update DMA request enabled
            };
            pub const Cc1de = enum(u1) {
                disabled = 0, // CCx DMA request disabled
                enabled = 1, // CCx DMA request enabled
            };
            pub const Tde = enum(u1) {
                disabled = 0, // Trigger DMA request disabled
                enabled = 1, // Trigger DMA request enabled
            };
            uie: Uie, // Update interrupt enable (u1)
            cc1ie: Cc1ie, // Capture/Compare 1 interrupt enable (u1)
            cc2ie: Cc1ie, // Capture/Compare 2 interrupt enable (u1)
            cc3ie: Cc1ie, // Capture/Compare 3 interrupt enable (u1)
            cc4ie: Cc1ie, // Capture/Compare 4 interrupt enable (u1)
            _reserved_5_5: u1,
            tie: Tie, // Trigger interrupt enable (u1)
            _reserved_7_7: u1,
            ude: Ude, // Update DMA request enable (u1)
            cc1de: Cc1de, // Capture/Compare 1 DMA request enable (u1)
            cc2de: Cc1de, // Capture/Compare 2 DMA request enable (u1)
            cc3de: Cc1de, // Capture/Compare 3 DMA request enable (u1)
            cc4de: Cc1de, // Capture/Compare 4 DMA request enable (u1)
            _reserved_13_13: u1,
            tde: Tde, // Trigger DMA request enable (u1)
            _padding_15_31: u17,
        };
        pub const dier = mmio(base_address + 0xc, 32, Dier);

        /// address: 0x40000010
        /// status register
        pub const Sr = packed struct {
            pub const Uif = enum(u1) {
                clear = 0, // No update occurred
                update_pending = 1, // Update interrupt pending.
            };
            pub const Cc1if = enum(u1) {
                match = 1, // If CC1 is an output: The content of the counter TIMx_CNT matches the content of the TIMx_CCR1 register. If CC1 is an input: The counter value has been captured in TIMx_CCR1 register.
                clear = 0, // Clear flag
            };
            pub const Tif = enum(u1) {
                no_trigger = 0, // No trigger event occurred
                trigger = 1, // Trigger interrupt pending
                pub const clear = @intToEnum(Tif, 0); // Clear flag
            };
            pub const Cc1of = enum(u1) {
                overcapture = 1, // The counter value has been captured in TIMx_CCRx register while CCxIF flag was already set
                clear = 0, // Clear flag
            };
            uif: Uif, // Update interrupt flag (u1)
            cc1if: Cc1if, // Capture/compare 1 interrupt flag (u1)
            cc2if: Cc1if, // Capture/Compare 2 interrupt flag (u1)
            cc3if: Cc1if, // Capture/Compare 3 interrupt flag (u1)
            cc4if: Cc1if, // Capture/Compare 4 interrupt flag (u1)
            _reserved_5_5: u1,
            tif: Tif, // Trigger interrupt flag (u1)
            _reserved_7_8: u2,
            cc1of: Cc1of, // Capture/Compare 1 overcapture flag (u1)
            cc2of: Cc1of, // Capture/compare 2 overcapture flag (u1)
            cc3of: Cc1of, // Capture/Compare 3 overcapture flag (u1)
            cc4of: Cc1of, // Capture/Compare 4 overcapture flag (u1)
            _padding_13_31: u19,
        };
        pub const sr = mmio(base_address + 0x10, 32, Sr);

        /// address: 0x40000014
        /// event generation register
        pub const Egr = packed struct {
            pub const Ug = enum(u1) {
                update = 1, // Re-initializes the timer counter and generates an update of the registers.
            };
            pub const Cc1gw = enum(u1) {
                trigger = 1, // If CC1 is an output: CC1IF flag is set, Corresponding interrupt or DMA request is sent if enabled. If CC1 is an input: The current value of the counter is captured in TIMx_CCR1 register.
            };
            pub const Tgw = enum(u1) {
                trigger = 1, // The TIF flag is set in TIMx_SR register. Related interrupt or DMA transfer can occur if enabled.
            };
            ug: Ug, // Update generation (u1)
            cc1g: Cc1gw, // Capture/compare 1 generation (u1)
            cc2g: Cc1gw, // Capture/compare 2 generation (u1)
            cc3g: Cc1gw, // Capture/compare 3 generation (u1)
            cc4g: Cc1gw, // Capture/compare 4 generation (u1)
            _reserved_5_5: u1,
            tg: Tgw, // Trigger generation (u1)
            _padding_7_31: u25,
        };
        pub const egr = mmio(base_address + 0x14, 32, Egr);

        /// address: 0x40000018
        /// capture/compare mode register 1 (output mode)
        pub const Ccmr1Output = packed struct {
            pub const Cc1s = enum(u2) {
                output = 0b00, // CC1 channel is configured as output
            };
            pub const Oc1pe = enum(u1) {
                disabled = 0, // Preload register on CCR1 disabled. New values written to CCR1 are taken into account immediately
                enabled = 1, // Preload register on CCR1 enabled. Preload value is loaded into active register on each update event
            };
            pub const Oc1m = enum(u3) {
                frozen = 0b000, // The comparison between the output compare register TIMx_CCRy and the counter TIMx_CNT has no effect on the outputs
                active_on_match = 0b001, // Set channel to active level on match. OCyREF signal is forced high when the counter matches the capture/compare register
                inactive_on_match = 0b010, // Set channel to inactive level on match. OCyREF signal is forced low when the counter matches the capture/compare register
                toggle = 0b011, // OCyREF toggles when TIMx_CNT=TIMx_CCRy
                force_inactive = 0b100, // OCyREF is forced low
                force_active = 0b101, // OCyREF is forced high
                pwm_mode1 = 0b110, // In upcounting, channel is active as long as TIMx_CNT<TIMx_CCRy else inactive. In downcounting, channel is inactive as long as TIMx_CNT>TIMx_CCRy else active
                pwm_mode2 = 0b111, // Inversely to PwmMode1
            };
            pub const Cc2s = enum(u2) {
                output = 0b00, // CC2 channel is configured as output
            };
            pub const Oc2pe = enum(u1) {
                disabled = 0, // Preload register on CCR2 disabled. New values written to CCR2 are taken into account immediately
                enabled = 1, // Preload register on CCR2 enabled. Preload value is loaded into active register on each update event
            };
            cc1s: Cc1s, // CC1S (u2)
            oc1fe: u1, // OC1FE
            oc1pe: Oc1pe, // OC1PE (u1)
            oc1m: Oc1m, // OC1M (u3)
            oc1ce: u1, // OC1CE
            cc2s: Cc2s, // CC2S (u2)
            oc2fe: u1, // OC2FE
            oc2pe: Oc2pe, // OC2PE (u1)
            oc2m: Oc1m, // OC2M (u3)
            oc2ce: u1, // OC2CE
            _padding_16_31: u16,
        };
        pub const ccmr1_output = mmio(base_address + 0x18, 32, Ccmr1Output);

        /// address: 0x40000018
        /// capture/compare mode register 1 (input mode)
        pub const Ccmr1Input = packed struct {
            pub const Cc1s = enum(u2) {
                ti1 = 0b01, // CC1 channel is configured as input, IC1 is mapped on TI1
                ti2 = 0b10, // CC1 channel is configured as input, IC1 is mapped on TI2
                trc = 0b11, // CC1 channel is configured as input, IC1 is mapped on TRC
            };
            pub const Ic1f = enum(u4) {
                no_filter = 0b0000, // No filter, sampling is done at fDTS
                fck_int_n2 = 0b0001, // fSAMPLING=fCK_INT, N=2
                fck_int_n4 = 0b0010, // fSAMPLING=fCK_INT, N=4
                fck_int_n8 = 0b0011, // fSAMPLING=fCK_INT, N=8
                fdts_div2_n6 = 0b0100, // fSAMPLING=fDTS/2, N=6
                fdts_div2_n8 = 0b0101, // fSAMPLING=fDTS/2, N=8
                fdts_div4_n6 = 0b0110, // fSAMPLING=fDTS/4, N=6
                fdts_div4_n8 = 0b0111, // fSAMPLING=fDTS/4, N=8
                fdts_div8_n6 = 0b1000, // fSAMPLING=fDTS/8, N=6
                fdts_div8_n8 = 0b1001, // fSAMPLING=fDTS/8, N=8
                fdts_div16_n5 = 0b1010, // fSAMPLING=fDTS/16, N=5
                fdts_div16_n6 = 0b1011, // fSAMPLING=fDTS/16, N=6
                fdts_div16_n8 = 0b1100, // fSAMPLING=fDTS/16, N=8
                fdts_div32_n5 = 0b1101, // fSAMPLING=fDTS/32, N=5
                fdts_div32_n6 = 0b1110, // fSAMPLING=fDTS/32, N=6
                fdts_div32_n8 = 0b1111, // fSAMPLING=fDTS/32, N=8
            };
            pub const Cc2s = enum(u2) {
                ti2 = 0b01, // CC2 channel is configured as input, IC2 is mapped on TI2
                ti1 = 0b10, // CC2 channel is configured as input, IC2 is mapped on TI1
                trc = 0b11, // CC2 channel is configured as input, IC2 is mapped on TRC
            };
            cc1s: Cc1s, // Capture/Compare 1 selection (u2)
            ic1psc: u2, // Input capture 1 prescaler
            ic1f: Ic1f, // Input capture 1 filter (u4)
            cc2s: Cc2s, // Capture/Compare 2 selection (u2)
            ic2psc: u2, // Input capture 2 prescaler
            ic2f: u4, // Input capture 2 filter
            _padding_16_31: u16,
        };
        pub const ccmr1_input = mmio(base_address + 0x18, 32, Ccmr1Input);

        /// address: 0x4000001c
        /// capture/compare mode register 2 (output mode)
        pub const Ccmr2Output = packed struct {
            pub const Cc3s = enum(u2) {
                output = 0b00, // CC3 channel is configured as output
            };
            pub const Oc3pe = enum(u1) {
                disabled = 0, // Preload register on CCR3 disabled. New values written to CCR3 are taken into account immediately
                enabled = 1, // Preload register on CCR3 enabled. Preload value is loaded into active register on each update event
            };
            pub const Oc3m = enum(u3) {
                frozen = 0b000, // The comparison between the output compare register TIMx_CCRy and the counter TIMx_CNT has no effect on the outputs
                active_on_match = 0b001, // Set channel to active level on match. OCyREF signal is forced high when the counter matches the capture/compare register
                inactive_on_match = 0b010, // Set channel to inactive level on match. OCyREF signal is forced low when the counter matches the capture/compare register
                toggle = 0b011, // OCyREF toggles when TIMx_CNT=TIMx_CCRy
                force_inactive = 0b100, // OCyREF is forced low
                force_active = 0b101, // OCyREF is forced high
                pwm_mode1 = 0b110, // In upcounting, channel is active as long as TIMx_CNT<TIMx_CCRy else inactive. In downcounting, channel is inactive as long as TIMx_CNT>TIMx_CCRy else active
                pwm_mode2 = 0b111, // Inversely to PwmMode1
            };
            pub const Cc4s = enum(u2) {
                output = 0b00, // CC4 channel is configured as output
            };
            pub const Oc4pe = enum(u1) {
                disabled = 0, // Preload register on CCR4 disabled. New values written to CCR4 are taken into account immediately
                enabled = 1, // Preload register on CCR4 enabled. Preload value is loaded into active register on each update event
            };
            cc3s: Cc3s, // CC3S (u2)
            oc3fe: u1, // OC3FE
            oc3pe: Oc3pe, // OC3PE (u1)
            oc3m: Oc3m, // OC3M (u3)
            oc3ce: u1, // OC3CE
            cc4s: Cc4s, // CC4S (u2)
            oc4fe: u1, // OC4FE
            oc4pe: Oc4pe, // OC4PE (u1)
            oc4m: Oc3m, // OC4M (u3)
            oc4ce: u1, // O24CE
            _padding_16_31: u16,
        };
        pub const ccmr2_output = mmio(base_address + 0x1c, 32, Ccmr2Output);

        /// address: 0x4000001c
        /// capture/compare mode register 2 (input mode)
        pub const Ccmr2Input = packed struct {
            pub const Cc3s = enum(u2) {
                ti3 = 0b01, // CC3 channel is configured as input, IC3 is mapped on TI3
                ti4 = 0b10, // CC3 channel is configured as input, IC3 is mapped on TI4
                trc = 0b11, // CC3 channel is configured as input, IC3 is mapped on TRC
            };
            pub const Cc4s = enum(u2) {
                ti4 = 0b01, // CC4 channel is configured as input, IC4 is mapped on TI4
                ti3 = 0b10, // CC4 channel is configured as input, IC4 is mapped on TI3
                trc = 0b11, // CC4 channel is configured as input, IC4 is mapped on TRC
            };
            cc3s: Cc3s, // Capture/compare 3 selection (u2)
            ic3psc: u2, // Input capture 3 prescaler
            ic3f: u4, // Input capture 3 filter
            cc4s: Cc4s, // Capture/Compare 4 selection (u2)
            ic4psc: u2, // Input capture 4 prescaler
            ic4f: u4, // Input capture 4 filter
            _padding_16_31: u16,
        };
        pub const ccmr2_input = mmio(base_address + 0x1c, 32, Ccmr2Input);

        /// address: 0x40000020
        /// capture/compare enable register
        pub const Ccer = packed struct {
            cc1e: u1, // Capture/Compare 1 output enable
            cc1p: u1, // Capture/Compare 1 output Polarity
            _reserved_2_2: u1,
            cc1np: u1, // Capture/Compare 1 output Polarity
            cc2e: u1, // Capture/Compare 2 output enable
            cc2p: u1, // Capture/Compare 2 output Polarity
            _reserved_6_6: u1,
            cc2np: u1, // Capture/Compare 2 output Polarity
            cc3e: u1, // Capture/Compare 3 output enable
            cc3p: u1, // Capture/Compare 3 output Polarity
            _reserved_10_10: u1,
            cc3np: u1, // Capture/Compare 3 output Polarity
            cc4e: u1, // Capture/Compare 4 output enable
            cc4p: u1, // Capture/Compare 3 output Polarity
            _reserved_14_14: u1,
            cc4np: u1, // Capture/Compare 4 output Polarity
            _padding_16_31: u16,
        };
        pub const ccer = mmio(base_address + 0x20, 32, Ccer);

        /// address: 0x40000024
        /// counter
        pub const cnt = @intToPtr(*volatile u32, base_address + 0x24);

        /// address: 0x40000028
        /// prescaler
        pub const psc = mmioInt(base_address + 0x28, 32, u16);

        /// address: 0x4000002c
        /// auto-reload register
        pub const arr = @intToPtr(*volatile u32, base_address + 0x2c);

        /// address: 0x40000034
        /// capture/compare register
        pub const Ccr1 = packed struct {
            ccr: u32, // Capture/Compare value
        };
        pub const ccr1 = mmio(base_address + 0x34, 32, Ccr1);

        /// address: 0x40000038
        /// capture/compare register
        pub const Ccr2 = packed struct {
            ccr: u32, // Capture/Compare value
        };
        pub const ccr2 = mmio(base_address + 0x38, 32, Ccr2);

        /// address: 0x4000003c
        /// capture/compare register
        pub const Ccr3 = packed struct {
            ccr: u32, // Capture/Compare value
        };
        pub const ccr3 = mmio(base_address + 0x3c, 32, Ccr3);

        /// address: 0x40000040
        /// capture/compare register
        pub const Ccr4 = packed struct {
            ccr: u32, // Capture/Compare value
        };
        pub const ccr4 = mmio(base_address + 0x40, 32, Ccr4);

        /// address: 0x40000048
        /// DMA control register
        pub const Dcr = packed struct {
            dba: u5, // DMA base address
            _reserved_5_7: u3,
            dbl: u5, // DMA burst length
            _padding_13_31: u19,
        };
        pub const dcr = mmio(base_address + 0x48, 32, Dcr);

        /// address: 0x4000004c
        /// DMA address for full transfer
        pub const Dmar = packed struct {
            dmab: u16, // DMA register for burst accesses
            _padding_16_31: u16,
        };
        pub const dmar = mmio(base_address + 0x4c, 32, Dmar);

        /// address: 0x40000050
        /// TIM5 option register
        pub const Or = packed struct {
            _reserved_0_9: u10,
            itr1_rmp: u2, // Timer Input 4 remap
            _padding_12_31: u20,
        };
        pub const @"or" = mmio(base_address + 0x50, 32, Or);
    };
    /// General purpose timers
    pub const tim3 = struct {
        pub const base_address = 0x40000400;

        /// address: 0x40000400
        /// control register 1
        pub const Cr1 = packed struct {
            pub const Cen = enum(u1) {
                disabled = 0, // Counter disabled
                enabled = 1, // Counter enabled
            };
            pub const Udis = enum(u1) {
                enabled = 0, // Update event enabled
                disabled = 1, // Update event disabled
            };
            pub const Urs = enum(u1) {
                any_event = 0, // Any of counter overflow/underflow, setting UG, or update through slave mode, generates an update interrupt or DMA request
                counter_only = 1, // Only counter overflow/underflow generates an update interrupt or DMA request
            };
            pub const Opm = enum(u1) {
                disabled = 0, // Counter is not stopped at update event
                enabled = 1, // Counter stops counting at the next update event (clearing the CEN bit)
            };
            pub const Dir = enum(u1) {
                up = 0, // Counter used as upcounter
                down = 1, // Counter used as downcounter
            };
            pub const Cms = enum(u2) {
                edge_aligned = 0b00, // The counter counts up or down depending on the direction bit
                center_aligned1 = 0b01, // The counter counts up and down alternatively. Output compare interrupt flags are set only when the counter is counting down.
                center_aligned2 = 0b10, // The counter counts up and down alternatively. Output compare interrupt flags are set only when the counter is counting up.
                center_aligned3 = 0b11, // The counter counts up and down alternatively. Output compare interrupt flags are set both when the counter is counting up or down.
            };
            pub const Arpe = enum(u1) {
                disabled = 0, // TIMx_APRR register is not buffered
                enabled = 1, // TIMx_APRR register is buffered
            };
            pub const Ckd = enum(u2) {
                div1 = 0b00, // t_DTS = t_CK_INT
                div2 = 0b01, // t_DTS = 2  t_CK_INT
                div4 = 0b10, // t_DTS = 4  t_CK_INT
            };
            cen: Cen, // Counter enable (u1)
            udis: Udis, // Update disable (u1)
            urs: Urs, // Update request source (u1)
            opm: Opm, // One-pulse mode (u1)
            dir: Dir, // Direction (u1)
            cms: Cms, // Center-aligned mode selection (u2)
            arpe: Arpe, // Auto-reload preload enable (u1)
            ckd: Ckd, // Clock division (u2)
            _padding_10_31: u22,
        };
        pub const cr1 = mmio(base_address + 0x0, 32, Cr1);

        /// address: 0x40000404
        /// control register 2
        pub const Cr2 = packed struct {
            pub const Ccds = enum(u1) {
                on_compare = 0, // CCx DMA request sent when CCx event occurs
                on_update = 1, // CCx DMA request sent when update event occurs
            };
            pub const Mms = enum(u3) {
                reset = 0b000, // The UG bit from the TIMx_EGR register is used as trigger output
                enable = 0b001, // The counter enable signal, CNT_EN, is used as trigger output
                update = 0b010, // The update event is selected as trigger output
                compare_pulse = 0b011, // The trigger output send a positive pulse when the CC1IF flag it to be set, as soon as a capture or a compare match occurred
                compare_oc1 = 0b100, // OC1REF signal is used as trigger output
                compare_oc2 = 0b101, // OC2REF signal is used as trigger output
                compare_oc3 = 0b110, // OC3REF signal is used as trigger output
                compare_oc4 = 0b111, // OC4REF signal is used as trigger output
            };
            pub const Ti1s = enum(u1) {
                normal = 0, // The TIMx_CH1 pin is connected to TI1 input
                xor = 1, // The TIMx_CH1, CH2, CH3 pins are connected to TI1 input
            };
            _reserved_0_2: u3,
            ccds: Ccds, // Capture/compare DMA selection (u1)
            mms: Mms, // Master mode selection (u3)
            ti1s: Ti1s, // TI1 selection (u1)
            _padding_8_31: u24,
        };
        pub const cr2 = mmio(base_address + 0x4, 32, Cr2);

        /// address: 0x40000408
        /// slave mode control register
        pub const Smcr = packed struct {
            pub const Sms = enum(u3) {
                disabled = 0b000, // Slave mode disabled - if CEN = 1 then the prescaler is clocked directly by the internal clock.
                encoder_mode_1 = 0b001, // Encoder mode 1 - Counter counts up/down on TI2FP1 edge depending on TI1FP2 level.
                encoder_mode_2 = 0b010, // Encoder mode 2 - Counter counts up/down on TI1FP2 edge depending on TI2FP1 level.
                encoder_mode_3 = 0b011, // Encoder mode 3 - Counter counts up/down on both TI1FP1 and TI2FP2 edges depending on the level of the other input.
                reset_mode = 0b100, // Reset Mode - Rising edge of the selected trigger input (TRGI) reinitializes the counter and generates an update of the registers.
                gated_mode = 0b101, // Gated Mode - The counter clock is enabled when the trigger input (TRGI) is high. The counter stops (but is not reset) as soon as the trigger becomes low. Both start and stop of the counter are controlled.
                trigger_mode = 0b110, // Trigger Mode - The counter starts at a rising edge of the trigger TRGI (but it is not reset). Only the start of the counter is controlled.
                ext_clock_mode = 0b111, // External Clock Mode 1 - Rising edges of the selected trigger (TRGI) clock the counter.
            };
            pub const Ts = enum(u3) {
                itr0 = 0b000, // Internal Trigger 0 (ITR0)
                itr1 = 0b001, // Internal Trigger 1 (ITR1)
                itr2 = 0b010, // Internal Trigger 2 (ITR2)
                ti1_f_ed = 0b100, // TI1 Edge Detector (TI1F_ED)
                ti1_fp1 = 0b101, // Filtered Timer Input 1 (TI1FP1)
                ti2_fp2 = 0b110, // Filtered Timer Input 2 (TI2FP2)
                etrf = 0b111, // External Trigger input (ETRF)
            };
            pub const Msm = enum(u1) {
                no_sync = 0, // No action
                sync = 1, // The effect of an event on the trigger input (TRGI) is delayed to allow a perfect synchronization between the current timer and its slaves (through TRGO). It is useful if we want to synchronize several timers on a single external event.
            };
            pub const Etf = enum(u4) {
                no_filter = 0b0000, // No filter, sampling is done at fDTS
                fck_int_n2 = 0b0001, // fSAMPLING=fCK_INT, N=2
                fck_int_n4 = 0b0010, // fSAMPLING=fCK_INT, N=4
                fck_int_n8 = 0b0011, // fSAMPLING=fCK_INT, N=8
                fdts_div2_n6 = 0b0100, // fSAMPLING=fDTS/2, N=6
                fdts_div2_n8 = 0b0101, // fSAMPLING=fDTS/2, N=8
                fdts_div4_n6 = 0b0110, // fSAMPLING=fDTS/4, N=6
                fdts_div4_n8 = 0b0111, // fSAMPLING=fDTS/4, N=8
                fdts_div8_n6 = 0b1000, // fSAMPLING=fDTS/8, N=6
                fdts_div8_n8 = 0b1001, // fSAMPLING=fDTS/8, N=8
                fdts_div16_n5 = 0b1010, // fSAMPLING=fDTS/16, N=5
                fdts_div16_n6 = 0b1011, // fSAMPLING=fDTS/16, N=6
                fdts_div16_n8 = 0b1100, // fSAMPLING=fDTS/16, N=8
                fdts_div32_n5 = 0b1101, // fSAMPLING=fDTS/32, N=5
                fdts_div32_n6 = 0b1110, // fSAMPLING=fDTS/32, N=6
                fdts_div32_n8 = 0b1111, // fSAMPLING=fDTS/32, N=8
            };
            pub const Etps = enum(u2) {
                div1 = 0b00, // Prescaler OFF
                div2 = 0b01, // ETRP frequency divided by 2
                div4 = 0b10, // ETRP frequency divided by 4
                div8 = 0b11, // ETRP frequency divided by 8
            };
            pub const Ece = enum(u1) {
                disabled = 0, // External clock mode 2 disabled
                enabled = 1, // External clock mode 2 enabled. The counter is clocked by any active edge on the ETRF signal.
            };
            pub const Etp = enum(u1) {
                not_inverted = 0, // ETR is noninverted, active at high level or rising edge
                inverted = 1, // ETR is inverted, active at low level or falling edge
            };
            sms: Sms, // Slave mode selection (u3)
            _reserved_3_3: u1,
            ts: Ts, // Trigger selection (u3)
            msm: Msm, // Master/Slave mode (u1)
            etf: Etf, // External trigger filter (u4)
            etps: Etps, // External trigger prescaler (u2)
            ece: Ece, // External clock enable (u1)
            etp: Etp, // External trigger polarity (u1)
            _padding_16_31: u16,
        };
        pub const smcr = mmio(base_address + 0x8, 32, Smcr);

        /// address: 0x4000040c
        /// DMA/Interrupt enable register
        pub const Dier = packed struct {
            pub const Uie = enum(u1) {
                disabled = 0, // Update interrupt disabled
                enabled = 1, // Update interrupt enabled
            };
            pub const Cc1ie = enum(u1) {
                disabled = 0, // CCx interrupt disabled
                enabled = 1, // CCx interrupt enabled
            };
            pub const Tie = enum(u1) {
                disabled = 0, // Trigger interrupt disabled
                enabled = 1, // Trigger interrupt enabled
            };
            pub const Ude = enum(u1) {
                disabled = 0, // Update DMA request disabled
                enabled = 1, // Update DMA request enabled
            };
            pub const Cc1de = enum(u1) {
                disabled = 0, // CCx DMA request disabled
                enabled = 1, // CCx DMA request enabled
            };
            pub const Tde = enum(u1) {
                disabled = 0, // Trigger DMA request disabled
                enabled = 1, // Trigger DMA request enabled
            };
            uie: Uie, // Update interrupt enable (u1)
            cc1ie: Cc1ie, // Capture/Compare 1 interrupt enable (u1)
            cc2ie: Cc1ie, // Capture/Compare 2 interrupt enable (u1)
            cc3ie: Cc1ie, // Capture/Compare 3 interrupt enable (u1)
            cc4ie: Cc1ie, // Capture/Compare 4 interrupt enable (u1)
            _reserved_5_5: u1,
            tie: Tie, // Trigger interrupt enable (u1)
            _reserved_7_7: u1,
            ude: Ude, // Update DMA request enable (u1)
            cc1de: Cc1de, // Capture/Compare 1 DMA request enable (u1)
            cc2de: Cc1de, // Capture/Compare 2 DMA request enable (u1)
            cc3de: Cc1de, // Capture/Compare 3 DMA request enable (u1)
            cc4de: Cc1de, // Capture/Compare 4 DMA request enable (u1)
            _reserved_13_13: u1,
            tde: Tde, // Trigger DMA request enable (u1)
            _padding_15_31: u17,
        };
        pub const dier = mmio(base_address + 0xc, 32, Dier);

        /// address: 0x40000410
        /// status register
        pub const Sr = packed struct {
            pub const Uif = enum(u1) {
                clear = 0, // No update occurred
                update_pending = 1, // Update interrupt pending.
            };
            pub const Cc1if = enum(u1) {
                match = 1, // If CC1 is an output: The content of the counter TIMx_CNT matches the content of the TIMx_CCR1 register. If CC1 is an input: The counter value has been captured in TIMx_CCR1 register.
                clear = 0, // Clear flag
            };
            pub const Tif = enum(u1) {
                no_trigger = 0, // No trigger event occurred
                trigger = 1, // Trigger interrupt pending
                pub const clear = @intToEnum(Tif, 0); // Clear flag
            };
            pub const Cc1of = enum(u1) {
                overcapture = 1, // The counter value has been captured in TIMx_CCRx register while CCxIF flag was already set
                clear = 0, // Clear flag
            };
            uif: Uif, // Update interrupt flag (u1)
            cc1if: Cc1if, // Capture/compare 1 interrupt flag (u1)
            cc2if: Cc1if, // Capture/Compare 2 interrupt flag (u1)
            cc3if: Cc1if, // Capture/Compare 3 interrupt flag (u1)
            cc4if: Cc1if, // Capture/Compare 4 interrupt flag (u1)
            _reserved_5_5: u1,
            tif: Tif, // Trigger interrupt flag (u1)
            _reserved_7_8: u2,
            cc1of: Cc1of, // Capture/Compare 1 overcapture flag (u1)
            cc2of: Cc1of, // Capture/compare 2 overcapture flag (u1)
            cc3of: Cc1of, // Capture/Compare 3 overcapture flag (u1)
            cc4of: Cc1of, // Capture/Compare 4 overcapture flag (u1)
            _padding_13_31: u19,
        };
        pub const sr = mmio(base_address + 0x10, 32, Sr);

        /// address: 0x40000414
        /// event generation register
        pub const Egr = packed struct {
            pub const Ug = enum(u1) {
                update = 1, // Re-initializes the timer counter and generates an update of the registers.
            };
            pub const Cc1gw = enum(u1) {
                trigger = 1, // If CC1 is an output: CC1IF flag is set, Corresponding interrupt or DMA request is sent if enabled. If CC1 is an input: The current value of the counter is captured in TIMx_CCR1 register.
            };
            pub const Tgw = enum(u1) {
                trigger = 1, // The TIF flag is set in TIMx_SR register. Related interrupt or DMA transfer can occur if enabled.
            };
            ug: Ug, // Update generation (u1)
            cc1g: Cc1gw, // Capture/compare 1 generation (u1)
            cc2g: Cc1gw, // Capture/compare 2 generation (u1)
            cc3g: Cc1gw, // Capture/compare 3 generation (u1)
            cc4g: Cc1gw, // Capture/compare 4 generation (u1)
            _reserved_5_5: u1,
            tg: Tgw, // Trigger generation (u1)
            _padding_7_31: u25,
        };
        pub const egr = mmio(base_address + 0x14, 32, Egr);

        /// address: 0x40000418
        /// capture/compare mode register 1 (output mode)
        pub const Ccmr1Output = packed struct {
            pub const Cc1s = enum(u2) {
                output = 0b00, // CC1 channel is configured as output
            };
            pub const Oc1pe = enum(u1) {
                disabled = 0, // Preload register on CCR1 disabled. New values written to CCR1 are taken into account immediately
                enabled = 1, // Preload register on CCR1 enabled. Preload value is loaded into active register on each update event
            };
            pub const Oc1m = enum(u3) {
                frozen = 0b000, // The comparison between the output compare register TIMx_CCRy and the counter TIMx_CNT has no effect on the outputs
                active_on_match = 0b001, // Set channel to active level on match. OCyREF signal is forced high when the counter matches the capture/compare register
                inactive_on_match = 0b010, // Set channel to inactive level on match. OCyREF signal is forced low when the counter matches the capture/compare register
                toggle = 0b011, // OCyREF toggles when TIMx_CNT=TIMx_CCRy
                force_inactive = 0b100, // OCyREF is forced low
                force_active = 0b101, // OCyREF is forced high
                pwm_mode1 = 0b110, // In upcounting, channel is active as long as TIMx_CNT<TIMx_CCRy else inactive. In downcounting, channel is inactive as long as TIMx_CNT>TIMx_CCRy else active
                pwm_mode2 = 0b111, // Inversely to PwmMode1
            };
            pub const Cc2s = enum(u2) {
                output = 0b00, // CC2 channel is configured as output
            };
            pub const Oc2pe = enum(u1) {
                disabled = 0, // Preload register on CCR2 disabled. New values written to CCR2 are taken into account immediately
                enabled = 1, // Preload register on CCR2 enabled. Preload value is loaded into active register on each update event
            };
            cc1s: Cc1s, // CC1S (u2)
            oc1fe: u1, // OC1FE
            oc1pe: Oc1pe, // OC1PE (u1)
            oc1m: Oc1m, // OC1M (u3)
            oc1ce: u1, // OC1CE
            cc2s: Cc2s, // CC2S (u2)
            oc2fe: u1, // OC2FE
            oc2pe: Oc2pe, // OC2PE (u1)
            oc2m: Oc1m, // OC2M (u3)
            oc2ce: u1, // OC2CE
            _padding_16_31: u16,
        };
        pub const ccmr1_output = mmio(base_address + 0x18, 32, Ccmr1Output);

        /// address: 0x40000418
        /// capture/compare mode register 1 (input mode)
        pub const Ccmr1Input = packed struct {
            pub const Cc1s = enum(u2) {
                ti1 = 0b01, // CC1 channel is configured as input, IC1 is mapped on TI1
                ti2 = 0b10, // CC1 channel is configured as input, IC1 is mapped on TI2
                trc = 0b11, // CC1 channel is configured as input, IC1 is mapped on TRC
            };
            pub const Ic1f = enum(u4) {
                no_filter = 0b0000, // No filter, sampling is done at fDTS
                fck_int_n2 = 0b0001, // fSAMPLING=fCK_INT, N=2
                fck_int_n4 = 0b0010, // fSAMPLING=fCK_INT, N=4
                fck_int_n8 = 0b0011, // fSAMPLING=fCK_INT, N=8
                fdts_div2_n6 = 0b0100, // fSAMPLING=fDTS/2, N=6
                fdts_div2_n8 = 0b0101, // fSAMPLING=fDTS/2, N=8
                fdts_div4_n6 = 0b0110, // fSAMPLING=fDTS/4, N=6
                fdts_div4_n8 = 0b0111, // fSAMPLING=fDTS/4, N=8
                fdts_div8_n6 = 0b1000, // fSAMPLING=fDTS/8, N=6
                fdts_div8_n8 = 0b1001, // fSAMPLING=fDTS/8, N=8
                fdts_div16_n5 = 0b1010, // fSAMPLING=fDTS/16, N=5
                fdts_div16_n6 = 0b1011, // fSAMPLING=fDTS/16, N=6
                fdts_div16_n8 = 0b1100, // fSAMPLING=fDTS/16, N=8
                fdts_div32_n5 = 0b1101, // fSAMPLING=fDTS/32, N=5
                fdts_div32_n6 = 0b1110, // fSAMPLING=fDTS/32, N=6
                fdts_div32_n8 = 0b1111, // fSAMPLING=fDTS/32, N=8
            };
            pub const Cc2s = enum(u2) {
                ti2 = 0b01, // CC2 channel is configured as input, IC2 is mapped on TI2
                ti1 = 0b10, // CC2 channel is configured as input, IC2 is mapped on TI1
                trc = 0b11, // CC2 channel is configured as input, IC2 is mapped on TRC
            };
            cc1s: Cc1s, // Capture/Compare 1 selection (u2)
            ic1psc: u2, // Input capture 1 prescaler
            ic1f: Ic1f, // Input capture 1 filter (u4)
            cc2s: Cc2s, // Capture/Compare 2 selection (u2)
            ic2psc: u2, // Input capture 2 prescaler
            ic2f: u4, // Input capture 2 filter
            _padding_16_31: u16,
        };
        pub const ccmr1_input = mmio(base_address + 0x18, 32, Ccmr1Input);

        /// address: 0x4000041c
        /// capture/compare mode register 2 (output mode)
        pub const Ccmr2Output = packed struct {
            pub const Cc3s = enum(u2) {
                output = 0b00, // CC3 channel is configured as output
            };
            pub const Oc3pe = enum(u1) {
                disabled = 0, // Preload register on CCR3 disabled. New values written to CCR3 are taken into account immediately
                enabled = 1, // Preload register on CCR3 enabled. Preload value is loaded into active register on each update event
            };
            pub const Oc3m = enum(u3) {
                frozen = 0b000, // The comparison between the output compare register TIMx_CCRy and the counter TIMx_CNT has no effect on the outputs
                active_on_match = 0b001, // Set channel to active level on match. OCyREF signal is forced high when the counter matches the capture/compare register
                inactive_on_match = 0b010, // Set channel to inactive level on match. OCyREF signal is forced low when the counter matches the capture/compare register
                toggle = 0b011, // OCyREF toggles when TIMx_CNT=TIMx_CCRy
                force_inactive = 0b100, // OCyREF is forced low
                force_active = 0b101, // OCyREF is forced high
                pwm_mode1 = 0b110, // In upcounting, channel is active as long as TIMx_CNT<TIMx_CCRy else inactive. In downcounting, channel is inactive as long as TIMx_CNT>TIMx_CCRy else active
                pwm_mode2 = 0b111, // Inversely to PwmMode1
            };
            pub const Cc4s = enum(u2) {
                output = 0b00, // CC4 channel is configured as output
            };
            pub const Oc4pe = enum(u1) {
                disabled = 0, // Preload register on CCR4 disabled. New values written to CCR4 are taken into account immediately
                enabled = 1, // Preload register on CCR4 enabled. Preload value is loaded into active register on each update event
            };
            cc3s: Cc3s, // CC3S (u2)
            oc3fe: u1, // OC3FE
            oc3pe: Oc3pe, // OC3PE (u1)
            oc3m: Oc3m, // OC3M (u3)
            oc3ce: u1, // OC3CE
            cc4s: Cc4s, // CC4S (u2)
            oc4fe: u1, // OC4FE
            oc4pe: Oc4pe, // OC4PE (u1)
            oc4m: Oc3m, // OC4M (u3)
            oc4ce: u1, // O24CE
            _padding_16_31: u16,
        };
        pub const ccmr2_output = mmio(base_address + 0x1c, 32, Ccmr2Output);

        /// address: 0x4000041c
        /// capture/compare mode register 2 (input mode)
        pub const Ccmr2Input = packed struct {
            pub const Cc3s = enum(u2) {
                ti3 = 0b01, // CC3 channel is configured as input, IC3 is mapped on TI3
                ti4 = 0b10, // CC3 channel is configured as input, IC3 is mapped on TI4
                trc = 0b11, // CC3 channel is configured as input, IC3 is mapped on TRC
            };
            pub const Cc4s = enum(u2) {
                ti4 = 0b01, // CC4 channel is configured as input, IC4 is mapped on TI4
                ti3 = 0b10, // CC4 channel is configured as input, IC4 is mapped on TI3
                trc = 0b11, // CC4 channel is configured as input, IC4 is mapped on TRC
            };
            cc3s: Cc3s, // Capture/compare 3 selection (u2)
            ic3psc: u2, // Input capture 3 prescaler
            ic3f: u4, // Input capture 3 filter
            cc4s: Cc4s, // Capture/Compare 4 selection (u2)
            ic4psc: u2, // Input capture 4 prescaler
            ic4f: u4, // Input capture 4 filter
            _padding_16_31: u16,
        };
        pub const ccmr2_input = mmio(base_address + 0x1c, 32, Ccmr2Input);

        /// address: 0x40000420
        /// capture/compare enable register
        pub const Ccer = packed struct {
            cc1e: u1, // Capture/Compare 1 output enable
            cc1p: u1, // Capture/Compare 1 output Polarity
            _reserved_2_2: u1,
            cc1np: u1, // Capture/Compare 1 output Polarity
            cc2e: u1, // Capture/Compare 2 output enable
            cc2p: u1, // Capture/Compare 2 output Polarity
            _reserved_6_6: u1,
            cc2np: u1, // Capture/Compare 2 output Polarity
            cc3e: u1, // Capture/Compare 3 output enable
            cc3p: u1, // Capture/Compare 3 output Polarity
            _reserved_10_10: u1,
            cc3np: u1, // Capture/Compare 3 output Polarity
            cc4e: u1, // Capture/Compare 4 output enable
            cc4p: u1, // Capture/Compare 3 output Polarity
            _reserved_14_14: u1,
            cc4np: u1, // Capture/Compare 4 output Polarity
            _padding_16_31: u16,
        };
        pub const ccer = mmio(base_address + 0x20, 32, Ccer);

        /// address: 0x40000424
        /// counter
        pub const cnt = mmioInt(base_address + 0x24, 32, u16);

        /// address: 0x40000428
        /// prescaler
        pub const psc = mmioInt(base_address + 0x28, 32, u16);

        /// address: 0x4000042c
        /// auto-reload register
        pub const arr = mmioInt(base_address + 0x2c, 32, u16);

        /// address: 0x40000434
        /// capture/compare register
        pub const Ccr1 = packed struct {
            ccr: u16, // Capture/Compare value
            _padding_16_31: u16,
        };
        pub const ccr1 = mmio(base_address + 0x34, 32, Ccr1);

        /// address: 0x40000438
        /// capture/compare register
        pub const Ccr2 = packed struct {
            ccr: u16, // Capture/Compare value
            _padding_16_31: u16,
        };
        pub const ccr2 = mmio(base_address + 0x38, 32, Ccr2);

        /// address: 0x4000043c
        /// capture/compare register
        pub const Ccr3 = packed struct {
            ccr: u16, // Capture/Compare value
            _padding_16_31: u16,
        };
        pub const ccr3 = mmio(base_address + 0x3c, 32, Ccr3);

        /// address: 0x40000440
        /// capture/compare register
        pub const Ccr4 = packed struct {
            ccr: u16, // Capture/Compare value
            _padding_16_31: u16,
        };
        pub const ccr4 = mmio(base_address + 0x40, 32, Ccr4);

        /// address: 0x40000448
        /// DMA control register
        pub const Dcr = packed struct {
            dba: u5, // DMA base address
            _reserved_5_7: u3,
            dbl: u5, // DMA burst length
            _padding_13_31: u19,
        };
        pub const dcr = mmio(base_address + 0x48, 32, Dcr);

        /// address: 0x4000044c
        /// DMA address for full transfer
        pub const Dmar = packed struct {
            dmab: u16, // DMA register for burst accesses
            _padding_16_31: u16,
        };
        pub const dmar = mmio(base_address + 0x4c, 32, Dmar);
    };
    /// General-purpose-timers
    pub const tim5 = struct {
        pub const base_address = 0x40000c00;

        /// address: 0x40000c00
        /// control register 1
        pub const Cr1 = packed struct {
            pub const Cen = enum(u1) {
                disabled = 0, // Counter disabled
                enabled = 1, // Counter enabled
            };
            pub const Udis = enum(u1) {
                enabled = 0, // Update event enabled
                disabled = 1, // Update event disabled
            };
            pub const Urs = enum(u1) {
                any_event = 0, // Any of counter overflow/underflow, setting UG, or update through slave mode, generates an update interrupt or DMA request
                counter_only = 1, // Only counter overflow/underflow generates an update interrupt or DMA request
            };
            pub const Opm = enum(u1) {
                disabled = 0, // Counter is not stopped at update event
                enabled = 1, // Counter stops counting at the next update event (clearing the CEN bit)
            };
            pub const Dir = enum(u1) {
                up = 0, // Counter used as upcounter
                down = 1, // Counter used as downcounter
            };
            pub const Cms = enum(u2) {
                edge_aligned = 0b00, // The counter counts up or down depending on the direction bit
                center_aligned1 = 0b01, // The counter counts up and down alternatively. Output compare interrupt flags are set only when the counter is counting down.
                center_aligned2 = 0b10, // The counter counts up and down alternatively. Output compare interrupt flags are set only when the counter is counting up.
                center_aligned3 = 0b11, // The counter counts up and down alternatively. Output compare interrupt flags are set both when the counter is counting up or down.
            };
            pub const Arpe = enum(u1) {
                disabled = 0, // TIMx_APRR register is not buffered
                enabled = 1, // TIMx_APRR register is buffered
            };
            pub const Ckd = enum(u2) {
                div1 = 0b00, // t_DTS = t_CK_INT
                div2 = 0b01, // t_DTS = 2  t_CK_INT
                div4 = 0b10, // t_DTS = 4  t_CK_INT
            };
            cen: Cen, // Counter enable (u1)
            udis: Udis, // Update disable (u1)
            urs: Urs, // Update request source (u1)
            opm: Opm, // One-pulse mode (u1)
            dir: Dir, // Direction (u1)
            cms: Cms, // Center-aligned mode selection (u2)
            arpe: Arpe, // Auto-reload preload enable (u1)
            ckd: Ckd, // Clock division (u2)
            _padding_10_31: u22,
        };
        pub const cr1 = mmio(base_address + 0x0, 32, Cr1);

        /// address: 0x40000c04
        /// control register 2
        pub const Cr2 = packed struct {
            pub const Ccds = enum(u1) {
                on_compare = 0, // CCx DMA request sent when CCx event occurs
                on_update = 1, // CCx DMA request sent when update event occurs
            };
            pub const Mms = enum(u3) {
                reset = 0b000, // The UG bit from the TIMx_EGR register is used as trigger output
                enable = 0b001, // The counter enable signal, CNT_EN, is used as trigger output
                update = 0b010, // The update event is selected as trigger output
                compare_pulse = 0b011, // The trigger output send a positive pulse when the CC1IF flag it to be set, as soon as a capture or a compare match occurred
                compare_oc1 = 0b100, // OC1REF signal is used as trigger output
                compare_oc2 = 0b101, // OC2REF signal is used as trigger output
                compare_oc3 = 0b110, // OC3REF signal is used as trigger output
                compare_oc4 = 0b111, // OC4REF signal is used as trigger output
            };
            pub const Ti1s = enum(u1) {
                normal = 0, // The TIMx_CH1 pin is connected to TI1 input
                xor = 1, // The TIMx_CH1, CH2, CH3 pins are connected to TI1 input
            };
            _reserved_0_2: u3,
            ccds: Ccds, // Capture/compare DMA selection (u1)
            mms: Mms, // Master mode selection (u3)
            ti1s: Ti1s, // TI1 selection (u1)
            _padding_8_31: u24,
        };
        pub const cr2 = mmio(base_address + 0x4, 32, Cr2);

        /// address: 0x40000c08
        /// slave mode control register
        pub const Smcr = packed struct {
            pub const Sms = enum(u3) {
                disabled = 0b000, // Slave mode disabled - if CEN = 1 then the prescaler is clocked directly by the internal clock.
                encoder_mode_1 = 0b001, // Encoder mode 1 - Counter counts up/down on TI2FP1 edge depending on TI1FP2 level.
                encoder_mode_2 = 0b010, // Encoder mode 2 - Counter counts up/down on TI1FP2 edge depending on TI2FP1 level.
                encoder_mode_3 = 0b011, // Encoder mode 3 - Counter counts up/down on both TI1FP1 and TI2FP2 edges depending on the level of the other input.
                reset_mode = 0b100, // Reset Mode - Rising edge of the selected trigger input (TRGI) reinitializes the counter and generates an update of the registers.
                gated_mode = 0b101, // Gated Mode - The counter clock is enabled when the trigger input (TRGI) is high. The counter stops (but is not reset) as soon as the trigger becomes low. Both start and stop of the counter are controlled.
                trigger_mode = 0b110, // Trigger Mode - The counter starts at a rising edge of the trigger TRGI (but it is not reset). Only the start of the counter is controlled.
                ext_clock_mode = 0b111, // External Clock Mode 1 - Rising edges of the selected trigger (TRGI) clock the counter.
            };
            pub const Ts = enum(u3) {
                itr0 = 0b000, // Internal Trigger 0 (ITR0)
                itr1 = 0b001, // Internal Trigger 1 (ITR1)
                itr2 = 0b010, // Internal Trigger 2 (ITR2)
                ti1_f_ed = 0b100, // TI1 Edge Detector (TI1F_ED)
                ti1_fp1 = 0b101, // Filtered Timer Input 1 (TI1FP1)
                ti2_fp2 = 0b110, // Filtered Timer Input 2 (TI2FP2)
                etrf = 0b111, // External Trigger input (ETRF)
            };
            pub const Msm = enum(u1) {
                no_sync = 0, // No action
                sync = 1, // The effect of an event on the trigger input (TRGI) is delayed to allow a perfect synchronization between the current timer and its slaves (through TRGO). It is useful if we want to synchronize several timers on a single external event.
            };
            pub const Etf = enum(u4) {
                no_filter = 0b0000, // No filter, sampling is done at fDTS
                fck_int_n2 = 0b0001, // fSAMPLING=fCK_INT, N=2
                fck_int_n4 = 0b0010, // fSAMPLING=fCK_INT, N=4
                fck_int_n8 = 0b0011, // fSAMPLING=fCK_INT, N=8
                fdts_div2_n6 = 0b0100, // fSAMPLING=fDTS/2, N=6
                fdts_div2_n8 = 0b0101, // fSAMPLING=fDTS/2, N=8
                fdts_div4_n6 = 0b0110, // fSAMPLING=fDTS/4, N=6
                fdts_div4_n8 = 0b0111, // fSAMPLING=fDTS/4, N=8
                fdts_div8_n6 = 0b1000, // fSAMPLING=fDTS/8, N=6
                fdts_div8_n8 = 0b1001, // fSAMPLING=fDTS/8, N=8
                fdts_div16_n5 = 0b1010, // fSAMPLING=fDTS/16, N=5
                fdts_div16_n6 = 0b1011, // fSAMPLING=fDTS/16, N=6
                fdts_div16_n8 = 0b1100, // fSAMPLING=fDTS/16, N=8
                fdts_div32_n5 = 0b1101, // fSAMPLING=fDTS/32, N=5
                fdts_div32_n6 = 0b1110, // fSAMPLING=fDTS/32, N=6
                fdts_div32_n8 = 0b1111, // fSAMPLING=fDTS/32, N=8
            };
            pub const Etps = enum(u2) {
                div1 = 0b00, // Prescaler OFF
                div2 = 0b01, // ETRP frequency divided by 2
                div4 = 0b10, // ETRP frequency divided by 4
                div8 = 0b11, // ETRP frequency divided by 8
            };
            pub const Ece = enum(u1) {
                disabled = 0, // External clock mode 2 disabled
                enabled = 1, // External clock mode 2 enabled. The counter is clocked by any active edge on the ETRF signal.
            };
            pub const Etp = enum(u1) {
                not_inverted = 0, // ETR is noninverted, active at high level or rising edge
                inverted = 1, // ETR is inverted, active at low level or falling edge
            };
            sms: Sms, // Slave mode selection (u3)
            _reserved_3_3: u1,
            ts: Ts, // Trigger selection (u3)
            msm: Msm, // Master/Slave mode (u1)
            etf: Etf, // External trigger filter (u4)
            etps: Etps, // External trigger prescaler (u2)
            ece: Ece, // External clock enable (u1)
            etp: Etp, // External trigger polarity (u1)
            _padding_16_31: u16,
        };
        pub const smcr = mmio(base_address + 0x8, 32, Smcr);

        /// address: 0x40000c0c
        /// DMA/Interrupt enable register
        pub const Dier = packed struct {
            pub const Uie = enum(u1) {
                disabled = 0, // Update interrupt disabled
                enabled = 1, // Update interrupt enabled
            };
            pub const Cc1ie = enum(u1) {
                disabled = 0, // CCx interrupt disabled
                enabled = 1, // CCx interrupt enabled
            };
            pub const Tie = enum(u1) {
                disabled = 0, // Trigger interrupt disabled
                enabled = 1, // Trigger interrupt enabled
            };
            pub const Ude = enum(u1) {
                disabled = 0, // Update DMA request disabled
                enabled = 1, // Update DMA request enabled
            };
            pub const Cc1de = enum(u1) {
                disabled = 0, // CCx DMA request disabled
                enabled = 1, // CCx DMA request enabled
            };
            pub const Tde = enum(u1) {
                disabled = 0, // Trigger DMA request disabled
                enabled = 1, // Trigger DMA request enabled
            };
            uie: Uie, // Update interrupt enable (u1)
            cc1ie: Cc1ie, // Capture/Compare 1 interrupt enable (u1)
            cc2ie: Cc1ie, // Capture/Compare 2 interrupt enable (u1)
            cc3ie: Cc1ie, // Capture/Compare 3 interrupt enable (u1)
            cc4ie: Cc1ie, // Capture/Compare 4 interrupt enable (u1)
            _reserved_5_5: u1,
            tie: Tie, // Trigger interrupt enable (u1)
            _reserved_7_7: u1,
            ude: Ude, // Update DMA request enable (u1)
            cc1de: Cc1de, // Capture/Compare 1 DMA request enable (u1)
            cc2de: Cc1de, // Capture/Compare 2 DMA request enable (u1)
            cc3de: Cc1de, // Capture/Compare 3 DMA request enable (u1)
            cc4de: Cc1de, // Capture/Compare 4 DMA request enable (u1)
            _reserved_13_13: u1,
            tde: Tde, // Trigger DMA request enable (u1)
            _padding_15_31: u17,
        };
        pub const dier = mmio(base_address + 0xc, 32, Dier);

        /// address: 0x40000c10
        /// status register
        pub const Sr = packed struct {
            pub const Uif = enum(u1) {
                clear = 0, // No update occurred
                update_pending = 1, // Update interrupt pending.
            };
            pub const Cc1if = enum(u1) {
                match = 1, // If CC1 is an output: The content of the counter TIMx_CNT matches the content of the TIMx_CCR1 register. If CC1 is an input: The counter value has been captured in TIMx_CCR1 register.
                clear = 0, // Clear flag
            };
            pub const Tif = enum(u1) {
                no_trigger = 0, // No trigger event occurred
                trigger = 1, // Trigger interrupt pending
                pub const clear = @intToEnum(Tif, 0); // Clear flag
            };
            pub const Cc1of = enum(u1) {
                overcapture = 1, // The counter value has been captured in TIMx_CCRx register while CCxIF flag was already set
                clear = 0, // Clear flag
            };
            uif: Uif, // Update interrupt flag (u1)
            cc1if: Cc1if, // Capture/compare 1 interrupt flag (u1)
            cc2if: Cc1if, // Capture/Compare 2 interrupt flag (u1)
            cc3if: Cc1if, // Capture/Compare 3 interrupt flag (u1)
            cc4if: Cc1if, // Capture/Compare 4 interrupt flag (u1)
            _reserved_5_5: u1,
            tif: Tif, // Trigger interrupt flag (u1)
            _reserved_7_8: u2,
            cc1of: Cc1of, // Capture/Compare 1 overcapture flag (u1)
            cc2of: Cc1of, // Capture/compare 2 overcapture flag (u1)
            cc3of: Cc1of, // Capture/Compare 3 overcapture flag (u1)
            cc4of: Cc1of, // Capture/Compare 4 overcapture flag (u1)
            _padding_13_31: u19,
        };
        pub const sr = mmio(base_address + 0x10, 32, Sr);

        /// address: 0x40000c14
        /// event generation register
        pub const Egr = packed struct {
            pub const Ug = enum(u1) {
                update = 1, // Re-initializes the timer counter and generates an update of the registers.
            };
            pub const Cc1gw = enum(u1) {
                trigger = 1, // If CC1 is an output: CC1IF flag is set, Corresponding interrupt or DMA request is sent if enabled. If CC1 is an input: The current value of the counter is captured in TIMx_CCR1 register.
            };
            pub const Tgw = enum(u1) {
                trigger = 1, // The TIF flag is set in TIMx_SR register. Related interrupt or DMA transfer can occur if enabled.
            };
            ug: Ug, // Update generation (u1)
            cc1g: Cc1gw, // Capture/compare 1 generation (u1)
            cc2g: Cc1gw, // Capture/compare 2 generation (u1)
            cc3g: Cc1gw, // Capture/compare 3 generation (u1)
            cc4g: Cc1gw, // Capture/compare 4 generation (u1)
            _reserved_5_5: u1,
            tg: Tgw, // Trigger generation (u1)
            _padding_7_31: u25,
        };
        pub const egr = mmio(base_address + 0x14, 32, Egr);

        /// address: 0x40000c18
        /// capture/compare mode register 1 (output mode)
        pub const Ccmr1Output = packed struct {
            pub const Cc1s = enum(u2) {
                output = 0b00, // CC1 channel is configured as output
            };
            pub const Oc1pe = enum(u1) {
                disabled = 0, // Preload register on CCR1 disabled. New values written to CCR1 are taken into account immediately
                enabled = 1, // Preload register on CCR1 enabled. Preload value is loaded into active register on each update event
            };
            pub const Oc1m = enum(u3) {
                frozen = 0b000, // The comparison between the output compare register TIMx_CCRy and the counter TIMx_CNT has no effect on the outputs
                active_on_match = 0b001, // Set channel to active level on match. OCyREF signal is forced high when the counter matches the capture/compare register
                inactive_on_match = 0b010, // Set channel to inactive level on match. OCyREF signal is forced low when the counter matches the capture/compare register
                toggle = 0b011, // OCyREF toggles when TIMx_CNT=TIMx_CCRy
                force_inactive = 0b100, // OCyREF is forced low
                force_active = 0b101, // OCyREF is forced high
                pwm_mode1 = 0b110, // In upcounting, channel is active as long as TIMx_CNT<TIMx_CCRy else inactive. In downcounting, channel is inactive as long as TIMx_CNT>TIMx_CCRy else active
                pwm_mode2 = 0b111, // Inversely to PwmMode1
            };
            pub const Cc2s = enum(u2) {
                output = 0b00, // CC2 channel is configured as output
            };
            pub const Oc2pe = enum(u1) {
                disabled = 0, // Preload register on CCR2 disabled. New values written to CCR2 are taken into account immediately
                enabled = 1, // Preload register on CCR2 enabled. Preload value is loaded into active register on each update event
            };
            cc1s: Cc1s, // CC1S (u2)
            oc1fe: u1, // OC1FE
            oc1pe: Oc1pe, // OC1PE (u1)
            oc1m: Oc1m, // OC1M (u3)
            oc1ce: u1, // OC1CE
            cc2s: Cc2s, // CC2S (u2)
            oc2fe: u1, // OC2FE
            oc2pe: Oc2pe, // OC2PE (u1)
            oc2m: Oc1m, // OC2M (u3)
            oc2ce: u1, // OC2CE
            _padding_16_31: u16,
        };
        pub const ccmr1_output = mmio(base_address + 0x18, 32, Ccmr1Output);

        /// address: 0x40000c18
        /// capture/compare mode register 1 (input mode)
        pub const Ccmr1Input = packed struct {
            pub const Cc1s = enum(u2) {
                ti1 = 0b01, // CC1 channel is configured as input, IC1 is mapped on TI1
                ti2 = 0b10, // CC1 channel is configured as input, IC1 is mapped on TI2
                trc = 0b11, // CC1 channel is configured as input, IC1 is mapped on TRC
            };
            pub const Ic1f = enum(u4) {
                no_filter = 0b0000, // No filter, sampling is done at fDTS
                fck_int_n2 = 0b0001, // fSAMPLING=fCK_INT, N=2
                fck_int_n4 = 0b0010, // fSAMPLING=fCK_INT, N=4
                fck_int_n8 = 0b0011, // fSAMPLING=fCK_INT, N=8
                fdts_div2_n6 = 0b0100, // fSAMPLING=fDTS/2, N=6
                fdts_div2_n8 = 0b0101, // fSAMPLING=fDTS/2, N=8
                fdts_div4_n6 = 0b0110, // fSAMPLING=fDTS/4, N=6
                fdts_div4_n8 = 0b0111, // fSAMPLING=fDTS/4, N=8
                fdts_div8_n6 = 0b1000, // fSAMPLING=fDTS/8, N=6
                fdts_div8_n8 = 0b1001, // fSAMPLING=fDTS/8, N=8
                fdts_div16_n5 = 0b1010, // fSAMPLING=fDTS/16, N=5
                fdts_div16_n6 = 0b1011, // fSAMPLING=fDTS/16, N=6
                fdts_div16_n8 = 0b1100, // fSAMPLING=fDTS/16, N=8
                fdts_div32_n5 = 0b1101, // fSAMPLING=fDTS/32, N=5
                fdts_div32_n6 = 0b1110, // fSAMPLING=fDTS/32, N=6
                fdts_div32_n8 = 0b1111, // fSAMPLING=fDTS/32, N=8
            };
            pub const Cc2s = enum(u2) {
                ti2 = 0b01, // CC2 channel is configured as input, IC2 is mapped on TI2
                ti1 = 0b10, // CC2 channel is configured as input, IC2 is mapped on TI1
                trc = 0b11, // CC2 channel is configured as input, IC2 is mapped on TRC
            };
            cc1s: Cc1s, // Capture/Compare 1 selection (u2)
            ic1psc: u2, // Input capture 1 prescaler
            ic1f: Ic1f, // Input capture 1 filter (u4)
            cc2s: Cc2s, // Capture/Compare 2 selection (u2)
            ic2psc: u2, // Input capture 2 prescaler
            ic2f: u4, // Input capture 2 filter
            _padding_16_31: u16,
        };
        pub const ccmr1_input = mmio(base_address + 0x18, 32, Ccmr1Input);

        /// address: 0x40000c1c
        /// capture/compare mode register 2 (output mode)
        pub const Ccmr2Output = packed struct {
            pub const Cc3s = enum(u2) {
                output = 0b00, // CC3 channel is configured as output
            };
            pub const Oc3pe = enum(u1) {
                disabled = 0, // Preload register on CCR3 disabled. New values written to CCR3 are taken into account immediately
                enabled = 1, // Preload register on CCR3 enabled. Preload value is loaded into active register on each update event
            };
            pub const Oc3m = enum(u3) {
                frozen = 0b000, // The comparison between the output compare register TIMx_CCRy and the counter TIMx_CNT has no effect on the outputs
                active_on_match = 0b001, // Set channel to active level on match. OCyREF signal is forced high when the counter matches the capture/compare register
                inactive_on_match = 0b010, // Set channel to inactive level on match. OCyREF signal is forced low when the counter matches the capture/compare register
                toggle = 0b011, // OCyREF toggles when TIMx_CNT=TIMx_CCRy
                force_inactive = 0b100, // OCyREF is forced low
                force_active = 0b101, // OCyREF is forced high
                pwm_mode1 = 0b110, // In upcounting, channel is active as long as TIMx_CNT<TIMx_CCRy else inactive. In downcounting, channel is inactive as long as TIMx_CNT>TIMx_CCRy else active
                pwm_mode2 = 0b111, // Inversely to PwmMode1
            };
            pub const Cc4s = enum(u2) {
                output = 0b00, // CC4 channel is configured as output
            };
            pub const Oc4pe = enum(u1) {
                disabled = 0, // Preload register on CCR4 disabled. New values written to CCR4 are taken into account immediately
                enabled = 1, // Preload register on CCR4 enabled. Preload value is loaded into active register on each update event
            };
            cc3s: Cc3s, // CC3S (u2)
            oc3fe: u1, // OC3FE
            oc3pe: Oc3pe, // OC3PE (u1)
            oc3m: Oc3m, // OC3M (u3)
            oc3ce: u1, // OC3CE
            cc4s: Cc4s, // CC4S (u2)
            oc4fe: u1, // OC4FE
            oc4pe: Oc4pe, // OC4PE (u1)
            oc4m: Oc3m, // OC4M (u3)
            oc4ce: u1, // O24CE
            _padding_16_31: u16,
        };
        pub const ccmr2_output = mmio(base_address + 0x1c, 32, Ccmr2Output);

        /// address: 0x40000c1c
        /// capture/compare mode register 2 (input mode)
        pub const Ccmr2Input = packed struct {
            pub const Cc3s = enum(u2) {
                ti3 = 0b01, // CC3 channel is configured as input, IC3 is mapped on TI3
                ti4 = 0b10, // CC3 channel is configured as input, IC3 is mapped on TI4
                trc = 0b11, // CC3 channel is configured as input, IC3 is mapped on TRC
            };
            pub const Cc4s = enum(u2) {
                ti4 = 0b01, // CC4 channel is configured as input, IC4 is mapped on TI4
                ti3 = 0b10, // CC4 channel is configured as input, IC4 is mapped on TI3
                trc = 0b11, // CC4 channel is configured as input, IC4 is mapped on TRC
            };
            cc3s: Cc3s, // Capture/compare 3 selection (u2)
            ic3psc: u2, // Input capture 3 prescaler
            ic3f: u4, // Input capture 3 filter
            cc4s: Cc4s, // Capture/Compare 4 selection (u2)
            ic4psc: u2, // Input capture 4 prescaler
            ic4f: u4, // Input capture 4 filter
            _padding_16_31: u16,
        };
        pub const ccmr2_input = mmio(base_address + 0x1c, 32, Ccmr2Input);

        /// address: 0x40000c20
        /// capture/compare enable register
        pub const Ccer = packed struct {
            cc1e: u1, // Capture/Compare 1 output enable
            cc1p: u1, // Capture/Compare 1 output Polarity
            _reserved_2_2: u1,
            cc1np: u1, // Capture/Compare 1 output Polarity
            cc2e: u1, // Capture/Compare 2 output enable
            cc2p: u1, // Capture/Compare 2 output Polarity
            _reserved_6_6: u1,
            cc2np: u1, // Capture/Compare 2 output Polarity
            cc3e: u1, // Capture/Compare 3 output enable
            cc3p: u1, // Capture/Compare 3 output Polarity
            _reserved_10_10: u1,
            cc3np: u1, // Capture/Compare 3 output Polarity
            cc4e: u1, // Capture/Compare 4 output enable
            cc4p: u1, // Capture/Compare 3 output Polarity
            _reserved_14_14: u1,
            cc4np: u1, // Capture/Compare 4 output Polarity
            _padding_16_31: u16,
        };
        pub const ccer = mmio(base_address + 0x20, 32, Ccer);

        /// address: 0x40000c24
        /// counter
        pub const cnt = @intToPtr(*volatile u32, base_address + 0x24);

        /// address: 0x40000c28
        /// prescaler
        pub const psc = mmioInt(base_address + 0x28, 32, u16);

        /// address: 0x40000c2c
        /// auto-reload register
        pub const arr = @intToPtr(*volatile u32, base_address + 0x2c);

        /// address: 0x40000c34
        /// capture/compare register
        pub const Ccr1 = packed struct {
            ccr: u32, // Capture/Compare value
        };
        pub const ccr1 = mmio(base_address + 0x34, 32, Ccr1);

        /// address: 0x40000c38
        /// capture/compare register
        pub const Ccr2 = packed struct {
            ccr: u32, // Capture/Compare value
        };
        pub const ccr2 = mmio(base_address + 0x38, 32, Ccr2);

        /// address: 0x40000c3c
        /// capture/compare register
        pub const Ccr3 = packed struct {
            ccr: u32, // Capture/Compare value
        };
        pub const ccr3 = mmio(base_address + 0x3c, 32, Ccr3);

        /// address: 0x40000c40
        /// capture/compare register
        pub const Ccr4 = packed struct {
            ccr: u32, // Capture/Compare value
        };
        pub const ccr4 = mmio(base_address + 0x40, 32, Ccr4);

        /// address: 0x40000c48
        /// DMA control register
        pub const Dcr = packed struct {
            dba: u5, // DMA base address
            _reserved_5_7: u3,
            dbl: u5, // DMA burst length
            _padding_13_31: u19,
        };
        pub const dcr = mmio(base_address + 0x48, 32, Dcr);

        /// address: 0x40000c4c
        /// DMA address for full transfer
        pub const Dmar = packed struct {
            dmab: u16, // DMA register for burst accesses
            _padding_16_31: u16,
        };
        pub const dmar = mmio(base_address + 0x4c, 32, Dmar);

        /// address: 0x40000c50
        /// TIM5 option register
        pub const Or = packed struct {
            _reserved_0_5: u6,
            it4_rmp: u2, // Timer Input 4 remap
            _padding_8_31: u24,
        };
        pub const @"or" = mmio(base_address + 0x50, 32, Or);
    };
    /// General purpose timers
    pub const tim9 = struct {
        pub const base_address = 0x40014000;

        /// address: 0x40014000
        /// control register 1
        pub const Cr1 = packed struct {
            pub const Cen = enum(u1) {
                disabled = 0, // Counter disabled
                enabled = 1, // Counter enabled
            };
            pub const Udis = enum(u1) {
                enabled = 0, // Update event enabled
                disabled = 1, // Update event disabled
            };
            pub const Urs = enum(u1) {
                any_event = 0, // Any of counter overflow/underflow, setting UG, or update through slave mode, generates an update interrupt or DMA request
                counter_only = 1, // Only counter overflow/underflow generates an update interrupt or DMA request
            };
            pub const Opm = enum(u1) {
                disabled = 0, // Counter is not stopped at update event
                enabled = 1, // Counter stops counting at the next update event (clearing the CEN bit)
            };
            pub const Arpe = enum(u1) {
                disabled = 0, // TIMx_APRR register is not buffered
                enabled = 1, // TIMx_APRR register is buffered
            };
            pub const Ckd = enum(u2) {
                div1 = 0b00, // t_DTS = t_CK_INT
                div2 = 0b01, // t_DTS = 2  t_CK_INT
                div4 = 0b10, // t_DTS = 4  t_CK_INT
            };
            cen: Cen, // Counter enable (u1)
            udis: Udis, // Update disable (u1)
            urs: Urs, // Update request source (u1)
            opm: Opm, // One-pulse mode (u1)
            _reserved_4_6: u3,
            arpe: Arpe, // Auto-reload preload enable (u1)
            ckd: Ckd, // Clock division (u2)
            _padding_10_31: u22,
        };
        pub const cr1 = mmio(base_address + 0x0, 32, Cr1);

        /// address: 0x40014004
        /// control register 2
        pub const Cr2 = packed struct {
            _reserved_0_3: u4,
            mms: u3, // Master mode selection
            _padding_7_31: u25,
        };
        pub const cr2 = mmio(base_address + 0x4, 32, Cr2);

        /// address: 0x40014008
        /// slave mode control register
        pub const Smcr = packed struct {
            sms: u3, // Slave mode selection
            _reserved_3_3: u1,
            ts: u3, // Trigger selection
            msm: u1, // Master/Slave mode
            _padding_8_31: u24,
        };
        pub const smcr = mmio(base_address + 0x8, 32, Smcr);

        /// address: 0x4001400c
        /// DMA/Interrupt enable register
        pub const Dier = packed struct {
            pub const Uie = enum(u1) {
                disabled = 0, // Update interrupt disabled
                enabled = 1, // Update interrupt enabled
            };
            uie: Uie, // Update interrupt enable (u1)
            cc1ie: u1, // Capture/Compare 1 interrupt enable
            cc2ie: u1, // Capture/Compare 2 interrupt enable
            _reserved_3_5: u3,
            tie: u1, // Trigger interrupt enable
            _padding_7_31: u25,
        };
        pub const dier = mmio(base_address + 0xc, 32, Dier);

        /// address: 0x40014010
        /// status register
        pub const Sr = packed struct {
            pub const Uif = enum(u1) {
                clear = 0, // No update occurred
                update_pending = 1, // Update interrupt pending.
            };
            uif: Uif, // Update interrupt flag (u1)
            cc1if: u1, // Capture/compare 1 interrupt flag
            cc2if: u1, // Capture/Compare 2 interrupt flag
            _reserved_3_5: u3,
            tif: u1, // Trigger interrupt flag
            _reserved_7_8: u2,
            cc1of: u1, // Capture/Compare 1 overcapture flag
            cc2of: u1, // Capture/compare 2 overcapture flag
            _padding_11_31: u21,
        };
        pub const sr = mmio(base_address + 0x10, 32, Sr);

        /// address: 0x40014014
        /// event generation register
        pub const Egr = packed struct {
            pub const Ug = enum(u1) {
                update = 1, // Re-initializes the timer counter and generates an update of the registers.
            };
            ug: Ug, // Update generation (u1)
            cc1g: u1, // Capture/compare 1 generation
            cc2g: u1, // Capture/compare 2 generation
            _reserved_3_5: u3,
            tg: u1, // Trigger generation
            _padding_7_31: u25,
        };
        pub const egr = mmio(base_address + 0x14, 32, Egr);

        /// address: 0x40014018
        /// capture/compare mode register 1 (output mode)
        pub const Ccmr1Output = packed struct {
            pub const Oc1m = enum(u3) {
                frozen = 0b000, // The comparison between the output compare register TIMx_CCRy and the counter TIMx_CNT has no effect on the outputs
                active_on_match = 0b001, // Set channel to active level on match. OCyREF signal is forced high when the counter matches the capture/compare register
                inactive_on_match = 0b010, // Set channel to inactive level on match. OCyREF signal is forced low when the counter matches the capture/compare register
                toggle = 0b011, // OCyREF toggles when TIMx_CNT=TIMx_CCRy
                force_inactive = 0b100, // OCyREF is forced low
                force_active = 0b101, // OCyREF is forced high
                pwm_mode1 = 0b110, // In upcounting, channel is active as long as TIMx_CNT<TIMx_CCRy else inactive. In downcounting, channel is inactive as long as TIMx_CNT>TIMx_CCRy else active
                pwm_mode2 = 0b111, // Inversely to PwmMode1
            };
            cc1s: u2, // Capture/Compare 1 selection
            oc1fe: u1, // Output Compare 1 fast enable
            oc1pe: u1, // Output Compare 1 preload enable
            oc1m: Oc1m, // Output Compare 1 mode (u3)
            _reserved_7_7: u1,
            cc2s: u2, // Capture/Compare 2 selection
            oc2fe: u1, // Output Compare 2 fast enable
            oc2pe: u1, // Output Compare 2 preload enable
            oc2m: Oc1m, // Output Compare 2 mode (u3)
            _padding_15_31: u17,
        };
        pub const ccmr1_output = mmio(base_address + 0x18, 32, Ccmr1Output);

        /// address: 0x40014018
        /// capture/compare mode register 1 (input mode)
        pub const Ccmr1Input = packed struct {
            cc1s: u2, // Capture/Compare 1 selection
            ic1psc: u2, // Input capture 1 prescaler
            ic1f: u3, // Input capture 1 filter
            _reserved_7_7: u1,
            cc2s: u2, // Capture/Compare 2 selection
            ic2psc: u2, // Input capture 2 prescaler
            ic2f: u3, // Input capture 2 filter
            _padding_15_31: u17,
        };
        pub const ccmr1_input = mmio(base_address + 0x18, 32, Ccmr1Input);

        /// address: 0x40014020
        /// capture/compare enable register
        pub const Ccer = packed struct {
            cc1e: u1, // Capture/Compare 1 output enable
            cc1p: u1, // Capture/Compare 1 output Polarity
            _reserved_2_2: u1,
            cc1np: u1, // Capture/Compare 1 output Polarity
            cc2e: u1, // Capture/Compare 2 output enable
            cc2p: u1, // Capture/Compare 2 output Polarity
            _reserved_6_6: u1,
            cc2np: u1, // Capture/Compare 2 output Polarity
            _padding_8_31: u24,
        };
        pub const ccer = mmio(base_address + 0x20, 32, Ccer);

        /// address: 0x40014024
        /// counter
        pub const cnt = mmioInt(base_address + 0x24, 32, u16);

        /// address: 0x40014028
        /// prescaler
        pub const psc = mmioInt(base_address + 0x28, 32, u16);

        /// address: 0x4001402c
        /// auto-reload register
        pub const arr = mmioInt(base_address + 0x2c, 32, u16);

        /// address: 0x40014034
        /// capture/compare register
        pub const Ccr1 = packed struct {
            ccr: u16, // Capture/Compare value
            _padding_16_31: u16,
        };
        pub const ccr1 = mmio(base_address + 0x34, 32, Ccr1);

        /// address: 0x40014038
        /// capture/compare register
        pub const Ccr2 = packed struct {
            ccr: u16, // Capture/Compare value
            _padding_16_31: u16,
        };
        pub const ccr2 = mmio(base_address + 0x38, 32, Ccr2);
    };
    /// Universal synchronous asynchronous receiver transmitter
    pub const usart1 = struct {
        pub const base_address = 0x40011000;

        /// address: 0x40011000
        /// Status register
        pub const Sr = packed struct {
            pe: u1, // Parity error
            fe: u1, // Framing error
            nf: u1, // Noise detected flag
            ore: u1, // Overrun error
            idle: u1, // IDLE line detected
            rxne: u1, // Read data register not empty
            tc: u1, // Transmission complete
            txe: u1, // Transmit data register empty
            lbd: u1, // LIN break detection flag
            cts: u1, // CTS flag
            _padding_10_31: u22,
        };
        pub const sr = mmio(base_address + 0x0, 32, Sr);

        /// address: 0x40011004
        /// Data register
        pub const dr = mmioInt(base_address + 0x4, 32, u9);

        /// address: 0x40011008
        /// Baud rate register
        pub const Brr = packed struct {
            div_fraction: u4, // fraction of USARTDIV
            div_mantissa: u12, // mantissa of USARTDIV
            _padding_16_31: u16,
        };
        pub const brr = mmio(base_address + 0x8, 32, Brr);

        /// address: 0x4001100c
        /// Control register 1
        pub const Cr1 = packed struct {
            pub const Sbk = enum(u1) {
                no_break = 0, // No break character is transmitted
                @"break" = 1, // Break character transmitted
            };
            pub const Rwu = enum(u1) {
                active = 0, // Receiver in active mode
                mute = 1, // Receiver in mute mode
            };
            pub const Re = enum(u1) {
                disabled = 0, // Receiver disabled
                enabled = 1, // Receiver enabled
            };
            pub const Te = enum(u1) {
                disabled = 0, // Transmitter disabled
                enabled = 1, // Transmitter enabled
            };
            pub const Idleie = enum(u1) {
                disabled = 0, // IDLE interrupt disabled
                enabled = 1, // IDLE interrupt enabled
            };
            pub const Rxneie = enum(u1) {
                disabled = 0, // RXNE interrupt disabled
                enabled = 1, // RXNE interrupt enabled
            };
            pub const Tcie = enum(u1) {
                disabled = 0, // TC interrupt disabled
                enabled = 1, // TC interrupt enabled
            };
            pub const Txeie = enum(u1) {
                disabled = 0, // TXE interrupt disabled
                enabled = 1, // TXE interrupt enabled
            };
            pub const Peie = enum(u1) {
                disabled = 0, // PE interrupt disabled
                enabled = 1, // PE interrupt enabled
            };
            pub const Ps = enum(u1) {
                even = 0, // Even parity
                odd = 1, // Odd parity
            };
            pub const Pce = enum(u1) {
                disabled = 0, // Parity control disabled
                enabled = 1, // Parity control enabled
            };
            pub const Wake = enum(u1) {
                idle_line = 0, // USART wakeup on idle line
                address_mark = 1, // USART wakeup on address mark
            };
            pub const M = enum(u1) {
                m8 = 0, // 8 data bits
                m9 = 1, // 9 data bits
            };
            pub const Ue = enum(u1) {
                disabled = 0, // USART prescaler and outputs disabled
                enabled = 1, // USART enabled
            };
            pub const Over8 = enum(u1) {
                oversample16 = 0, // Oversampling by 16
                oversample8 = 1, // Oversampling by 8
            };
            sbk: Sbk, // Send break (u1)
            rwu: Rwu, // Receiver wakeup (u1)
            re: Re, // Receiver enable (u1)
            te: Te, // Transmitter enable (u1)
            idleie: Idleie, // IDLE interrupt enable (u1)
            rxneie: Rxneie, // RXNE interrupt enable (u1)
            tcie: Tcie, // Transmission complete interrupt enable (u1)
            txeie: Txeie, // TXE interrupt enable (u1)
            peie: Peie, // PE interrupt enable (u1)
            ps: Ps, // Parity selection (u1)
            pce: Pce, // Parity control enable (u1)
            wake: Wake, // Wakeup method (u1)
            m: M, // Word length (u1)
            ue: Ue, // USART enable (u1)
            _reserved_14_14: u1,
            over8: Over8, // Oversampling mode (u1)
            _padding_16_31: u16,
        };
        pub const cr1 = mmio(base_address + 0xc, 32, Cr1);

        /// address: 0x40011010
        /// Control register 2
        pub const Cr2 = packed struct {
            pub const Lbdl = enum(u1) {
                lbdl10 = 0, // 10-bit break detection
                lbdl11 = 1, // 11-bit break detection
            };
            pub const Lbdie = enum(u1) {
                disabled = 0, // LIN break detection interrupt disabled
                enabled = 1, // LIN break detection interrupt enabled
            };
            pub const Cpha = enum(u1) {
                first = 0, // The first clock transition is the first data capture edge
                second = 1, // The second clock transition is the first data capture edge
            };
            pub const Cpol = enum(u1) {
                low = 0, // Steady low value on CK pin outside transmission window
                high = 1, // Steady high value on CK pin outside transmission window
            };
            pub const Clken = enum(u1) {
                disabled = 0, // CK pin disabled
                enabled = 1, // CK pin enabled
            };
            pub const Stop = enum(u2) {
                stop1 = 0b00, // 1 stop bit
                stop0p5 = 0b01, // 0.5 stop bits
                stop2 = 0b10, // 2 stop bits
                stop1p5 = 0b11, // 1.5 stop bits
            };
            pub const Linen = enum(u1) {
                disabled = 0, // LIN mode disabled
                enabled = 1, // LIN mode enabled
            };
            add: u4, // Address of the USART node
            _reserved_4_4: u1,
            lbdl: Lbdl, // lin break detection length (u1)
            lbdie: Lbdie, // LIN break detection interrupt enable (u1)
            _reserved_7_7: u1,
            lbcl: u1, // Last bit clock pulse
            cpha: Cpha, // Clock phase (u1)
            cpol: Cpol, // Clock polarity (u1)
            clken: Clken, // Clock enable (u1)
            stop: Stop, // STOP bits (u2)
            linen: Linen, // LIN mode enable (u1)
            _padding_15_31: u17,
        };
        pub const cr2 = mmio(base_address + 0x10, 32, Cr2);

        /// address: 0x40011014
        /// Control register 3
        pub const Cr3 = packed struct {
            pub const Eie = enum(u1) {
                disabled = 0, // Error interrupt disabled
                enabled = 1, // Error interrupt enabled
            };
            pub const Iren = enum(u1) {
                disabled = 0, // IrDA disabled
                enabled = 1, // IrDA enabled
            };
            pub const Irlp = enum(u1) {
                normal = 0, // Normal mode
                low_power = 1, // Low-power mode
            };
            pub const Hdsel = enum(u1) {
                full_duplex = 0, // Half duplex mode is not selected
                half_duplex = 1, // Half duplex mode is selected
            };
            pub const Nack = enum(u1) {
                disabled = 0, // NACK transmission in case of parity error is disabled
                enabled = 1, // NACK transmission during parity error is enabled
            };
            pub const Scen = enum(u1) {
                disabled = 0, // Smartcard mode disabled
                enabled = 1, // Smartcard mode enabled
            };
            pub const Dmar = enum(u1) {
                disabled = 0, // DMA mode is disabled for reception
                enabled = 1, // DMA mode is enabled for reception
            };
            pub const Dmat = enum(u1) {
                disabled = 0, // DMA mode is disabled for transmission
                enabled = 1, // DMA mode is enabled for transmission
            };
            pub const Rtse = enum(u1) {
                disabled = 0, // RTS hardware flow control disabled
                enabled = 1, // RTS hardware flow control enabled
            };
            pub const Ctse = enum(u1) {
                disabled = 0, // CTS hardware flow control disabled
                enabled = 1, // CTS hardware flow control enabled
            };
            pub const Ctsie = enum(u1) {
                disabled = 0, // CTS interrupt disabled
                enabled = 1, // CTS interrupt enabled
            };
            pub const Onebit = enum(u1) {
                sample3 = 0, // Three sample bit method
                sample1 = 1, // One sample bit method
            };
            eie: Eie, // Error interrupt enable (u1)
            iren: Iren, // IrDA mode enable (u1)
            irlp: Irlp, // IrDA low-power (u1)
            hdsel: Hdsel, // Half-duplex selection (u1)
            nack: Nack, // Smartcard NACK enable (u1)
            scen: Scen, // Smartcard mode enable (u1)
            dmar: Dmar, // DMA enable receiver (u1)
            dmat: Dmat, // DMA enable transmitter (u1)
            rtse: Rtse, // RTS enable (u1)
            ctse: Ctse, // CTS enable (u1)
            ctsie: Ctsie, // CTS interrupt enable (u1)
            onebit: Onebit, // One sample bit method enable (u1)
            _padding_12_31: u20,
        };
        pub const cr3 = mmio(base_address + 0x14, 32, Cr3);

        /// address: 0x40011018
        /// Guard time and prescaler register
        pub const Gtpr = packed struct {
            psc: u8, // Prescaler value
            gt: u8, // Guard time value
            _padding_16_31: u16,
        };
        pub const gtpr = mmio(base_address + 0x18, 32, Gtpr);
    };
    /// Window watchdog
    pub const wwdg = struct {
        pub const base_address = 0x40002c00;

        /// address: 0x40002c00
        /// Control register
        pub const Cr = packed struct {
            pub const Wdga = enum(u1) {
                disabled = 0, // Watchdog disabled
                enabled = 1, // Watchdog enabled
            };
            t: u7, // 7-bit counter (MSB to LSB)
            wdga: Wdga, // Activation bit (u1)
            _padding_8_31: u24,
        };
        pub const cr = mmio(base_address + 0x0, 32, Cr);

        /// address: 0x40002c04
        /// Configuration register
        pub const Cfr = packed struct {
            pub const Wdgtb = enum(u2) {
                div1 = 0b00, // Counter clock (PCLK1 div 4096) div 1
                div2 = 0b01, // Counter clock (PCLK1 div 4096) div 2
                div4 = 0b10, // Counter clock (PCLK1 div 4096) div 4
                div8 = 0b11, // Counter clock (PCLK1 div 4096) div 8
            };
            pub const Ewiw = enum(u1) {
                enable = 1, // interrupt occurs whenever the counter reaches the value 0x40
            };
            w: u7, // 7-bit window value
            wdgtb: Wdgtb, // Timer base (u2)
            ewi: Ewiw, // Early wakeup interrupt (u1)
            _padding_10_31: u22,
        };
        pub const cfr = mmio(base_address + 0x4, 32, Cfr);

        /// address: 0x40002c08
        /// Status register
        pub const Sr = packed struct {
            pub const Ewif = enum(u1) {
                pending = 1, // The EWI Interrupt Service Routine has been triggered
                finished = 0, // The EWI Interrupt Service Routine has been serviced
                pub const finished = @intToEnum(Ewif, 0); // The EWI Interrupt Service Routine has been serviced
            };
            ewif: Ewif, // Early wakeup interrupt flag (u1)
            _padding_1_31: u31,
        };
        pub const sr = mmio(base_address + 0x8, 32, Sr);
    };
    /// DMA controller
    pub const dma1 = struct {
        pub const base_address = 0x40026000;

        /// address: 0x40026000
        /// low interrupt status register
        pub const Lisr = packed struct {
            pub const Feif0 = enum(u1) {
                no_error = 0, // No FIFO error event on stream x
                @"error" = 1, // A FIFO error event occurred on stream x
            };
            pub const Dmeif0 = enum(u1) {
                no_error = 0, // No Direct Mode error on stream x
                @"error" = 1, // A Direct Mode error occurred on stream x
            };
            pub const Teif0 = enum(u1) {
                no_error = 0, // No transfer error on stream x
                @"error" = 1, // A transfer error occurred on stream x
            };
            pub const Htif0 = enum(u1) {
                not_half = 0, // No half transfer event on stream x
                half = 1, // A half transfer event occurred on stream x
            };
            pub const Tcif0 = enum(u1) {
                not_complete = 0, // No transfer complete event on stream x
                complete = 1, // A transfer complete event occurred on stream x
            };
            feif0: Feif0, // Stream x FIFO error interrupt flag (x=3..0) (u1)
            _reserved_1_1: u1,
            dmeif0: Dmeif0, // Stream x direct mode error interrupt flag (x=3..0) (u1)
            teif0: Teif0, // Stream x transfer error interrupt flag (x=3..0) (u1)
            htif0: Htif0, // Stream x half transfer interrupt flag (x=3..0) (u1)
            tcif0: Tcif0, // Stream x transfer complete interrupt flag (x = 3..0) (u1)
            feif1: Feif0, // Stream x FIFO error interrupt flag (x=3..0) (u1)
            _reserved_7_7: u1,
            dmeif1: Dmeif0, // Stream x direct mode error interrupt flag (x=3..0) (u1)
            teif1: Teif0, // Stream x transfer error interrupt flag (x=3..0) (u1)
            htif1: Htif0, // Stream x half transfer interrupt flag (x=3..0) (u1)
            tcif1: Tcif0, // Stream x transfer complete interrupt flag (x = 3..0) (u1)
            _reserved_12_15: u4,
            feif2: Feif0, // Stream x FIFO error interrupt flag (x=3..0) (u1)
            _reserved_17_17: u1,
            dmeif2: Dmeif0, // Stream x direct mode error interrupt flag (x=3..0) (u1)
            teif2: Teif0, // Stream x transfer error interrupt flag (x=3..0) (u1)
            htif2: Htif0, // Stream x half transfer interrupt flag (x=3..0) (u1)
            tcif2: Tcif0, // Stream x transfer complete interrupt flag (x = 3..0) (u1)
            feif3: Feif0, // Stream x FIFO error interrupt flag (x=3..0) (u1)
            _reserved_23_23: u1,
            dmeif3: Dmeif0, // Stream x direct mode error interrupt flag (x=3..0) (u1)
            teif3: Teif0, // Stream x transfer error interrupt flag (x=3..0) (u1)
            htif3: Htif0, // Stream x half transfer interrupt flag (x=3..0) (u1)
            tcif3: Tcif0, // Stream x transfer complete interrupt flag (x = 3..0) (u1)
            _padding_28_31: u4,
        };
        pub const lisr = mmio(base_address + 0x0, 32, Lisr);

        /// address: 0x40026004
        /// high interrupt status register
        pub const Hisr = packed struct {
            pub const Feif4 = enum(u1) {
                no_error = 0, // No FIFO error event on stream x
                @"error" = 1, // A FIFO error event occurred on stream x
            };
            pub const Dmeif4 = enum(u1) {
                no_error = 0, // No Direct Mode error on stream x
                @"error" = 1, // A Direct Mode error occurred on stream x
            };
            pub const Teif4 = enum(u1) {
                no_error = 0, // No transfer error on stream x
                @"error" = 1, // A transfer error occurred on stream x
            };
            pub const Htif4 = enum(u1) {
                not_half = 0, // No half transfer event on stream x
                half = 1, // A half transfer event occurred on stream x
            };
            pub const Tcif4 = enum(u1) {
                not_complete = 0, // No transfer complete event on stream x
                complete = 1, // A transfer complete event occurred on stream x
            };
            feif4: Feif4, // Stream x FIFO error interrupt flag (x=7..4) (u1)
            _reserved_1_1: u1,
            dmeif4: Dmeif4, // Stream x direct mode error interrupt flag (x=7..4) (u1)
            teif4: Teif4, // Stream x transfer error interrupt flag (x=7..4) (u1)
            htif4: Htif4, // Stream x half transfer interrupt flag (x=7..4) (u1)
            tcif4: Tcif4, // Stream x transfer complete interrupt flag (x=7..4) (u1)
            feif5: Feif4, // Stream x FIFO error interrupt flag (x=7..4) (u1)
            _reserved_7_7: u1,
            dmeif5: Dmeif4, // Stream x direct mode error interrupt flag (x=7..4) (u1)
            teif5: Teif4, // Stream x transfer error interrupt flag (x=7..4) (u1)
            htif5: Htif4, // Stream x half transfer interrupt flag (x=7..4) (u1)
            tcif5: Tcif4, // Stream x transfer complete interrupt flag (x=7..4) (u1)
            _reserved_12_15: u4,
            feif6: Feif4, // Stream x FIFO error interrupt flag (x=7..4) (u1)
            _reserved_17_17: u1,
            dmeif6: Dmeif4, // Stream x direct mode error interrupt flag (x=7..4) (u1)
            teif6: Teif4, // Stream x transfer error interrupt flag (x=7..4) (u1)
            htif6: Htif4, // Stream x half transfer interrupt flag (x=7..4) (u1)
            tcif6: Tcif4, // Stream x transfer complete interrupt flag (x=7..4) (u1)
            feif7: Feif4, // Stream x FIFO error interrupt flag (x=7..4) (u1)
            _reserved_23_23: u1,
            dmeif7: Dmeif4, // Stream x direct mode error interrupt flag (x=7..4) (u1)
            teif7: Teif4, // Stream x transfer error interrupt flag (x=7..4) (u1)
            htif7: Htif4, // Stream x half transfer interrupt flag (x=7..4) (u1)
            tcif7: Tcif4, // Stream x transfer complete interrupt flag (x=7..4) (u1)
            _padding_28_31: u4,
        };
        pub const hisr = mmio(base_address + 0x4, 32, Hisr);

        /// address: 0x40026008
        /// low interrupt flag clear register
        pub const Lifcr = packed struct {
            pub const Cfeif0 = enum(u1) {
                clear = 1, // Clear the corresponding CFEIFx flag
            };
            pub const Cdmeif0 = enum(u1) {
                clear = 1, // Clear the corresponding DMEIFx flag
            };
            pub const Cteif0 = enum(u1) {
                clear = 1, // Clear the corresponding TEIFx flag
            };
            pub const Chtif0 = enum(u1) {
                clear = 1, // Clear the corresponding HTIFx flag
            };
            pub const Ctcif0 = enum(u1) {
                clear = 1, // Clear the corresponding TCIFx flag
            };
            cfeif0: Cfeif0, // Stream x clear FIFO error interrupt flag (x = 3..0) (u1)
            _reserved_1_1: u1,
            cdmeif0: Cdmeif0, // Stream x clear direct mode error interrupt flag (x = 3..0) (u1)
            cteif0: Cteif0, // Stream x clear transfer error interrupt flag (x = 3..0) (u1)
            chtif0: Chtif0, // Stream x clear half transfer interrupt flag (x = 3..0) (u1)
            ctcif0: Ctcif0, // Stream x clear transfer complete interrupt flag (x = 3..0) (u1)
            cfeif1: Cfeif0, // Stream x clear FIFO error interrupt flag (x = 3..0) (u1)
            _reserved_7_7: u1,
            cdmeif1: Cdmeif0, // Stream x clear direct mode error interrupt flag (x = 3..0) (u1)
            cteif1: Cteif0, // Stream x clear transfer error interrupt flag (x = 3..0) (u1)
            chtif1: Chtif0, // Stream x clear half transfer interrupt flag (x = 3..0) (u1)
            ctcif1: Ctcif0, // Stream x clear transfer complete interrupt flag (x = 3..0) (u1)
            _reserved_12_15: u4,
            cfeif2: Cfeif0, // Stream x clear FIFO error interrupt flag (x = 3..0) (u1)
            _reserved_17_17: u1,
            cdmeif2: Cdmeif0, // Stream x clear direct mode error interrupt flag (x = 3..0) (u1)
            cteif2: Cteif0, // Stream x clear transfer error interrupt flag (x = 3..0) (u1)
            chtif2: Chtif0, // Stream x clear half transfer interrupt flag (x = 3..0) (u1)
            ctcif2: Ctcif0, // Stream x clear transfer complete interrupt flag (x = 3..0) (u1)
            cfeif3: Cfeif0, // Stream x clear FIFO error interrupt flag (x = 3..0) (u1)
            _reserved_23_23: u1,
            cdmeif3: Cdmeif0, // Stream x clear direct mode error interrupt flag (x = 3..0) (u1)
            cteif3: Cteif0, // Stream x clear transfer error interrupt flag (x = 3..0) (u1)
            chtif3: Chtif0, // Stream x clear half transfer interrupt flag (x = 3..0) (u1)
            ctcif3: Ctcif0, // Stream x clear transfer complete interrupt flag (x = 3..0) (u1)
            _padding_28_31: u4,
        };
        pub const lifcr = mmio(base_address + 0x8, 32, Lifcr);

        /// address: 0x4002600c
        /// high interrupt flag clear register
        pub const Hifcr = packed struct {
            pub const Cfeif4 = enum(u1) {
                clear = 1, // Clear the corresponding CFEIFx flag
            };
            pub const Cdmeif4 = enum(u1) {
                clear = 1, // Clear the corresponding DMEIFx flag
            };
            pub const Cteif4 = enum(u1) {
                clear = 1, // Clear the corresponding TEIFx flag
            };
            pub const Chtif4 = enum(u1) {
                clear = 1, // Clear the corresponding HTIFx flag
            };
            pub const Ctcif4 = enum(u1) {
                clear = 1, // Clear the corresponding TCIFx flag
            };
            cfeif4: Cfeif4, // Stream x clear FIFO error interrupt flag (x = 7..4) (u1)
            _reserved_1_1: u1,
            cdmeif4: Cdmeif4, // Stream x clear direct mode error interrupt flag (x = 7..4) (u1)
            cteif4: Cteif4, // Stream x clear transfer error interrupt flag (x = 7..4) (u1)
            chtif4: Chtif4, // Stream x clear half transfer interrupt flag (x = 7..4) (u1)
            ctcif4: Ctcif4, // Stream x clear transfer complete interrupt flag (x = 7..4) (u1)
            cfeif5: Cfeif4, // Stream x clear FIFO error interrupt flag (x = 7..4) (u1)
            _reserved_7_7: u1,
            cdmeif5: Cdmeif4, // Stream x clear direct mode error interrupt flag (x = 7..4) (u1)
            cteif5: Cteif4, // Stream x clear transfer error interrupt flag (x = 7..4) (u1)
            chtif5: Chtif4, // Stream x clear half transfer interrupt flag (x = 7..4) (u1)
            ctcif5: Ctcif4, // Stream x clear transfer complete interrupt flag (x = 7..4) (u1)
            _reserved_12_15: u4,
            cfeif6: Cfeif4, // Stream x clear FIFO error interrupt flag (x = 7..4) (u1)
            _reserved_17_17: u1,
            cdmeif6: Cdmeif4, // Stream x clear direct mode error interrupt flag (x = 7..4) (u1)
            cteif6: Cteif4, // Stream x clear transfer error interrupt flag (x = 7..4) (u1)
            chtif6: Chtif4, // Stream x clear half transfer interrupt flag (x = 7..4) (u1)
            ctcif6: Ctcif4, // Stream x clear transfer complete interrupt flag (x = 7..4) (u1)
            cfeif7: Cfeif4, // Stream x clear FIFO error interrupt flag (x = 7..4) (u1)
            _reserved_23_23: u1,
            cdmeif7: Cdmeif4, // Stream x clear direct mode error interrupt flag (x = 7..4) (u1)
            cteif7: Cteif4, // Stream x clear transfer error interrupt flag (x = 7..4) (u1)
            chtif7: Chtif4, // Stream x clear half transfer interrupt flag (x = 7..4) (u1)
            ctcif7: Ctcif4, // Stream x clear transfer complete interrupt flag (x = 7..4) (u1)
            _padding_28_31: u4,
        };
        pub const hifcr = mmio(base_address + 0xc, 32, Hifcr);

        /// address: 0x40026010
        /// stream x configuration register
        pub const St0cr = packed struct {
            pub const En = enum(u1) {
                disabled = 0, // Stream disabled
                enabled = 1, // Stream enabled
            };
            pub const Dmeie = enum(u1) {
                disabled = 0, // DME interrupt disabled
                enabled = 1, // DME interrupt enabled
            };
            pub const Teie = enum(u1) {
                disabled = 0, // TE interrupt disabled
                enabled = 1, // TE interrupt enabled
            };
            pub const Htie = enum(u1) {
                disabled = 0, // HT interrupt disabled
                enabled = 1, // HT interrupt enabled
            };
            pub const Tcie = enum(u1) {
                disabled = 0, // TC interrupt disabled
                enabled = 1, // TC interrupt enabled
            };
            pub const Pfctrl = enum(u1) {
                dma = 0, // The DMA is the flow controller
                peripheral = 1, // The peripheral is the flow controller
            };
            pub const Dir = enum(u2) {
                peripheral_to_memory = 0b00, // Peripheral-to-memory
                memory_to_peripheral = 0b01, // Memory-to-peripheral
                memory_to_memory = 0b10, // Memory-to-memory
            };
            pub const Circ = enum(u1) {
                disabled = 0, // Circular mode disabled
                enabled = 1, // Circular mode enabled
            };
            pub const Pinc = enum(u1) {
                fixed = 0, // Address pointer is fixed
                incremented = 1, // Address pointer is incremented after each data transfer
            };
            pub const Psize = enum(u2) {
                bits8 = 0b00, // Byte (8-bit)
                bits16 = 0b01, // Half-word (16-bit)
                bits32 = 0b10, // Word (32-bit)
            };
            pub const Pincos = enum(u1) {
                psize = 0, // The offset size for the peripheral address calculation is linked to the PSIZE
                fixed4 = 1, // The offset size for the peripheral address calculation is fixed to 4 (32-bit alignment)
            };
            pub const Pl = enum(u2) {
                low = 0b00, // Low
                medium = 0b01, // Medium
                high = 0b10, // High
                very_high = 0b11, // Very high
            };
            pub const Dbm = enum(u1) {
                disabled = 0, // No buffer switching at the end of transfer
                enabled = 1, // Memory target switched at the end of the DMA transfer
            };
            pub const Ct = enum(u1) {
                memory0 = 0, // The current target memory is Memory 0
                memory1 = 1, // The current target memory is Memory 1
            };
            pub const Pburst = enum(u2) {
                single = 0b00, // Single transfer
                incr4 = 0b01, // Incremental burst of 4 beats
                incr8 = 0b10, // Incremental burst of 8 beats
                incr16 = 0b11, // Incremental burst of 16 beats
            };
            en: En, // Stream enable / flag stream ready when read low (u1)
            dmeie: Dmeie, // Direct mode error interrupt enable (u1)
            teie: Teie, // Transfer error interrupt enable (u1)
            htie: Htie, // Half transfer interrupt enable (u1)
            tcie: Tcie, // Transfer complete interrupt enable (u1)
            pfctrl: Pfctrl, // Peripheral flow controller (u1)
            dir: Dir, // Data transfer direction (u2)
            circ: Circ, // Circular mode (u1)
            pinc: Pinc, // Peripheral increment mode (u1)
            minc: Pinc, // Memory increment mode (u1)
            psize: Psize, // Peripheral data size (u2)
            msize: Psize, // Memory data size (u2)
            pincos: Pincos, // Peripheral increment offset size (u1)
            pl: Pl, // Priority level (u2)
            dbm: Dbm, // Double buffer mode (u1)
            ct: Ct, // Current target (only in double buffer mode) (u1)
            _reserved_20_20: u1,
            pburst: Pburst, // Peripheral burst transfer configuration (u2)
            mburst: Pburst, // Memory burst transfer configuration (u2)
            chsel: u3, // Channel selection
            _padding_28_31: u4,
        };
        pub const st0cr = mmio(base_address + 0x10, 32, St0cr);

        /// address: 0x40026014
        /// stream x number of data register
        pub const St0ndtr = packed struct {
            ndt: u16, // Number of data items to transfer
            _padding_16_31: u16,
        };
        pub const st0ndtr = mmio(base_address + 0x14, 32, St0ndtr);

        /// address: 0x40026018
        /// stream x peripheral address register
        pub const St0par = packed struct {
            pa: u32, // Peripheral address
        };
        pub const st0par = mmio(base_address + 0x18, 32, St0par);

        /// address: 0x4002601c
        /// stream x memory 0 address register
        pub const St0m0ar = packed struct {
            m0a: u32, // Memory 0 address
        };
        pub const st0m0ar = mmio(base_address + 0x1c, 32, St0m0ar);

        /// address: 0x40026020
        /// stream x memory 1 address register
        pub const St0m1ar = packed struct {
            m1a: u32, // Memory 1 address (used in case of Double buffer mode)
        };
        pub const st0m1ar = mmio(base_address + 0x20, 32, St0m1ar);

        /// address: 0x40026024
        /// stream x FIFO control register
        pub const St0fcr = packed struct {
            pub const Fth = enum(u2) {
                quarter = 0b00, // 1/4 full FIFO
                half = 0b01, // 1/2 full FIFO
                three_quarters = 0b10, // 3/4 full FIFO
                full = 0b11, // Full FIFO
            };
            pub const Dmdis = enum(u1) {
                enabled = 0, // Direct mode is enabled
                disabled = 1, // Direct mode is disabled
            };
            pub const Fs = enum(u3) {
                quarter1 = 0b000, // 0 < fifo_level < 1/4
                quarter2 = 0b001, // 1/4 <= fifo_level < 1/2
                quarter3 = 0b010, // 1/2 <= fifo_level < 3/4
                quarter4 = 0b011, // 3/4 <= fifo_level < full
                empty = 0b100, // FIFO is empty
                full = 0b101, // FIFO is full
            };
            pub const Feie = enum(u1) {
                disabled = 0, // FE interrupt disabled
                enabled = 1, // FE interrupt enabled
            };
            fth: Fth, // FIFO threshold selection (u2)
            dmdis: Dmdis, // Direct mode disable (u1)
            fs: Fs, // FIFO status (u3)
            _reserved_6_6: u1,
            feie: Feie, // FIFO error interrupt enable (u1)
            _padding_8_31: u24,
        };
        pub const st0fcr = mmio(base_address + 0x24, 32, St0fcr);

        /// address: 0x40026028
        /// stream x configuration register
        pub const St1cr = packed struct {
            pub const En = enum(u1) {
                disabled = 0, // Stream disabled
                enabled = 1, // Stream enabled
            };
            pub const Dmeie = enum(u1) {
                disabled = 0, // DME interrupt disabled
                enabled = 1, // DME interrupt enabled
            };
            pub const Teie = enum(u1) {
                disabled = 0, // TE interrupt disabled
                enabled = 1, // TE interrupt enabled
            };
            pub const Htie = enum(u1) {
                disabled = 0, // HT interrupt disabled
                enabled = 1, // HT interrupt enabled
            };
            pub const Tcie = enum(u1) {
                disabled = 0, // TC interrupt disabled
                enabled = 1, // TC interrupt enabled
            };
            pub const Pfctrl = enum(u1) {
                dma = 0, // The DMA is the flow controller
                peripheral = 1, // The peripheral is the flow controller
            };
            pub const Dir = enum(u2) {
                peripheral_to_memory = 0b00, // Peripheral-to-memory
                memory_to_peripheral = 0b01, // Memory-to-peripheral
                memory_to_memory = 0b10, // Memory-to-memory
            };
            pub const Circ = enum(u1) {
                disabled = 0, // Circular mode disabled
                enabled = 1, // Circular mode enabled
            };
            pub const Pinc = enum(u1) {
                fixed = 0, // Address pointer is fixed
                incremented = 1, // Address pointer is incremented after each data transfer
            };
            pub const Psize = enum(u2) {
                bits8 = 0b00, // Byte (8-bit)
                bits16 = 0b01, // Half-word (16-bit)
                bits32 = 0b10, // Word (32-bit)
            };
            pub const Pincos = enum(u1) {
                psize = 0, // The offset size for the peripheral address calculation is linked to the PSIZE
                fixed4 = 1, // The offset size for the peripheral address calculation is fixed to 4 (32-bit alignment)
            };
            pub const Pl = enum(u2) {
                low = 0b00, // Low
                medium = 0b01, // Medium
                high = 0b10, // High
                very_high = 0b11, // Very high
            };
            pub const Dbm = enum(u1) {
                disabled = 0, // No buffer switching at the end of transfer
                enabled = 1, // Memory target switched at the end of the DMA transfer
            };
            pub const Ct = enum(u1) {
                memory0 = 0, // The current target memory is Memory 0
                memory1 = 1, // The current target memory is Memory 1
            };
            pub const Pburst = enum(u2) {
                single = 0b00, // Single transfer
                incr4 = 0b01, // Incremental burst of 4 beats
                incr8 = 0b10, // Incremental burst of 8 beats
                incr16 = 0b11, // Incremental burst of 16 beats
            };
            en: En, // Stream enable / flag stream ready when read low (u1)
            dmeie: Dmeie, // Direct mode error interrupt enable (u1)
            teie: Teie, // Transfer error interrupt enable (u1)
            htie: Htie, // Half transfer interrupt enable (u1)
            tcie: Tcie, // Transfer complete interrupt enable (u1)
            pfctrl: Pfctrl, // Peripheral flow controller (u1)
            dir: Dir, // Data transfer direction (u2)
            circ: Circ, // Circular mode (u1)
            pinc: Pinc, // Peripheral increment mode (u1)
            minc: Pinc, // Memory increment mode (u1)
            psize: Psize, // Peripheral data size (u2)
            msize: Psize, // Memory data size (u2)
            pincos: Pincos, // Peripheral increment offset size (u1)
            pl: Pl, // Priority level (u2)
            dbm: Dbm, // Double buffer mode (u1)
            ct: Ct, // Current target (only in double buffer mode) (u1)
            _reserved_20_20: u1,
            pburst: Pburst, // Peripheral burst transfer configuration (u2)
            mburst: Pburst, // Memory burst transfer configuration (u2)
            chsel: u3, // Channel selection
            _padding_28_31: u4,
        };
        pub const st1cr = mmio(base_address + 0x28, 32, St1cr);

        /// address: 0x4002602c
        /// stream x number of data register
        pub const St1ndtr = packed struct {
            ndt: u16, // Number of data items to transfer
            _padding_16_31: u16,
        };
        pub const st1ndtr = mmio(base_address + 0x2c, 32, St1ndtr);

        /// address: 0x40026030
        /// stream x peripheral address register
        pub const St1par = packed struct {
            pa: u32, // Peripheral address
        };
        pub const st1par = mmio(base_address + 0x30, 32, St1par);

        /// address: 0x40026034
        /// stream x memory 0 address register
        pub const St1m0ar = packed struct {
            m0a: u32, // Memory 0 address
        };
        pub const st1m0ar = mmio(base_address + 0x34, 32, St1m0ar);

        /// address: 0x40026038
        /// stream x memory 1 address register
        pub const St1m1ar = packed struct {
            m1a: u32, // Memory 1 address (used in case of Double buffer mode)
        };
        pub const st1m1ar = mmio(base_address + 0x38, 32, St1m1ar);

        /// address: 0x4002603c
        /// stream x FIFO control register
        pub const St1fcr = packed struct {
            pub const Fth = enum(u2) {
                quarter = 0b00, // 1/4 full FIFO
                half = 0b01, // 1/2 full FIFO
                three_quarters = 0b10, // 3/4 full FIFO
                full = 0b11, // Full FIFO
            };
            pub const Dmdis = enum(u1) {
                enabled = 0, // Direct mode is enabled
                disabled = 1, // Direct mode is disabled
            };
            pub const Fs = enum(u3) {
                quarter1 = 0b000, // 0 < fifo_level < 1/4
                quarter2 = 0b001, // 1/4 <= fifo_level < 1/2
                quarter3 = 0b010, // 1/2 <= fifo_level < 3/4
                quarter4 = 0b011, // 3/4 <= fifo_level < full
                empty = 0b100, // FIFO is empty
                full = 0b101, // FIFO is full
            };
            pub const Feie = enum(u1) {
                disabled = 0, // FE interrupt disabled
                enabled = 1, // FE interrupt enabled
            };
            fth: Fth, // FIFO threshold selection (u2)
            dmdis: Dmdis, // Direct mode disable (u1)
            fs: Fs, // FIFO status (u3)
            _reserved_6_6: u1,
            feie: Feie, // FIFO error interrupt enable (u1)
            _padding_8_31: u24,
        };
        pub const st1fcr = mmio(base_address + 0x3c, 32, St1fcr);

        /// address: 0x40026040
        /// stream x configuration register
        pub const St2cr = packed struct {
            pub const En = enum(u1) {
                disabled = 0, // Stream disabled
                enabled = 1, // Stream enabled
            };
            pub const Dmeie = enum(u1) {
                disabled = 0, // DME interrupt disabled
                enabled = 1, // DME interrupt enabled
            };
            pub const Teie = enum(u1) {
                disabled = 0, // TE interrupt disabled
                enabled = 1, // TE interrupt enabled
            };
            pub const Htie = enum(u1) {
                disabled = 0, // HT interrupt disabled
                enabled = 1, // HT interrupt enabled
            };
            pub const Tcie = enum(u1) {
                disabled = 0, // TC interrupt disabled
                enabled = 1, // TC interrupt enabled
            };
            pub const Pfctrl = enum(u1) {
                dma = 0, // The DMA is the flow controller
                peripheral = 1, // The peripheral is the flow controller
            };
            pub const Dir = enum(u2) {
                peripheral_to_memory = 0b00, // Peripheral-to-memory
                memory_to_peripheral = 0b01, // Memory-to-peripheral
                memory_to_memory = 0b10, // Memory-to-memory
            };
            pub const Circ = enum(u1) {
                disabled = 0, // Circular mode disabled
                enabled = 1, // Circular mode enabled
            };
            pub const Pinc = enum(u1) {
                fixed = 0, // Address pointer is fixed
                incremented = 1, // Address pointer is incremented after each data transfer
            };
            pub const Psize = enum(u2) {
                bits8 = 0b00, // Byte (8-bit)
                bits16 = 0b01, // Half-word (16-bit)
                bits32 = 0b10, // Word (32-bit)
            };
            pub const Pincos = enum(u1) {
                psize = 0, // The offset size for the peripheral address calculation is linked to the PSIZE
                fixed4 = 1, // The offset size for the peripheral address calculation is fixed to 4 (32-bit alignment)
            };
            pub const Pl = enum(u2) {
                low = 0b00, // Low
                medium = 0b01, // Medium
                high = 0b10, // High
                very_high = 0b11, // Very high
            };
            pub const Dbm = enum(u1) {
                disabled = 0, // No buffer switching at the end of transfer
                enabled = 1, // Memory target switched at the end of the DMA transfer
            };
            pub const Ct = enum(u1) {
                memory0 = 0, // The current target memory is Memory 0
                memory1 = 1, // The current target memory is Memory 1
            };
            pub const Pburst = enum(u2) {
                single = 0b00, // Single transfer
                incr4 = 0b01, // Incremental burst of 4 beats
                incr8 = 0b10, // Incremental burst of 8 beats
                incr16 = 0b11, // Incremental burst of 16 beats
            };
            en: En, // Stream enable / flag stream ready when read low (u1)
            dmeie: Dmeie, // Direct mode error interrupt enable (u1)
            teie: Teie, // Transfer error interrupt enable (u1)
            htie: Htie, // Half transfer interrupt enable (u1)
            tcie: Tcie, // Transfer complete interrupt enable (u1)
            pfctrl: Pfctrl, // Peripheral flow controller (u1)
            dir: Dir, // Data transfer direction (u2)
            circ: Circ, // Circular mode (u1)
            pinc: Pinc, // Peripheral increment mode (u1)
            minc: Pinc, // Memory increment mode (u1)
            psize: Psize, // Peripheral data size (u2)
            msize: Psize, // Memory data size (u2)
            pincos: Pincos, // Peripheral increment offset size (u1)
            pl: Pl, // Priority level (u2)
            dbm: Dbm, // Double buffer mode (u1)
            ct: Ct, // Current target (only in double buffer mode) (u1)
            _reserved_20_20: u1,
            pburst: Pburst, // Peripheral burst transfer configuration (u2)
            mburst: Pburst, // Memory burst transfer configuration (u2)
            chsel: u3, // Channel selection
            _padding_28_31: u4,
        };
        pub const st2cr = mmio(base_address + 0x40, 32, St2cr);

        /// address: 0x40026044
        /// stream x number of data register
        pub const St2ndtr = packed struct {
            ndt: u16, // Number of data items to transfer
            _padding_16_31: u16,
        };
        pub const st2ndtr = mmio(base_address + 0x44, 32, St2ndtr);

        /// address: 0x40026048
        /// stream x peripheral address register
        pub const St2par = packed struct {
            pa: u32, // Peripheral address
        };
        pub const st2par = mmio(base_address + 0x48, 32, St2par);

        /// address: 0x4002604c
        /// stream x memory 0 address register
        pub const St2m0ar = packed struct {
            m0a: u32, // Memory 0 address
        };
        pub const st2m0ar = mmio(base_address + 0x4c, 32, St2m0ar);

        /// address: 0x40026050
        /// stream x memory 1 address register
        pub const St2m1ar = packed struct {
            m1a: u32, // Memory 1 address (used in case of Double buffer mode)
        };
        pub const st2m1ar = mmio(base_address + 0x50, 32, St2m1ar);

        /// address: 0x40026054
        /// stream x FIFO control register
        pub const St2fcr = packed struct {
            pub const Fth = enum(u2) {
                quarter = 0b00, // 1/4 full FIFO
                half = 0b01, // 1/2 full FIFO
                three_quarters = 0b10, // 3/4 full FIFO
                full = 0b11, // Full FIFO
            };
            pub const Dmdis = enum(u1) {
                enabled = 0, // Direct mode is enabled
                disabled = 1, // Direct mode is disabled
            };
            pub const Fs = enum(u3) {
                quarter1 = 0b000, // 0 < fifo_level < 1/4
                quarter2 = 0b001, // 1/4 <= fifo_level < 1/2
                quarter3 = 0b010, // 1/2 <= fifo_level < 3/4
                quarter4 = 0b011, // 3/4 <= fifo_level < full
                empty = 0b100, // FIFO is empty
                full = 0b101, // FIFO is full
            };
            pub const Feie = enum(u1) {
                disabled = 0, // FE interrupt disabled
                enabled = 1, // FE interrupt enabled
            };
            fth: Fth, // FIFO threshold selection (u2)
            dmdis: Dmdis, // Direct mode disable (u1)
            fs: Fs, // FIFO status (u3)
            _reserved_6_6: u1,
            feie: Feie, // FIFO error interrupt enable (u1)
            _padding_8_31: u24,
        };
        pub const st2fcr = mmio(base_address + 0x54, 32, St2fcr);

        /// address: 0x40026058
        /// stream x configuration register
        pub const St3cr = packed struct {
            pub const En = enum(u1) {
                disabled = 0, // Stream disabled
                enabled = 1, // Stream enabled
            };
            pub const Dmeie = enum(u1) {
                disabled = 0, // DME interrupt disabled
                enabled = 1, // DME interrupt enabled
            };
            pub const Teie = enum(u1) {
                disabled = 0, // TE interrupt disabled
                enabled = 1, // TE interrupt enabled
            };
            pub const Htie = enum(u1) {
                disabled = 0, // HT interrupt disabled
                enabled = 1, // HT interrupt enabled
            };
            pub const Tcie = enum(u1) {
                disabled = 0, // TC interrupt disabled
                enabled = 1, // TC interrupt enabled
            };
            pub const Pfctrl = enum(u1) {
                dma = 0, // The DMA is the flow controller
                peripheral = 1, // The peripheral is the flow controller
            };
            pub const Dir = enum(u2) {
                peripheral_to_memory = 0b00, // Peripheral-to-memory
                memory_to_peripheral = 0b01, // Memory-to-peripheral
                memory_to_memory = 0b10, // Memory-to-memory
            };
            pub const Circ = enum(u1) {
                disabled = 0, // Circular mode disabled
                enabled = 1, // Circular mode enabled
            };
            pub const Pinc = enum(u1) {
                fixed = 0, // Address pointer is fixed
                incremented = 1, // Address pointer is incremented after each data transfer
            };
            pub const Psize = enum(u2) {
                bits8 = 0b00, // Byte (8-bit)
                bits16 = 0b01, // Half-word (16-bit)
                bits32 = 0b10, // Word (32-bit)
            };
            pub const Pincos = enum(u1) {
                psize = 0, // The offset size for the peripheral address calculation is linked to the PSIZE
                fixed4 = 1, // The offset size for the peripheral address calculation is fixed to 4 (32-bit alignment)
            };
            pub const Pl = enum(u2) {
                low = 0b00, // Low
                medium = 0b01, // Medium
                high = 0b10, // High
                very_high = 0b11, // Very high
            };
            pub const Dbm = enum(u1) {
                disabled = 0, // No buffer switching at the end of transfer
                enabled = 1, // Memory target switched at the end of the DMA transfer
            };
            pub const Ct = enum(u1) {
                memory0 = 0, // The current target memory is Memory 0
                memory1 = 1, // The current target memory is Memory 1
            };
            pub const Pburst = enum(u2) {
                single = 0b00, // Single transfer
                incr4 = 0b01, // Incremental burst of 4 beats
                incr8 = 0b10, // Incremental burst of 8 beats
                incr16 = 0b11, // Incremental burst of 16 beats
            };
            en: En, // Stream enable / flag stream ready when read low (u1)
            dmeie: Dmeie, // Direct mode error interrupt enable (u1)
            teie: Teie, // Transfer error interrupt enable (u1)
            htie: Htie, // Half transfer interrupt enable (u1)
            tcie: Tcie, // Transfer complete interrupt enable (u1)
            pfctrl: Pfctrl, // Peripheral flow controller (u1)
            dir: Dir, // Data transfer direction (u2)
            circ: Circ, // Circular mode (u1)
            pinc: Pinc, // Peripheral increment mode (u1)
            minc: Pinc, // Memory increment mode (u1)
            psize: Psize, // Peripheral data size (u2)
            msize: Psize, // Memory data size (u2)
            pincos: Pincos, // Peripheral increment offset size (u1)
            pl: Pl, // Priority level (u2)
            dbm: Dbm, // Double buffer mode (u1)
            ct: Ct, // Current target (only in double buffer mode) (u1)
            _reserved_20_20: u1,
            pburst: Pburst, // Peripheral burst transfer configuration (u2)
            mburst: Pburst, // Memory burst transfer configuration (u2)
            chsel: u3, // Channel selection
            _padding_28_31: u4,
        };
        pub const st3cr = mmio(base_address + 0x58, 32, St3cr);

        /// address: 0x4002605c
        /// stream x number of data register
        pub const St3ndtr = packed struct {
            ndt: u16, // Number of data items to transfer
            _padding_16_31: u16,
        };
        pub const st3ndtr = mmio(base_address + 0x5c, 32, St3ndtr);

        /// address: 0x40026060
        /// stream x peripheral address register
        pub const St3par = packed struct {
            pa: u32, // Peripheral address
        };
        pub const st3par = mmio(base_address + 0x60, 32, St3par);

        /// address: 0x40026064
        /// stream x memory 0 address register
        pub const St3m0ar = packed struct {
            m0a: u32, // Memory 0 address
        };
        pub const st3m0ar = mmio(base_address + 0x64, 32, St3m0ar);

        /// address: 0x40026068
        /// stream x memory 1 address register
        pub const St3m1ar = packed struct {
            m1a: u32, // Memory 1 address (used in case of Double buffer mode)
        };
        pub const st3m1ar = mmio(base_address + 0x68, 32, St3m1ar);

        /// address: 0x4002606c
        /// stream x FIFO control register
        pub const St3fcr = packed struct {
            pub const Fth = enum(u2) {
                quarter = 0b00, // 1/4 full FIFO
                half = 0b01, // 1/2 full FIFO
                three_quarters = 0b10, // 3/4 full FIFO
                full = 0b11, // Full FIFO
            };
            pub const Dmdis = enum(u1) {
                enabled = 0, // Direct mode is enabled
                disabled = 1, // Direct mode is disabled
            };
            pub const Fs = enum(u3) {
                quarter1 = 0b000, // 0 < fifo_level < 1/4
                quarter2 = 0b001, // 1/4 <= fifo_level < 1/2
                quarter3 = 0b010, // 1/2 <= fifo_level < 3/4
                quarter4 = 0b011, // 3/4 <= fifo_level < full
                empty = 0b100, // FIFO is empty
                full = 0b101, // FIFO is full
            };
            pub const Feie = enum(u1) {
                disabled = 0, // FE interrupt disabled
                enabled = 1, // FE interrupt enabled
            };
            fth: Fth, // FIFO threshold selection (u2)
            dmdis: Dmdis, // Direct mode disable (u1)
            fs: Fs, // FIFO status (u3)
            _reserved_6_6: u1,
            feie: Feie, // FIFO error interrupt enable (u1)
            _padding_8_31: u24,
        };
        pub const st3fcr = mmio(base_address + 0x6c, 32, St3fcr);

        /// address: 0x40026070
        /// stream x configuration register
        pub const St4cr = packed struct {
            pub const En = enum(u1) {
                disabled = 0, // Stream disabled
                enabled = 1, // Stream enabled
            };
            pub const Dmeie = enum(u1) {
                disabled = 0, // DME interrupt disabled
                enabled = 1, // DME interrupt enabled
            };
            pub const Teie = enum(u1) {
                disabled = 0, // TE interrupt disabled
                enabled = 1, // TE interrupt enabled
            };
            pub const Htie = enum(u1) {
                disabled = 0, // HT interrupt disabled
                enabled = 1, // HT interrupt enabled
            };
            pub const Tcie = enum(u1) {
                disabled = 0, // TC interrupt disabled
                enabled = 1, // TC interrupt enabled
            };
            pub const Pfctrl = enum(u1) {
                dma = 0, // The DMA is the flow controller
                peripheral = 1, // The peripheral is the flow controller
            };
            pub const Dir = enum(u2) {
                peripheral_to_memory = 0b00, // Peripheral-to-memory
                memory_to_peripheral = 0b01, // Memory-to-peripheral
                memory_to_memory = 0b10, // Memory-to-memory
            };
            pub const Circ = enum(u1) {
                disabled = 0, // Circular mode disabled
                enabled = 1, // Circular mode enabled
            };
            pub const Pinc = enum(u1) {
                fixed = 0, // Address pointer is fixed
                incremented = 1, // Address pointer is incremented after each data transfer
            };
            pub const Psize = enum(u2) {
                bits8 = 0b00, // Byte (8-bit)
                bits16 = 0b01, // Half-word (16-bit)
                bits32 = 0b10, // Word (32-bit)
            };
            pub const Pincos = enum(u1) {
                psize = 0, // The offset size for the peripheral address calculation is linked to the PSIZE
                fixed4 = 1, // The offset size for the peripheral address calculation is fixed to 4 (32-bit alignment)
            };
            pub const Pl = enum(u2) {
                low = 0b00, // Low
                medium = 0b01, // Medium
                high = 0b10, // High
                very_high = 0b11, // Very high
            };
            pub const Dbm = enum(u1) {
                disabled = 0, // No buffer switching at the end of transfer
                enabled = 1, // Memory target switched at the end of the DMA transfer
            };
            pub const Ct = enum(u1) {
                memory0 = 0, // The current target memory is Memory 0
                memory1 = 1, // The current target memory is Memory 1
            };
            pub const Pburst = enum(u2) {
                single = 0b00, // Single transfer
                incr4 = 0b01, // Incremental burst of 4 beats
                incr8 = 0b10, // Incremental burst of 8 beats
                incr16 = 0b11, // Incremental burst of 16 beats
            };
            en: En, // Stream enable / flag stream ready when read low (u1)
            dmeie: Dmeie, // Direct mode error interrupt enable (u1)
            teie: Teie, // Transfer error interrupt enable (u1)
            htie: Htie, // Half transfer interrupt enable (u1)
            tcie: Tcie, // Transfer complete interrupt enable (u1)
            pfctrl: Pfctrl, // Peripheral flow controller (u1)
            dir: Dir, // Data transfer direction (u2)
            circ: Circ, // Circular mode (u1)
            pinc: Pinc, // Peripheral increment mode (u1)
            minc: Pinc, // Memory increment mode (u1)
            psize: Psize, // Peripheral data size (u2)
            msize: Psize, // Memory data size (u2)
            pincos: Pincos, // Peripheral increment offset size (u1)
            pl: Pl, // Priority level (u2)
            dbm: Dbm, // Double buffer mode (u1)
            ct: Ct, // Current target (only in double buffer mode) (u1)
            _reserved_20_20: u1,
            pburst: Pburst, // Peripheral burst transfer configuration (u2)
            mburst: Pburst, // Memory burst transfer configuration (u2)
            chsel: u3, // Channel selection
            _padding_28_31: u4,
        };
        pub const st4cr = mmio(base_address + 0x70, 32, St4cr);

        /// address: 0x40026074
        /// stream x number of data register
        pub const St4ndtr = packed struct {
            ndt: u16, // Number of data items to transfer
            _padding_16_31: u16,
        };
        pub const st4ndtr = mmio(base_address + 0x74, 32, St4ndtr);

        /// address: 0x40026078
        /// stream x peripheral address register
        pub const St4par = packed struct {
            pa: u32, // Peripheral address
        };
        pub const st4par = mmio(base_address + 0x78, 32, St4par);

        /// address: 0x4002607c
        /// stream x memory 0 address register
        pub const St4m0ar = packed struct {
            m0a: u32, // Memory 0 address
        };
        pub const st4m0ar = mmio(base_address + 0x7c, 32, St4m0ar);

        /// address: 0x40026080
        /// stream x memory 1 address register
        pub const St4m1ar = packed struct {
            m1a: u32, // Memory 1 address (used in case of Double buffer mode)
        };
        pub const st4m1ar = mmio(base_address + 0x80, 32, St4m1ar);

        /// address: 0x40026084
        /// stream x FIFO control register
        pub const St4fcr = packed struct {
            pub const Fth = enum(u2) {
                quarter = 0b00, // 1/4 full FIFO
                half = 0b01, // 1/2 full FIFO
                three_quarters = 0b10, // 3/4 full FIFO
                full = 0b11, // Full FIFO
            };
            pub const Dmdis = enum(u1) {
                enabled = 0, // Direct mode is enabled
                disabled = 1, // Direct mode is disabled
            };
            pub const Fs = enum(u3) {
                quarter1 = 0b000, // 0 < fifo_level < 1/4
                quarter2 = 0b001, // 1/4 <= fifo_level < 1/2
                quarter3 = 0b010, // 1/2 <= fifo_level < 3/4
                quarter4 = 0b011, // 3/4 <= fifo_level < full
                empty = 0b100, // FIFO is empty
                full = 0b101, // FIFO is full
            };
            pub const Feie = enum(u1) {
                disabled = 0, // FE interrupt disabled
                enabled = 1, // FE interrupt enabled
            };
            fth: Fth, // FIFO threshold selection (u2)
            dmdis: Dmdis, // Direct mode disable (u1)
            fs: Fs, // FIFO status (u3)
            _reserved_6_6: u1,
            feie: Feie, // FIFO error interrupt enable (u1)
            _padding_8_31: u24,
        };
        pub const st4fcr = mmio(base_address + 0x84, 32, St4fcr);

        /// address: 0x40026088
        /// stream x configuration register
        pub const St5cr = packed struct {
            pub const En = enum(u1) {
                disabled = 0, // Stream disabled
                enabled = 1, // Stream enabled
            };
            pub const Dmeie = enum(u1) {
                disabled = 0, // DME interrupt disabled
                enabled = 1, // DME interrupt enabled
            };
            pub const Teie = enum(u1) {
                disabled = 0, // TE interrupt disabled
                enabled = 1, // TE interrupt enabled
            };
            pub const Htie = enum(u1) {
                disabled = 0, // HT interrupt disabled
                enabled = 1, // HT interrupt enabled
            };
            pub const Tcie = enum(u1) {
                disabled = 0, // TC interrupt disabled
                enabled = 1, // TC interrupt enabled
            };
            pub const Pfctrl = enum(u1) {
                dma = 0, // The DMA is the flow controller
                peripheral = 1, // The peripheral is the flow controller
            };
            pub const Dir = enum(u2) {
                peripheral_to_memory = 0b00, // Peripheral-to-memory
                memory_to_peripheral = 0b01, // Memory-to-peripheral
                memory_to_memory = 0b10, // Memory-to-memory
            };
            pub const Circ = enum(u1) {
                disabled = 0, // Circular mode disabled
                enabled = 1, // Circular mode enabled
            };
            pub const Pinc = enum(u1) {
                fixed = 0, // Address pointer is fixed
                incremented = 1, // Address pointer is incremented after each data transfer
            };
            pub const Psize = enum(u2) {
                bits8 = 0b00, // Byte (8-bit)
                bits16 = 0b01, // Half-word (16-bit)
                bits32 = 0b10, // Word (32-bit)
            };
            pub const Pincos = enum(u1) {
                psize = 0, // The offset size for the peripheral address calculation is linked to the PSIZE
                fixed4 = 1, // The offset size for the peripheral address calculation is fixed to 4 (32-bit alignment)
            };
            pub const Pl = enum(u2) {
                low = 0b00, // Low
                medium = 0b01, // Medium
                high = 0b10, // High
                very_high = 0b11, // Very high
            };
            pub const Dbm = enum(u1) {
                disabled = 0, // No buffer switching at the end of transfer
                enabled = 1, // Memory target switched at the end of the DMA transfer
            };
            pub const Ct = enum(u1) {
                memory0 = 0, // The current target memory is Memory 0
                memory1 = 1, // The current target memory is Memory 1
            };
            pub const Pburst = enum(u2) {
                single = 0b00, // Single transfer
                incr4 = 0b01, // Incremental burst of 4 beats
                incr8 = 0b10, // Incremental burst of 8 beats
                incr16 = 0b11, // Incremental burst of 16 beats
            };
            en: En, // Stream enable / flag stream ready when read low (u1)
            dmeie: Dmeie, // Direct mode error interrupt enable (u1)
            teie: Teie, // Transfer error interrupt enable (u1)
            htie: Htie, // Half transfer interrupt enable (u1)
            tcie: Tcie, // Transfer complete interrupt enable (u1)
            pfctrl: Pfctrl, // Peripheral flow controller (u1)
            dir: Dir, // Data transfer direction (u2)
            circ: Circ, // Circular mode (u1)
            pinc: Pinc, // Peripheral increment mode (u1)
            minc: Pinc, // Memory increment mode (u1)
            psize: Psize, // Peripheral data size (u2)
            msize: Psize, // Memory data size (u2)
            pincos: Pincos, // Peripheral increment offset size (u1)
            pl: Pl, // Priority level (u2)
            dbm: Dbm, // Double buffer mode (u1)
            ct: Ct, // Current target (only in double buffer mode) (u1)
            _reserved_20_20: u1,
            pburst: Pburst, // Peripheral burst transfer configuration (u2)
            mburst: Pburst, // Memory burst transfer configuration (u2)
            chsel: u3, // Channel selection
            _padding_28_31: u4,
        };
        pub const st5cr = mmio(base_address + 0x88, 32, St5cr);

        /// address: 0x4002608c
        /// stream x number of data register
        pub const St5ndtr = packed struct {
            ndt: u16, // Number of data items to transfer
            _padding_16_31: u16,
        };
        pub const st5ndtr = mmio(base_address + 0x8c, 32, St5ndtr);

        /// address: 0x40026090
        /// stream x peripheral address register
        pub const St5par = packed struct {
            pa: u32, // Peripheral address
        };
        pub const st5par = mmio(base_address + 0x90, 32, St5par);

        /// address: 0x40026094
        /// stream x memory 0 address register
        pub const St5m0ar = packed struct {
            m0a: u32, // Memory 0 address
        };
        pub const st5m0ar = mmio(base_address + 0x94, 32, St5m0ar);

        /// address: 0x40026098
        /// stream x memory 1 address register
        pub const St5m1ar = packed struct {
            m1a: u32, // Memory 1 address (used in case of Double buffer mode)
        };
        pub const st5m1ar = mmio(base_address + 0x98, 32, St5m1ar);

        /// address: 0x4002609c
        /// stream x FIFO control register
        pub const St5fcr = packed struct {
            pub const Fth = enum(u2) {
                quarter = 0b00, // 1/4 full FIFO
                half = 0b01, // 1/2 full FIFO
                three_quarters = 0b10, // 3/4 full FIFO
                full = 0b11, // Full FIFO
            };
            pub const Dmdis = enum(u1) {
                enabled = 0, // Direct mode is enabled
                disabled = 1, // Direct mode is disabled
            };
            pub const Fs = enum(u3) {
                quarter1 = 0b000, // 0 < fifo_level < 1/4
                quarter2 = 0b001, // 1/4 <= fifo_level < 1/2
                quarter3 = 0b010, // 1/2 <= fifo_level < 3/4
                quarter4 = 0b011, // 3/4 <= fifo_level < full
                empty = 0b100, // FIFO is empty
                full = 0b101, // FIFO is full
            };
            pub const Feie = enum(u1) {
                disabled = 0, // FE interrupt disabled
                enabled = 1, // FE interrupt enabled
            };
            fth: Fth, // FIFO threshold selection (u2)
            dmdis: Dmdis, // Direct mode disable (u1)
            fs: Fs, // FIFO status (u3)
            _reserved_6_6: u1,
            feie: Feie, // FIFO error interrupt enable (u1)
            _padding_8_31: u24,
        };
        pub const st5fcr = mmio(base_address + 0x9c, 32, St5fcr);

        /// address: 0x400260a0
        /// stream x configuration register
        pub const St6cr = packed struct {
            pub const En = enum(u1) {
                disabled = 0, // Stream disabled
                enabled = 1, // Stream enabled
            };
            pub const Dmeie = enum(u1) {
                disabled = 0, // DME interrupt disabled
                enabled = 1, // DME interrupt enabled
            };
            pub const Teie = enum(u1) {
                disabled = 0, // TE interrupt disabled
                enabled = 1, // TE interrupt enabled
            };
            pub const Htie = enum(u1) {
                disabled = 0, // HT interrupt disabled
                enabled = 1, // HT interrupt enabled
            };
            pub const Tcie = enum(u1) {
                disabled = 0, // TC interrupt disabled
                enabled = 1, // TC interrupt enabled
            };
            pub const Pfctrl = enum(u1) {
                dma = 0, // The DMA is the flow controller
                peripheral = 1, // The peripheral is the flow controller
            };
            pub const Dir = enum(u2) {
                peripheral_to_memory = 0b00, // Peripheral-to-memory
                memory_to_peripheral = 0b01, // Memory-to-peripheral
                memory_to_memory = 0b10, // Memory-to-memory
            };
            pub const Circ = enum(u1) {
                disabled = 0, // Circular mode disabled
                enabled = 1, // Circular mode enabled
            };
            pub const Pinc = enum(u1) {
                fixed = 0, // Address pointer is fixed
                incremented = 1, // Address pointer is incremented after each data transfer
            };
            pub const Psize = enum(u2) {
                bits8 = 0b00, // Byte (8-bit)
                bits16 = 0b01, // Half-word (16-bit)
                bits32 = 0b10, // Word (32-bit)
            };
            pub const Pincos = enum(u1) {
                psize = 0, // The offset size for the peripheral address calculation is linked to the PSIZE
                fixed4 = 1, // The offset size for the peripheral address calculation is fixed to 4 (32-bit alignment)
            };
            pub const Pl = enum(u2) {
                low = 0b00, // Low
                medium = 0b01, // Medium
                high = 0b10, // High
                very_high = 0b11, // Very high
            };
            pub const Dbm = enum(u1) {
                disabled = 0, // No buffer switching at the end of transfer
                enabled = 1, // Memory target switched at the end of the DMA transfer
            };
            pub const Ct = enum(u1) {
                memory0 = 0, // The current target memory is Memory 0
                memory1 = 1, // The current target memory is Memory 1
            };
            pub const Pburst = enum(u2) {
                single = 0b00, // Single transfer
                incr4 = 0b01, // Incremental burst of 4 beats
                incr8 = 0b10, // Incremental burst of 8 beats
                incr16 = 0b11, // Incremental burst of 16 beats
            };
            en: En, // Stream enable / flag stream ready when read low (u1)
            dmeie: Dmeie, // Direct mode error interrupt enable (u1)
            teie: Teie, // Transfer error interrupt enable (u1)
            htie: Htie, // Half transfer interrupt enable (u1)
            tcie: Tcie, // Transfer complete interrupt enable (u1)
            pfctrl: Pfctrl, // Peripheral flow controller (u1)
            dir: Dir, // Data transfer direction (u2)
            circ: Circ, // Circular mode (u1)
            pinc: Pinc, // Peripheral increment mode (u1)
            minc: Pinc, // Memory increment mode (u1)
            psize: Psize, // Peripheral data size (u2)
            msize: Psize, // Memory data size (u2)
            pincos: Pincos, // Peripheral increment offset size (u1)
            pl: Pl, // Priority level (u2)
            dbm: Dbm, // Double buffer mode (u1)
            ct: Ct, // Current target (only in double buffer mode) (u1)
            _reserved_20_20: u1,
            pburst: Pburst, // Peripheral burst transfer configuration (u2)
            mburst: Pburst, // Memory burst transfer configuration (u2)
            chsel: u3, // Channel selection
            _padding_28_31: u4,
        };
        pub const st6cr = mmio(base_address + 0xa0, 32, St6cr);

        /// address: 0x400260a4
        /// stream x number of data register
        pub const St6ndtr = packed struct {
            ndt: u16, // Number of data items to transfer
            _padding_16_31: u16,
        };
        pub const st6ndtr = mmio(base_address + 0xa4, 32, St6ndtr);

        /// address: 0x400260a8
        /// stream x peripheral address register
        pub const St6par = packed struct {
            pa: u32, // Peripheral address
        };
        pub const st6par = mmio(base_address + 0xa8, 32, St6par);

        /// address: 0x400260ac
        /// stream x memory 0 address register
        pub const St6m0ar = packed struct {
            m0a: u32, // Memory 0 address
        };
        pub const st6m0ar = mmio(base_address + 0xac, 32, St6m0ar);

        /// address: 0x400260b0
        /// stream x memory 1 address register
        pub const St6m1ar = packed struct {
            m1a: u32, // Memory 1 address (used in case of Double buffer mode)
        };
        pub const st6m1ar = mmio(base_address + 0xb0, 32, St6m1ar);

        /// address: 0x400260b4
        /// stream x FIFO control register
        pub const St6fcr = packed struct {
            pub const Fth = enum(u2) {
                quarter = 0b00, // 1/4 full FIFO
                half = 0b01, // 1/2 full FIFO
                three_quarters = 0b10, // 3/4 full FIFO
                full = 0b11, // Full FIFO
            };
            pub const Dmdis = enum(u1) {
                enabled = 0, // Direct mode is enabled
                disabled = 1, // Direct mode is disabled
            };
            pub const Fs = enum(u3) {
                quarter1 = 0b000, // 0 < fifo_level < 1/4
                quarter2 = 0b001, // 1/4 <= fifo_level < 1/2
                quarter3 = 0b010, // 1/2 <= fifo_level < 3/4
                quarter4 = 0b011, // 3/4 <= fifo_level < full
                empty = 0b100, // FIFO is empty
                full = 0b101, // FIFO is full
            };
            pub const Feie = enum(u1) {
                disabled = 0, // FE interrupt disabled
                enabled = 1, // FE interrupt enabled
            };
            fth: Fth, // FIFO threshold selection (u2)
            dmdis: Dmdis, // Direct mode disable (u1)
            fs: Fs, // FIFO status (u3)
            _reserved_6_6: u1,
            feie: Feie, // FIFO error interrupt enable (u1)
            _padding_8_31: u24,
        };
        pub const st6fcr = mmio(base_address + 0xb4, 32, St6fcr);

        /// address: 0x400260b8
        /// stream x configuration register
        pub const St7cr = packed struct {
            pub const En = enum(u1) {
                disabled = 0, // Stream disabled
                enabled = 1, // Stream enabled
            };
            pub const Dmeie = enum(u1) {
                disabled = 0, // DME interrupt disabled
                enabled = 1, // DME interrupt enabled
            };
            pub const Teie = enum(u1) {
                disabled = 0, // TE interrupt disabled
                enabled = 1, // TE interrupt enabled
            };
            pub const Htie = enum(u1) {
                disabled = 0, // HT interrupt disabled
                enabled = 1, // HT interrupt enabled
            };
            pub const Tcie = enum(u1) {
                disabled = 0, // TC interrupt disabled
                enabled = 1, // TC interrupt enabled
            };
            pub const Pfctrl = enum(u1) {
                dma = 0, // The DMA is the flow controller
                peripheral = 1, // The peripheral is the flow controller
            };
            pub const Dir = enum(u2) {
                peripheral_to_memory = 0b00, // Peripheral-to-memory
                memory_to_peripheral = 0b01, // Memory-to-peripheral
                memory_to_memory = 0b10, // Memory-to-memory
            };
            pub const Circ = enum(u1) {
                disabled = 0, // Circular mode disabled
                enabled = 1, // Circular mode enabled
            };
            pub const Pinc = enum(u1) {
                fixed = 0, // Address pointer is fixed
                incremented = 1, // Address pointer is incremented after each data transfer
            };
            pub const Psize = enum(u2) {
                bits8 = 0b00, // Byte (8-bit)
                bits16 = 0b01, // Half-word (16-bit)
                bits32 = 0b10, // Word (32-bit)
            };
            pub const Pincos = enum(u1) {
                psize = 0, // The offset size for the peripheral address calculation is linked to the PSIZE
                fixed4 = 1, // The offset size for the peripheral address calculation is fixed to 4 (32-bit alignment)
            };
            pub const Pl = enum(u2) {
                low = 0b00, // Low
                medium = 0b01, // Medium
                high = 0b10, // High
                very_high = 0b11, // Very high
            };
            pub const Dbm = enum(u1) {
                disabled = 0, // No buffer switching at the end of transfer
                enabled = 1, // Memory target switched at the end of the DMA transfer
            };
            pub const Ct = enum(u1) {
                memory0 = 0, // The current target memory is Memory 0
                memory1 = 1, // The current target memory is Memory 1
            };
            pub const Pburst = enum(u2) {
                single = 0b00, // Single transfer
                incr4 = 0b01, // Incremental burst of 4 beats
                incr8 = 0b10, // Incremental burst of 8 beats
                incr16 = 0b11, // Incremental burst of 16 beats
            };
            en: En, // Stream enable / flag stream ready when read low (u1)
            dmeie: Dmeie, // Direct mode error interrupt enable (u1)
            teie: Teie, // Transfer error interrupt enable (u1)
            htie: Htie, // Half transfer interrupt enable (u1)
            tcie: Tcie, // Transfer complete interrupt enable (u1)
            pfctrl: Pfctrl, // Peripheral flow controller (u1)
            dir: Dir, // Data transfer direction (u2)
            circ: Circ, // Circular mode (u1)
            pinc: Pinc, // Peripheral increment mode (u1)
            minc: Pinc, // Memory increment mode (u1)
            psize: Psize, // Peripheral data size (u2)
            msize: Psize, // Memory data size (u2)
            pincos: Pincos, // Peripheral increment offset size (u1)
            pl: Pl, // Priority level (u2)
            dbm: Dbm, // Double buffer mode (u1)
            ct: Ct, // Current target (only in double buffer mode) (u1)
            _reserved_20_20: u1,
            pburst: Pburst, // Peripheral burst transfer configuration (u2)
            mburst: Pburst, // Memory burst transfer configuration (u2)
            chsel: u3, // Channel selection
            _padding_28_31: u4,
        };
        pub const st7cr = mmio(base_address + 0xb8, 32, St7cr);

        /// address: 0x400260bc
        /// stream x number of data register
        pub const St7ndtr = packed struct {
            ndt: u16, // Number of data items to transfer
            _padding_16_31: u16,
        };
        pub const st7ndtr = mmio(base_address + 0xbc, 32, St7ndtr);

        /// address: 0x400260c0
        /// stream x peripheral address register
        pub const St7par = packed struct {
            pa: u32, // Peripheral address
        };
        pub const st7par = mmio(base_address + 0xc0, 32, St7par);

        /// address: 0x400260c4
        /// stream x memory 0 address register
        pub const St7m0ar = packed struct {
            m0a: u32, // Memory 0 address
        };
        pub const st7m0ar = mmio(base_address + 0xc4, 32, St7m0ar);

        /// address: 0x400260c8
        /// stream x memory 1 address register
        pub const St7m1ar = packed struct {
            m1a: u32, // Memory 1 address (used in case of Double buffer mode)
        };
        pub const st7m1ar = mmio(base_address + 0xc8, 32, St7m1ar);

        /// address: 0x400260cc
        /// stream x FIFO control register
        pub const St7fcr = packed struct {
            pub const Fth = enum(u2) {
                quarter = 0b00, // 1/4 full FIFO
                half = 0b01, // 1/2 full FIFO
                three_quarters = 0b10, // 3/4 full FIFO
                full = 0b11, // Full FIFO
            };
            pub const Dmdis = enum(u1) {
                enabled = 0, // Direct mode is enabled
                disabled = 1, // Direct mode is disabled
            };
            pub const Fs = enum(u3) {
                quarter1 = 0b000, // 0 < fifo_level < 1/4
                quarter2 = 0b001, // 1/4 <= fifo_level < 1/2
                quarter3 = 0b010, // 1/2 <= fifo_level < 3/4
                quarter4 = 0b011, // 3/4 <= fifo_level < full
                empty = 0b100, // FIFO is empty
                full = 0b101, // FIFO is full
            };
            pub const Feie = enum(u1) {
                disabled = 0, // FE interrupt disabled
                enabled = 1, // FE interrupt enabled
            };
            fth: Fth, // FIFO threshold selection (u2)
            dmdis: Dmdis, // Direct mode disable (u1)
            fs: Fs, // FIFO status (u3)
            _reserved_6_6: u1,
            feie: Feie, // FIFO error interrupt enable (u1)
            _padding_8_31: u24,
        };
        pub const st7fcr = mmio(base_address + 0xcc, 32, St7fcr);
    };
    /// General-purpose I/Os
    pub const gpioh = struct {
        pub const base_address = 0x40021c00;

        /// address: 0x40021c00
        /// GPIO port mode register
        pub const Moder = packed struct {
            pub const Moder0 = enum(u2) {
                input = 0b00, // Input mode (reset state)
                output = 0b01, // General purpose output mode
                alternate = 0b10, // Alternate function mode
                analog = 0b11, // Analog mode
            };
            moder0: Moder0, // Port x configuration bits (y = 0..15) (u2)
            moder1: Moder0, // Port x configuration bits (y = 0..15) (u2)
            moder2: Moder0, // Port x configuration bits (y = 0..15) (u2)
            moder3: Moder0, // Port x configuration bits (y = 0..15) (u2)
            moder4: Moder0, // Port x configuration bits (y = 0..15) (u2)
            moder5: Moder0, // Port x configuration bits (y = 0..15) (u2)
            moder6: Moder0, // Port x configuration bits (y = 0..15) (u2)
            moder7: Moder0, // Port x configuration bits (y = 0..15) (u2)
            moder8: Moder0, // Port x configuration bits (y = 0..15) (u2)
            moder9: Moder0, // Port x configuration bits (y = 0..15) (u2)
            moder10: Moder0, // Port x configuration bits (y = 0..15) (u2)
            moder11: Moder0, // Port x configuration bits (y = 0..15) (u2)
            moder12: Moder0, // Port x configuration bits (y = 0..15) (u2)
            moder13: Moder0, // Port x configuration bits (y = 0..15) (u2)
            moder14: Moder0, // Port x configuration bits (y = 0..15) (u2)
            moder15: Moder0, // Port x configuration bits (y = 0..15) (u2)
        };
        pub const moder = mmio(base_address + 0x0, 32, Moder);

        /// address: 0x40021c04
        /// GPIO port output type register
        pub const Otyper = packed struct {
            pub const Ot0 = enum(u1) {
                push_pull = 0, // Output push-pull (reset state)
                open_drain = 1, // Output open-drain
            };
            ot0: Ot0, // Port x configuration bits (y = 0..15) (u1)
            ot1: Ot0, // Port x configuration bits (y = 0..15) (u1)
            ot2: Ot0, // Port x configuration bits (y = 0..15) (u1)
            ot3: Ot0, // Port x configuration bits (y = 0..15) (u1)
            ot4: Ot0, // Port x configuration bits (y = 0..15) (u1)
            ot5: Ot0, // Port x configuration bits (y = 0..15) (u1)
            ot6: Ot0, // Port x configuration bits (y = 0..15) (u1)
            ot7: Ot0, // Port x configuration bits (y = 0..15) (u1)
            ot8: Ot0, // Port x configuration bits (y = 0..15) (u1)
            ot9: Ot0, // Port x configuration bits (y = 0..15) (u1)
            ot10: Ot0, // Port x configuration bits (y = 0..15) (u1)
            ot11: Ot0, // Port x configuration bits (y = 0..15) (u1)
            ot12: Ot0, // Port x configuration bits (y = 0..15) (u1)
            ot13: Ot0, // Port x configuration bits (y = 0..15) (u1)
            ot14: Ot0, // Port x configuration bits (y = 0..15) (u1)
            ot15: Ot0, // Port x configuration bits (y = 0..15) (u1)
            _padding_16_31: u16,
        };
        pub const otyper = mmio(base_address + 0x4, 32, Otyper);

        /// address: 0x40021c08
        /// GPIO port output speed register
        pub const Ospeedr = packed struct {
            pub const Ospeedr0 = enum(u2) {
                low_speed = 0b00, // Low speed
                medium_speed = 0b01, // Medium speed
                high_speed = 0b10, // High speed
                very_high_speed = 0b11, // Very high speed
            };
            ospeedr0: Ospeedr0, // Port x configuration bits (y = 0..15) (u2)
            ospeedr1: Ospeedr0, // Port x configuration bits (y = 0..15) (u2)
            ospeedr2: Ospeedr0, // Port x configuration bits (y = 0..15) (u2)
            ospeedr3: Ospeedr0, // Port x configuration bits (y = 0..15) (u2)
            ospeedr4: Ospeedr0, // Port x configuration bits (y = 0..15) (u2)
            ospeedr5: Ospeedr0, // Port x configuration bits (y = 0..15) (u2)
            ospeedr6: Ospeedr0, // Port x configuration bits (y = 0..15) (u2)
            ospeedr7: Ospeedr0, // Port x configuration bits (y = 0..15) (u2)
            ospeedr8: Ospeedr0, // Port x configuration bits (y = 0..15) (u2)
            ospeedr9: Ospeedr0, // Port x configuration bits (y = 0..15) (u2)
            ospeedr10: Ospeedr0, // Port x configuration bits (y = 0..15) (u2)
            ospeedr11: Ospeedr0, // Port x configuration bits (y = 0..15) (u2)
            ospeedr12: Ospeedr0, // Port x configuration bits (y = 0..15) (u2)
            ospeedr13: Ospeedr0, // Port x configuration bits (y = 0..15) (u2)
            ospeedr14: Ospeedr0, // Port x configuration bits (y = 0..15) (u2)
            ospeedr15: Ospeedr0, // Port x configuration bits (y = 0..15) (u2)
        };
        pub const ospeedr = mmio(base_address + 0x8, 32, Ospeedr);

        /// address: 0x40021c0c
        /// GPIO port pull-up/pull-down register
        pub const Pupdr = packed struct {
            pub const Pupdr0 = enum(u2) {
                floating = 0b00, // No pull-up, pull-down
                pull_up = 0b01, // Pull-up
                pull_down = 0b10, // Pull-down
            };
            pupdr0: Pupdr0, // Port x configuration bits (y = 0..15) (u2)
            pupdr1: Pupdr0, // Port x configuration bits (y = 0..15) (u2)
            pupdr2: Pupdr0, // Port x configuration bits (y = 0..15) (u2)
            pupdr3: Pupdr0, // Port x configuration bits (y = 0..15) (u2)
            pupdr4: Pupdr0, // Port x configuration bits (y = 0..15) (u2)
            pupdr5: Pupdr0, // Port x configuration bits (y = 0..15) (u2)
            pupdr6: Pupdr0, // Port x configuration bits (y = 0..15) (u2)
            pupdr7: Pupdr0, // Port x configuration bits (y = 0..15) (u2)
            pupdr8: Pupdr0, // Port x configuration bits (y = 0..15) (u2)
            pupdr9: Pupdr0, // Port x configuration bits (y = 0..15) (u2)
            pupdr10: Pupdr0, // Port x configuration bits (y = 0..15) (u2)
            pupdr11: Pupdr0, // Port x configuration bits (y = 0..15) (u2)
            pupdr12: Pupdr0, // Port x configuration bits (y = 0..15) (u2)
            pupdr13: Pupdr0, // Port x configuration bits (y = 0..15) (u2)
            pupdr14: Pupdr0, // Port x configuration bits (y = 0..15) (u2)
            pupdr15: Pupdr0, // Port x configuration bits (y = 0..15) (u2)
        };
        pub const pupdr = mmio(base_address + 0xc, 32, Pupdr);

        /// address: 0x40021c10
        /// GPIO port input data register
        pub const Idr = packed struct {
            pub const Idr0 = enum(u1) {
                high = 1, // Input is logic high
                low = 0, // Input is logic low
            };
            idr0: Idr0, // Port input data (y = 0..15) (u1)
            idr1: Idr0, // Port input data (y = 0..15) (u1)
            idr2: Idr0, // Port input data (y = 0..15) (u1)
            idr3: Idr0, // Port input data (y = 0..15) (u1)
            idr4: Idr0, // Port input data (y = 0..15) (u1)
            idr5: Idr0, // Port input data (y = 0..15) (u1)
            idr6: Idr0, // Port input data (y = 0..15) (u1)
            idr7: Idr0, // Port input data (y = 0..15) (u1)
            idr8: Idr0, // Port input data (y = 0..15) (u1)
            idr9: Idr0, // Port input data (y = 0..15) (u1)
            idr10: Idr0, // Port input data (y = 0..15) (u1)
            idr11: Idr0, // Port input data (y = 0..15) (u1)
            idr12: Idr0, // Port input data (y = 0..15) (u1)
            idr13: Idr0, // Port input data (y = 0..15) (u1)
            idr14: Idr0, // Port input data (y = 0..15) (u1)
            idr15: Idr0, // Port input data (y = 0..15) (u1)
            _padding_16_31: u16,
        };
        pub const idr = mmio(base_address + 0x10, 32, Idr);

        /// address: 0x40021c14
        /// GPIO port output data register
        pub const Odr = packed struct {
            pub const Odr0 = enum(u1) {
                high = 1, // Set output to logic high
                low = 0, // Set output to logic low
            };
            odr0: Odr0, // Port output data (y = 0..15) (u1)
            odr1: Odr0, // Port output data (y = 0..15) (u1)
            odr2: Odr0, // Port output data (y = 0..15) (u1)
            odr3: Odr0, // Port output data (y = 0..15) (u1)
            odr4: Odr0, // Port output data (y = 0..15) (u1)
            odr5: Odr0, // Port output data (y = 0..15) (u1)
            odr6: Odr0, // Port output data (y = 0..15) (u1)
            odr7: Odr0, // Port output data (y = 0..15) (u1)
            odr8: Odr0, // Port output data (y = 0..15) (u1)
            odr9: Odr0, // Port output data (y = 0..15) (u1)
            odr10: Odr0, // Port output data (y = 0..15) (u1)
            odr11: Odr0, // Port output data (y = 0..15) (u1)
            odr12: Odr0, // Port output data (y = 0..15) (u1)
            odr13: Odr0, // Port output data (y = 0..15) (u1)
            odr14: Odr0, // Port output data (y = 0..15) (u1)
            odr15: Odr0, // Port output data (y = 0..15) (u1)
            _padding_16_31: u16,
        };
        pub const odr = mmio(base_address + 0x14, 32, Odr);

        /// address: 0x40021c18
        /// GPIO port bit set/reset register
        pub const Bsrr = packed struct {
            pub const Bs0w = enum(u1) {
                set = 1, // Sets the corresponding ODRx bit
            };
            pub const Br0w = enum(u1) {
                reset = 1, // Resets the corresponding ODRx bit
            };
            bs0: Bs0w, // Port x set bit y (y= 0..15) (u1)
            bs1: Bs0w, // Port x set bit y (y= 0..15) (u1)
            bs2: Bs0w, // Port x set bit y (y= 0..15) (u1)
            bs3: Bs0w, // Port x set bit y (y= 0..15) (u1)
            bs4: Bs0w, // Port x set bit y (y= 0..15) (u1)
            bs5: Bs0w, // Port x set bit y (y= 0..15) (u1)
            bs6: Bs0w, // Port x set bit y (y= 0..15) (u1)
            bs7: Bs0w, // Port x set bit y (y= 0..15) (u1)
            bs8: Bs0w, // Port x set bit y (y= 0..15) (u1)
            bs9: Bs0w, // Port x set bit y (y= 0..15) (u1)
            bs10: Bs0w, // Port x set bit y (y= 0..15) (u1)
            bs11: Bs0w, // Port x set bit y (y= 0..15) (u1)
            bs12: Bs0w, // Port x set bit y (y= 0..15) (u1)
            bs13: Bs0w, // Port x set bit y (y= 0..15) (u1)
            bs14: Bs0w, // Port x set bit y (y= 0..15) (u1)
            bs15: Bs0w, // Port x set bit y (y= 0..15) (u1)
            br0: Br0w, // Port x set bit y (y= 0..15) (u1)
            br1: Br0w, // Port x reset bit y (y = 0..15) (u1)
            br2: Br0w, // Port x reset bit y (y = 0..15) (u1)
            br3: Br0w, // Port x reset bit y (y = 0..15) (u1)
            br4: Br0w, // Port x reset bit y (y = 0..15) (u1)
            br5: Br0w, // Port x reset bit y (y = 0..15) (u1)
            br6: Br0w, // Port x reset bit y (y = 0..15) (u1)
            br7: Br0w, // Port x reset bit y (y = 0..15) (u1)
            br8: Br0w, // Port x reset bit y (y = 0..15) (u1)
            br9: Br0w, // Port x reset bit y (y = 0..15) (u1)
            br10: Br0w, // Port x reset bit y (y = 0..15) (u1)
            br11: Br0w, // Port x reset bit y (y = 0..15) (u1)
            br12: Br0w, // Port x reset bit y (y = 0..15) (u1)
            br13: Br0w, // Port x reset bit y (y = 0..15) (u1)
            br14: Br0w, // Port x reset bit y (y = 0..15) (u1)
            br15: Br0w, // Port x reset bit y (y = 0..15) (u1)
        };
        pub const bsrr = mmio(base_address + 0x18, 32, Bsrr);

        /// address: 0x40021c1c
        /// GPIO port configuration lock register
        pub const Lckr = packed struct {
            pub const Lck0 = enum(u1) {
                unlocked = 0, // Port configuration not locked
                locked = 1, // Port configuration locked
            };
            pub const Lckk = enum(u1) {
                not_active = 0, // Port configuration lock key not active
                active = 1, // Port configuration lock key active
            };
            lck0: Lck0, // Port x lock bit y (y= 0..15) (u1)
            lck1: Lck0, // Port x lock bit y (y= 0..15) (u1)
            lck2: Lck0, // Port x lock bit y (y= 0..15) (u1)
            lck3: Lck0, // Port x lock bit y (y= 0..15) (u1)
            lck4: Lck0, // Port x lock bit y (y= 0..15) (u1)
            lck5: Lck0, // Port x lock bit y (y= 0..15) (u1)
            lck6: Lck0, // Port x lock bit y (y= 0..15) (u1)
            lck7: Lck0, // Port x lock bit y (y= 0..15) (u1)
            lck8: Lck0, // Port x lock bit y (y= 0..15) (u1)
            lck9: Lck0, // Port x lock bit y (y= 0..15) (u1)
            lck10: Lck0, // Port x lock bit y (y= 0..15) (u1)
            lck11: Lck0, // Port x lock bit y (y= 0..15) (u1)
            lck12: Lck0, // Port x lock bit y (y= 0..15) (u1)
            lck13: Lck0, // Port x lock bit y (y= 0..15) (u1)
            lck14: Lck0, // Port x lock bit y (y= 0..15) (u1)
            lck15: Lck0, // Port x lock bit y (y= 0..15) (u1)
            lckk: Lckk, // Port x lock bit y (y= 0..15) (u1)
            _padding_17_31: u15,
        };
        pub const lckr = mmio(base_address + 0x1c, 32, Lckr);

        /// address: 0x40021c20
        /// GPIO alternate function low register
        pub const Afrl = packed struct {
            pub const Afrl0 = enum(u4) {
                af0 = 0b0000, // AF0
                af1 = 0b0001, // AF1
                af2 = 0b0010, // AF2
                af3 = 0b0011, // AF3
                af4 = 0b0100, // AF4
                af5 = 0b0101, // AF5
                af6 = 0b0110, // AF6
                af7 = 0b0111, // AF7
                af8 = 0b1000, // AF8
                af9 = 0b1001, // AF9
                af10 = 0b1010, // AF10
                af11 = 0b1011, // AF11
                af12 = 0b1100, // AF12
                af13 = 0b1101, // AF13
                af14 = 0b1110, // AF14
                af15 = 0b1111, // AF15
            };
            afrl0: Afrl0, // Alternate function selection for port x bit y (y = 0..7) (u4)
            afrl1: Afrl0, // Alternate function selection for port x bit y (y = 0..7) (u4)
            afrl2: Afrl0, // Alternate function selection for port x bit y (y = 0..7) (u4)
            afrl3: Afrl0, // Alternate function selection for port x bit y (y = 0..7) (u4)
            afrl4: Afrl0, // Alternate function selection for port x bit y (y = 0..7) (u4)
            afrl5: Afrl0, // Alternate function selection for port x bit y (y = 0..7) (u4)
            afrl6: Afrl0, // Alternate function selection for port x bit y (y = 0..7) (u4)
            afrl7: Afrl0, // Alternate function selection for port x bit y (y = 0..7) (u4)
        };
        pub const afrl = mmio(base_address + 0x20, 32, Afrl);

        /// address: 0x40021c24
        /// GPIO alternate function high register
        pub const Afrh = packed struct {
            pub const Afrh8 = enum(u4) {
                af0 = 0b0000, // AF0
                af1 = 0b0001, // AF1
                af2 = 0b0010, // AF2
                af3 = 0b0011, // AF3
                af4 = 0b0100, // AF4
                af5 = 0b0101, // AF5
                af6 = 0b0110, // AF6
                af7 = 0b0111, // AF7
                af8 = 0b1000, // AF8
                af9 = 0b1001, // AF9
                af10 = 0b1010, // AF10
                af11 = 0b1011, // AF11
                af12 = 0b1100, // AF12
                af13 = 0b1101, // AF13
                af14 = 0b1110, // AF14
                af15 = 0b1111, // AF15
            };
            afrh8: Afrh8, // Alternate function selection for port x bit y (y = 8..15) (u4)
            afrh9: Afrh8, // Alternate function selection for port x bit y (y = 8..15) (u4)
            afrh10: Afrh8, // Alternate function selection for port x bit y (y = 8..15) (u4)
            afrh11: Afrh8, // Alternate function selection for port x bit y (y = 8..15) (u4)
            afrh12: Afrh8, // Alternate function selection for port x bit y (y = 8..15) (u4)
            afrh13: Afrh8, // Alternate function selection for port x bit y (y = 8..15) (u4)
            afrh14: Afrh8, // Alternate function selection for port x bit y (y = 8..15) (u4)
            afrh15: Afrh8, // Alternate function selection for port x bit y (y = 8..15) (u4)
        };
        pub const afrh = mmio(base_address + 0x24, 32, Afrh);
    };
    /// General-purpose I/Os
    pub const gpiob = struct {
        pub const base_address = 0x40020400;

        /// address: 0x40020400
        /// GPIO port mode register
        pub const Moder = packed struct {
            pub const Moder0 = enum(u2) {
                input = 0b00, // Input mode (reset state)
                output = 0b01, // General purpose output mode
                alternate = 0b10, // Alternate function mode
                analog = 0b11, // Analog mode
            };
            moder0: Moder0, // Port x configuration bits (y = 0..15) (u2)
            moder1: Moder0, // Port x configuration bits (y = 0..15) (u2)
            moder2: Moder0, // Port x configuration bits (y = 0..15) (u2)
            moder3: Moder0, // Port x configuration bits (y = 0..15) (u2)
            moder4: Moder0, // Port x configuration bits (y = 0..15) (u2)
            moder5: Moder0, // Port x configuration bits (y = 0..15) (u2)
            moder6: Moder0, // Port x configuration bits (y = 0..15) (u2)
            moder7: Moder0, // Port x configuration bits (y = 0..15) (u2)
            moder8: Moder0, // Port x configuration bits (y = 0..15) (u2)
            moder9: Moder0, // Port x configuration bits (y = 0..15) (u2)
            moder10: Moder0, // Port x configuration bits (y = 0..15) (u2)
            moder11: Moder0, // Port x configuration bits (y = 0..15) (u2)
            moder12: Moder0, // Port x configuration bits (y = 0..15) (u2)
            moder13: Moder0, // Port x configuration bits (y = 0..15) (u2)
            moder14: Moder0, // Port x configuration bits (y = 0..15) (u2)
            moder15: Moder0, // Port x configuration bits (y = 0..15) (u2)
        };
        pub const moder = mmio(base_address + 0x0, 32, Moder);

        /// address: 0x40020404
        /// GPIO port output type register
        pub const Otyper = packed struct {
            pub const Ot0 = enum(u1) {
                push_pull = 0, // Output push-pull (reset state)
                open_drain = 1, // Output open-drain
            };
            ot0: Ot0, // Port x configuration bits (y = 0..15) (u1)
            ot1: Ot0, // Port x configuration bits (y = 0..15) (u1)
            ot2: Ot0, // Port x configuration bits (y = 0..15) (u1)
            ot3: Ot0, // Port x configuration bits (y = 0..15) (u1)
            ot4: Ot0, // Port x configuration bits (y = 0..15) (u1)
            ot5: Ot0, // Port x configuration bits (y = 0..15) (u1)
            ot6: Ot0, // Port x configuration bits (y = 0..15) (u1)
            ot7: Ot0, // Port x configuration bits (y = 0..15) (u1)
            ot8: Ot0, // Port x configuration bits (y = 0..15) (u1)
            ot9: Ot0, // Port x configuration bits (y = 0..15) (u1)
            ot10: Ot0, // Port x configuration bits (y = 0..15) (u1)
            ot11: Ot0, // Port x configuration bits (y = 0..15) (u1)
            ot12: Ot0, // Port x configuration bits (y = 0..15) (u1)
            ot13: Ot0, // Port x configuration bits (y = 0..15) (u1)
            ot14: Ot0, // Port x configuration bits (y = 0..15) (u1)
            ot15: Ot0, // Port x configuration bits (y = 0..15) (u1)
            _padding_16_31: u16,
        };
        pub const otyper = mmio(base_address + 0x4, 32, Otyper);

        /// address: 0x40020408
        /// GPIO port output speed register
        pub const Ospeedr = packed struct {
            pub const Ospeedr0 = enum(u2) {
                low_speed = 0b00, // Low speed
                medium_speed = 0b01, // Medium speed
                high_speed = 0b10, // High speed
                very_high_speed = 0b11, // Very high speed
            };
            ospeedr0: Ospeedr0, // Port x configuration bits (y = 0..15) (u2)
            ospeedr1: Ospeedr0, // Port x configuration bits (y = 0..15) (u2)
            ospeedr2: Ospeedr0, // Port x configuration bits (y = 0..15) (u2)
            ospeedr3: Ospeedr0, // Port x configuration bits (y = 0..15) (u2)
            ospeedr4: Ospeedr0, // Port x configuration bits (y = 0..15) (u2)
            ospeedr5: Ospeedr0, // Port x configuration bits (y = 0..15) (u2)
            ospeedr6: Ospeedr0, // Port x configuration bits (y = 0..15) (u2)
            ospeedr7: Ospeedr0, // Port x configuration bits (y = 0..15) (u2)
            ospeedr8: Ospeedr0, // Port x configuration bits (y = 0..15) (u2)
            ospeedr9: Ospeedr0, // Port x configuration bits (y = 0..15) (u2)
            ospeedr10: Ospeedr0, // Port x configuration bits (y = 0..15) (u2)
            ospeedr11: Ospeedr0, // Port x configuration bits (y = 0..15) (u2)
            ospeedr12: Ospeedr0, // Port x configuration bits (y = 0..15) (u2)
            ospeedr13: Ospeedr0, // Port x configuration bits (y = 0..15) (u2)
            ospeedr14: Ospeedr0, // Port x configuration bits (y = 0..15) (u2)
            ospeedr15: Ospeedr0, // Port x configuration bits (y = 0..15) (u2)
        };
        pub const ospeedr = mmio(base_address + 0x8, 32, Ospeedr);

        /// address: 0x4002040c
        /// GPIO port pull-up/pull-down register
        pub const Pupdr = packed struct {
            pub const Pupdr0 = enum(u2) {
                floating = 0b00, // No pull-up, pull-down
                pull_up = 0b01, // Pull-up
                pull_down = 0b10, // Pull-down
            };
            pupdr0: Pupdr0, // Port x configuration bits (y = 0..15) (u2)
            pupdr1: Pupdr0, // Port x configuration bits (y = 0..15) (u2)
            pupdr2: Pupdr0, // Port x configuration bits (y = 0..15) (u2)
            pupdr3: Pupdr0, // Port x configuration bits (y = 0..15) (u2)
            pupdr4: Pupdr0, // Port x configuration bits (y = 0..15) (u2)
            pupdr5: Pupdr0, // Port x configuration bits (y = 0..15) (u2)
            pupdr6: Pupdr0, // Port x configuration bits (y = 0..15) (u2)
            pupdr7: Pupdr0, // Port x configuration bits (y = 0..15) (u2)
            pupdr8: Pupdr0, // Port x configuration bits (y = 0..15) (u2)
            pupdr9: Pupdr0, // Port x configuration bits (y = 0..15) (u2)
            pupdr10: Pupdr0, // Port x configuration bits (y = 0..15) (u2)
            pupdr11: Pupdr0, // Port x configuration bits (y = 0..15) (u2)
            pupdr12: Pupdr0, // Port x configuration bits (y = 0..15) (u2)
            pupdr13: Pupdr0, // Port x configuration bits (y = 0..15) (u2)
            pupdr14: Pupdr0, // Port x configuration bits (y = 0..15) (u2)
            pupdr15: Pupdr0, // Port x configuration bits (y = 0..15) (u2)
        };
        pub const pupdr = mmio(base_address + 0xc, 32, Pupdr);

        /// address: 0x40020410
        /// GPIO port input data register
        pub const Idr = packed struct {
            pub const Idr0 = enum(u1) {
                high = 1, // Input is logic high
                low = 0, // Input is logic low
            };
            idr0: Idr0, // Port input data (y = 0..15) (u1)
            idr1: Idr0, // Port input data (y = 0..15) (u1)
            idr2: Idr0, // Port input data (y = 0..15) (u1)
            idr3: Idr0, // Port input data (y = 0..15) (u1)
            idr4: Idr0, // Port input data (y = 0..15) (u1)
            idr5: Idr0, // Port input data (y = 0..15) (u1)
            idr6: Idr0, // Port input data (y = 0..15) (u1)
            idr7: Idr0, // Port input data (y = 0..15) (u1)
            idr8: Idr0, // Port input data (y = 0..15) (u1)
            idr9: Idr0, // Port input data (y = 0..15) (u1)
            idr10: Idr0, // Port input data (y = 0..15) (u1)
            idr11: Idr0, // Port input data (y = 0..15) (u1)
            idr12: Idr0, // Port input data (y = 0..15) (u1)
            idr13: Idr0, // Port input data (y = 0..15) (u1)
            idr14: Idr0, // Port input data (y = 0..15) (u1)
            idr15: Idr0, // Port input data (y = 0..15) (u1)
            _padding_16_31: u16,
        };
        pub const idr = mmio(base_address + 0x10, 32, Idr);

        /// address: 0x40020414
        /// GPIO port output data register
        pub const Odr = packed struct {
            pub const Odr0 = enum(u1) {
                high = 1, // Set output to logic high
                low = 0, // Set output to logic low
            };
            odr0: Odr0, // Port output data (y = 0..15) (u1)
            odr1: Odr0, // Port output data (y = 0..15) (u1)
            odr2: Odr0, // Port output data (y = 0..15) (u1)
            odr3: Odr0, // Port output data (y = 0..15) (u1)
            odr4: Odr0, // Port output data (y = 0..15) (u1)
            odr5: Odr0, // Port output data (y = 0..15) (u1)
            odr6: Odr0, // Port output data (y = 0..15) (u1)
            odr7: Odr0, // Port output data (y = 0..15) (u1)
            odr8: Odr0, // Port output data (y = 0..15) (u1)
            odr9: Odr0, // Port output data (y = 0..15) (u1)
            odr10: Odr0, // Port output data (y = 0..15) (u1)
            odr11: Odr0, // Port output data (y = 0..15) (u1)
            odr12: Odr0, // Port output data (y = 0..15) (u1)
            odr13: Odr0, // Port output data (y = 0..15) (u1)
            odr14: Odr0, // Port output data (y = 0..15) (u1)
            odr15: Odr0, // Port output data (y = 0..15) (u1)
            _padding_16_31: u16,
        };
        pub const odr = mmio(base_address + 0x14, 32, Odr);

        /// address: 0x40020418
        /// GPIO port bit set/reset register
        pub const Bsrr = packed struct {
            pub const Bs0w = enum(u1) {
                set = 1, // Sets the corresponding ODRx bit
            };
            pub const Br0w = enum(u1) {
                reset = 1, // Resets the corresponding ODRx bit
            };
            bs0: Bs0w, // Port x set bit y (y= 0..15) (u1)
            bs1: Bs0w, // Port x set bit y (y= 0..15) (u1)
            bs2: Bs0w, // Port x set bit y (y= 0..15) (u1)
            bs3: Bs0w, // Port x set bit y (y= 0..15) (u1)
            bs4: Bs0w, // Port x set bit y (y= 0..15) (u1)
            bs5: Bs0w, // Port x set bit y (y= 0..15) (u1)
            bs6: Bs0w, // Port x set bit y (y= 0..15) (u1)
            bs7: Bs0w, // Port x set bit y (y= 0..15) (u1)
            bs8: Bs0w, // Port x set bit y (y= 0..15) (u1)
            bs9: Bs0w, // Port x set bit y (y= 0..15) (u1)
            bs10: Bs0w, // Port x set bit y (y= 0..15) (u1)
            bs11: Bs0w, // Port x set bit y (y= 0..15) (u1)
            bs12: Bs0w, // Port x set bit y (y= 0..15) (u1)
            bs13: Bs0w, // Port x set bit y (y= 0..15) (u1)
            bs14: Bs0w, // Port x set bit y (y= 0..15) (u1)
            bs15: Bs0w, // Port x set bit y (y= 0..15) (u1)
            br0: Br0w, // Port x set bit y (y= 0..15) (u1)
            br1: Br0w, // Port x reset bit y (y = 0..15) (u1)
            br2: Br0w, // Port x reset bit y (y = 0..15) (u1)
            br3: Br0w, // Port x reset bit y (y = 0..15) (u1)
            br4: Br0w, // Port x reset bit y (y = 0..15) (u1)
            br5: Br0w, // Port x reset bit y (y = 0..15) (u1)
            br6: Br0w, // Port x reset bit y (y = 0..15) (u1)
            br7: Br0w, // Port x reset bit y (y = 0..15) (u1)
            br8: Br0w, // Port x reset bit y (y = 0..15) (u1)
            br9: Br0w, // Port x reset bit y (y = 0..15) (u1)
            br10: Br0w, // Port x reset bit y (y = 0..15) (u1)
            br11: Br0w, // Port x reset bit y (y = 0..15) (u1)
            br12: Br0w, // Port x reset bit y (y = 0..15) (u1)
            br13: Br0w, // Port x reset bit y (y = 0..15) (u1)
            br14: Br0w, // Port x reset bit y (y = 0..15) (u1)
            br15: Br0w, // Port x reset bit y (y = 0..15) (u1)
        };
        pub const bsrr = mmio(base_address + 0x18, 32, Bsrr);

        /// address: 0x4002041c
        /// GPIO port configuration lock register
        pub const Lckr = packed struct {
            pub const Lck0 = enum(u1) {
                unlocked = 0, // Port configuration not locked
                locked = 1, // Port configuration locked
            };
            pub const Lckk = enum(u1) {
                not_active = 0, // Port configuration lock key not active
                active = 1, // Port configuration lock key active
            };
            lck0: Lck0, // Port x lock bit y (y= 0..15) (u1)
            lck1: Lck0, // Port x lock bit y (y= 0..15) (u1)
            lck2: Lck0, // Port x lock bit y (y= 0..15) (u1)
            lck3: Lck0, // Port x lock bit y (y= 0..15) (u1)
            lck4: Lck0, // Port x lock bit y (y= 0..15) (u1)
            lck5: Lck0, // Port x lock bit y (y= 0..15) (u1)
            lck6: Lck0, // Port x lock bit y (y= 0..15) (u1)
            lck7: Lck0, // Port x lock bit y (y= 0..15) (u1)
            lck8: Lck0, // Port x lock bit y (y= 0..15) (u1)
            lck9: Lck0, // Port x lock bit y (y= 0..15) (u1)
            lck10: Lck0, // Port x lock bit y (y= 0..15) (u1)
            lck11: Lck0, // Port x lock bit y (y= 0..15) (u1)
            lck12: Lck0, // Port x lock bit y (y= 0..15) (u1)
            lck13: Lck0, // Port x lock bit y (y= 0..15) (u1)
            lck14: Lck0, // Port x lock bit y (y= 0..15) (u1)
            lck15: Lck0, // Port x lock bit y (y= 0..15) (u1)
            lckk: Lckk, // Port x lock bit y (y= 0..15) (u1)
            _padding_17_31: u15,
        };
        pub const lckr = mmio(base_address + 0x1c, 32, Lckr);

        /// address: 0x40020420
        /// GPIO alternate function low register
        pub const Afrl = packed struct {
            pub const Afrl0 = enum(u4) {
                af0 = 0b0000, // AF0
                af1 = 0b0001, // AF1
                af2 = 0b0010, // AF2
                af3 = 0b0011, // AF3
                af4 = 0b0100, // AF4
                af5 = 0b0101, // AF5
                af6 = 0b0110, // AF6
                af7 = 0b0111, // AF7
                af8 = 0b1000, // AF8
                af9 = 0b1001, // AF9
                af10 = 0b1010, // AF10
                af11 = 0b1011, // AF11
                af12 = 0b1100, // AF12
                af13 = 0b1101, // AF13
                af14 = 0b1110, // AF14
                af15 = 0b1111, // AF15
            };
            afrl0: Afrl0, // Alternate function selection for port x bit y (y = 0..7) (u4)
            afrl1: Afrl0, // Alternate function selection for port x bit y (y = 0..7) (u4)
            afrl2: Afrl0, // Alternate function selection for port x bit y (y = 0..7) (u4)
            afrl3: Afrl0, // Alternate function selection for port x bit y (y = 0..7) (u4)
            afrl4: Afrl0, // Alternate function selection for port x bit y (y = 0..7) (u4)
            afrl5: Afrl0, // Alternate function selection for port x bit y (y = 0..7) (u4)
            afrl6: Afrl0, // Alternate function selection for port x bit y (y = 0..7) (u4)
            afrl7: Afrl0, // Alternate function selection for port x bit y (y = 0..7) (u4)
        };
        pub const afrl = mmio(base_address + 0x20, 32, Afrl);

        /// address: 0x40020424
        /// GPIO alternate function high register
        pub const Afrh = packed struct {
            pub const Afrh8 = enum(u4) {
                af0 = 0b0000, // AF0
                af1 = 0b0001, // AF1
                af2 = 0b0010, // AF2
                af3 = 0b0011, // AF3
                af4 = 0b0100, // AF4
                af5 = 0b0101, // AF5
                af6 = 0b0110, // AF6
                af7 = 0b0111, // AF7
                af8 = 0b1000, // AF8
                af9 = 0b1001, // AF9
                af10 = 0b1010, // AF10
                af11 = 0b1011, // AF11
                af12 = 0b1100, // AF12
                af13 = 0b1101, // AF13
                af14 = 0b1110, // AF14
                af15 = 0b1111, // AF15
            };
            afrh8: Afrh8, // Alternate function selection for port x bit y (y = 8..15) (u4)
            afrh9: Afrh8, // Alternate function selection for port x bit y (y = 8..15) (u4)
            afrh10: Afrh8, // Alternate function selection for port x bit y (y = 8..15) (u4)
            afrh11: Afrh8, // Alternate function selection for port x bit y (y = 8..15) (u4)
            afrh12: Afrh8, // Alternate function selection for port x bit y (y = 8..15) (u4)
            afrh13: Afrh8, // Alternate function selection for port x bit y (y = 8..15) (u4)
            afrh14: Afrh8, // Alternate function selection for port x bit y (y = 8..15) (u4)
            afrh15: Afrh8, // Alternate function selection for port x bit y (y = 8..15) (u4)
        };
        pub const afrh = mmio(base_address + 0x24, 32, Afrh);
    };
    /// General-purpose I/Os
    pub const gpioa = struct {
        pub const base_address = 0x40020000;

        /// address: 0x40020000
        /// GPIO port mode register
        pub const Moder = packed struct {
            pub const Moder0 = enum(u2) {
                input = 0b00, // Input mode (reset state)
                output = 0b01, // General purpose output mode
                alternate = 0b10, // Alternate function mode
                analog = 0b11, // Analog mode
            };
            moder0: Moder0, // Port x configuration bits (y = 0..15) (u2)
            moder1: Moder0, // Port x configuration bits (y = 0..15) (u2)
            moder2: Moder0, // Port x configuration bits (y = 0..15) (u2)
            moder3: Moder0, // Port x configuration bits (y = 0..15) (u2)
            moder4: Moder0, // Port x configuration bits (y = 0..15) (u2)
            moder5: Moder0, // Port x configuration bits (y = 0..15) (u2)
            moder6: Moder0, // Port x configuration bits (y = 0..15) (u2)
            moder7: Moder0, // Port x configuration bits (y = 0..15) (u2)
            moder8: Moder0, // Port x configuration bits (y = 0..15) (u2)
            moder9: Moder0, // Port x configuration bits (y = 0..15) (u2)
            moder10: Moder0, // Port x configuration bits (y = 0..15) (u2)
            moder11: Moder0, // Port x configuration bits (y = 0..15) (u2)
            moder12: Moder0, // Port x configuration bits (y = 0..15) (u2)
            moder13: Moder0, // Port x configuration bits (y = 0..15) (u2)
            moder14: Moder0, // Port x configuration bits (y = 0..15) (u2)
            moder15: Moder0, // Port x configuration bits (y = 0..15) (u2)
        };
        pub const moder = mmio(base_address + 0x0, 32, Moder);

        /// address: 0x40020004
        /// GPIO port output type register
        pub const Otyper = packed struct {
            pub const Ot0 = enum(u1) {
                push_pull = 0, // Output push-pull (reset state)
                open_drain = 1, // Output open-drain
            };
            ot0: Ot0, // Port x configuration bits (y = 0..15) (u1)
            ot1: Ot0, // Port x configuration bits (y = 0..15) (u1)
            ot2: Ot0, // Port x configuration bits (y = 0..15) (u1)
            ot3: Ot0, // Port x configuration bits (y = 0..15) (u1)
            ot4: Ot0, // Port x configuration bits (y = 0..15) (u1)
            ot5: Ot0, // Port x configuration bits (y = 0..15) (u1)
            ot6: Ot0, // Port x configuration bits (y = 0..15) (u1)
            ot7: Ot0, // Port x configuration bits (y = 0..15) (u1)
            ot8: Ot0, // Port x configuration bits (y = 0..15) (u1)
            ot9: Ot0, // Port x configuration bits (y = 0..15) (u1)
            ot10: Ot0, // Port x configuration bits (y = 0..15) (u1)
            ot11: Ot0, // Port x configuration bits (y = 0..15) (u1)
            ot12: Ot0, // Port x configuration bits (y = 0..15) (u1)
            ot13: Ot0, // Port x configuration bits (y = 0..15) (u1)
            ot14: Ot0, // Port x configuration bits (y = 0..15) (u1)
            ot15: Ot0, // Port x configuration bits (y = 0..15) (u1)
            _padding_16_31: u16,
        };
        pub const otyper = mmio(base_address + 0x4, 32, Otyper);

        /// address: 0x40020008
        /// GPIO port output speed register
        pub const Ospeedr = packed struct {
            pub const Ospeedr0 = enum(u2) {
                low_speed = 0b00, // Low speed
                medium_speed = 0b01, // Medium speed
                high_speed = 0b10, // High speed
                very_high_speed = 0b11, // Very high speed
            };
            ospeedr0: Ospeedr0, // Port x configuration bits (y = 0..15) (u2)
            ospeedr1: Ospeedr0, // Port x configuration bits (y = 0..15) (u2)
            ospeedr2: Ospeedr0, // Port x configuration bits (y = 0..15) (u2)
            ospeedr3: Ospeedr0, // Port x configuration bits (y = 0..15) (u2)
            ospeedr4: Ospeedr0, // Port x configuration bits (y = 0..15) (u2)
            ospeedr5: Ospeedr0, // Port x configuration bits (y = 0..15) (u2)
            ospeedr6: Ospeedr0, // Port x configuration bits (y = 0..15) (u2)
            ospeedr7: Ospeedr0, // Port x configuration bits (y = 0..15) (u2)
            ospeedr8: Ospeedr0, // Port x configuration bits (y = 0..15) (u2)
            ospeedr9: Ospeedr0, // Port x configuration bits (y = 0..15) (u2)
            ospeedr10: Ospeedr0, // Port x configuration bits (y = 0..15) (u2)
            ospeedr11: Ospeedr0, // Port x configuration bits (y = 0..15) (u2)
            ospeedr12: Ospeedr0, // Port x configuration bits (y = 0..15) (u2)
            ospeedr13: Ospeedr0, // Port x configuration bits (y = 0..15) (u2)
            ospeedr14: Ospeedr0, // Port x configuration bits (y = 0..15) (u2)
            ospeedr15: Ospeedr0, // Port x configuration bits (y = 0..15) (u2)
        };
        pub const ospeedr = mmio(base_address + 0x8, 32, Ospeedr);

        /// address: 0x4002000c
        /// GPIO port pull-up/pull-down register
        pub const Pupdr = packed struct {
            pub const Pupdr0 = enum(u2) {
                floating = 0b00, // No pull-up, pull-down
                pull_up = 0b01, // Pull-up
                pull_down = 0b10, // Pull-down
            };
            pupdr0: Pupdr0, // Port x configuration bits (y = 0..15) (u2)
            pupdr1: Pupdr0, // Port x configuration bits (y = 0..15) (u2)
            pupdr2: Pupdr0, // Port x configuration bits (y = 0..15) (u2)
            pupdr3: Pupdr0, // Port x configuration bits (y = 0..15) (u2)
            pupdr4: Pupdr0, // Port x configuration bits (y = 0..15) (u2)
            pupdr5: Pupdr0, // Port x configuration bits (y = 0..15) (u2)
            pupdr6: Pupdr0, // Port x configuration bits (y = 0..15) (u2)
            pupdr7: Pupdr0, // Port x configuration bits (y = 0..15) (u2)
            pupdr8: Pupdr0, // Port x configuration bits (y = 0..15) (u2)
            pupdr9: Pupdr0, // Port x configuration bits (y = 0..15) (u2)
            pupdr10: Pupdr0, // Port x configuration bits (y = 0..15) (u2)
            pupdr11: Pupdr0, // Port x configuration bits (y = 0..15) (u2)
            pupdr12: Pupdr0, // Port x configuration bits (y = 0..15) (u2)
            pupdr13: Pupdr0, // Port x configuration bits (y = 0..15) (u2)
            pupdr14: Pupdr0, // Port x configuration bits (y = 0..15) (u2)
            pupdr15: Pupdr0, // Port x configuration bits (y = 0..15) (u2)
        };
        pub const pupdr = mmio(base_address + 0xc, 32, Pupdr);

        /// address: 0x40020010
        /// GPIO port input data register
        pub const Idr = packed struct {
            pub const Idr0 = enum(u1) {
                high = 1, // Input is logic high
                low = 0, // Input is logic low
            };
            idr0: Idr0, // Port input data (y = 0..15) (u1)
            idr1: Idr0, // Port input data (y = 0..15) (u1)
            idr2: Idr0, // Port input data (y = 0..15) (u1)
            idr3: Idr0, // Port input data (y = 0..15) (u1)
            idr4: Idr0, // Port input data (y = 0..15) (u1)
            idr5: Idr0, // Port input data (y = 0..15) (u1)
            idr6: Idr0, // Port input data (y = 0..15) (u1)
            idr7: Idr0, // Port input data (y = 0..15) (u1)
            idr8: Idr0, // Port input data (y = 0..15) (u1)
            idr9: Idr0, // Port input data (y = 0..15) (u1)
            idr10: Idr0, // Port input data (y = 0..15) (u1)
            idr11: Idr0, // Port input data (y = 0..15) (u1)
            idr12: Idr0, // Port input data (y = 0..15) (u1)
            idr13: Idr0, // Port input data (y = 0..15) (u1)
            idr14: Idr0, // Port input data (y = 0..15) (u1)
            idr15: Idr0, // Port input data (y = 0..15) (u1)
            _padding_16_31: u16,
        };
        pub const idr = mmio(base_address + 0x10, 32, Idr);

        /// address: 0x40020014
        /// GPIO port output data register
        pub const Odr = packed struct {
            pub const Odr0 = enum(u1) {
                high = 1, // Set output to logic high
                low = 0, // Set output to logic low
            };
            odr0: Odr0, // Port output data (y = 0..15) (u1)
            odr1: Odr0, // Port output data (y = 0..15) (u1)
            odr2: Odr0, // Port output data (y = 0..15) (u1)
            odr3: Odr0, // Port output data (y = 0..15) (u1)
            odr4: Odr0, // Port output data (y = 0..15) (u1)
            odr5: Odr0, // Port output data (y = 0..15) (u1)
            odr6: Odr0, // Port output data (y = 0..15) (u1)
            odr7: Odr0, // Port output data (y = 0..15) (u1)
            odr8: Odr0, // Port output data (y = 0..15) (u1)
            odr9: Odr0, // Port output data (y = 0..15) (u1)
            odr10: Odr0, // Port output data (y = 0..15) (u1)
            odr11: Odr0, // Port output data (y = 0..15) (u1)
            odr12: Odr0, // Port output data (y = 0..15) (u1)
            odr13: Odr0, // Port output data (y = 0..15) (u1)
            odr14: Odr0, // Port output data (y = 0..15) (u1)
            odr15: Odr0, // Port output data (y = 0..15) (u1)
            _padding_16_31: u16,
        };
        pub const odr = mmio(base_address + 0x14, 32, Odr);

        /// address: 0x40020018
        /// GPIO port bit set/reset register
        pub const Bsrr = packed struct {
            pub const Bs0w = enum(u1) {
                set = 1, // Sets the corresponding ODRx bit
            };
            pub const Br0w = enum(u1) {
                reset = 1, // Resets the corresponding ODRx bit
            };
            bs0: Bs0w, // Port x set bit y (y= 0..15) (u1)
            bs1: Bs0w, // Port x set bit y (y= 0..15) (u1)
            bs2: Bs0w, // Port x set bit y (y= 0..15) (u1)
            bs3: Bs0w, // Port x set bit y (y= 0..15) (u1)
            bs4: Bs0w, // Port x set bit y (y= 0..15) (u1)
            bs5: Bs0w, // Port x set bit y (y= 0..15) (u1)
            bs6: Bs0w, // Port x set bit y (y= 0..15) (u1)
            bs7: Bs0w, // Port x set bit y (y= 0..15) (u1)
            bs8: Bs0w, // Port x set bit y (y= 0..15) (u1)
            bs9: Bs0w, // Port x set bit y (y= 0..15) (u1)
            bs10: Bs0w, // Port x set bit y (y= 0..15) (u1)
            bs11: Bs0w, // Port x set bit y (y= 0..15) (u1)
            bs12: Bs0w, // Port x set bit y (y= 0..15) (u1)
            bs13: Bs0w, // Port x set bit y (y= 0..15) (u1)
            bs14: Bs0w, // Port x set bit y (y= 0..15) (u1)
            bs15: Bs0w, // Port x set bit y (y= 0..15) (u1)
            br0: Br0w, // Port x set bit y (y= 0..15) (u1)
            br1: Br0w, // Port x reset bit y (y = 0..15) (u1)
            br2: Br0w, // Port x reset bit y (y = 0..15) (u1)
            br3: Br0w, // Port x reset bit y (y = 0..15) (u1)
            br4: Br0w, // Port x reset bit y (y = 0..15) (u1)
            br5: Br0w, // Port x reset bit y (y = 0..15) (u1)
            br6: Br0w, // Port x reset bit y (y = 0..15) (u1)
            br7: Br0w, // Port x reset bit y (y = 0..15) (u1)
            br8: Br0w, // Port x reset bit y (y = 0..15) (u1)
            br9: Br0w, // Port x reset bit y (y = 0..15) (u1)
            br10: Br0w, // Port x reset bit y (y = 0..15) (u1)
            br11: Br0w, // Port x reset bit y (y = 0..15) (u1)
            br12: Br0w, // Port x reset bit y (y = 0..15) (u1)
            br13: Br0w, // Port x reset bit y (y = 0..15) (u1)
            br14: Br0w, // Port x reset bit y (y = 0..15) (u1)
            br15: Br0w, // Port x reset bit y (y = 0..15) (u1)
        };
        pub const bsrr = mmio(base_address + 0x18, 32, Bsrr);

        /// address: 0x4002001c
        /// GPIO port configuration lock register
        pub const Lckr = packed struct {
            pub const Lck0 = enum(u1) {
                unlocked = 0, // Port configuration not locked
                locked = 1, // Port configuration locked
            };
            pub const Lckk = enum(u1) {
                not_active = 0, // Port configuration lock key not active
                active = 1, // Port configuration lock key active
            };
            lck0: Lck0, // Port x lock bit y (y= 0..15) (u1)
            lck1: Lck0, // Port x lock bit y (y= 0..15) (u1)
            lck2: Lck0, // Port x lock bit y (y= 0..15) (u1)
            lck3: Lck0, // Port x lock bit y (y= 0..15) (u1)
            lck4: Lck0, // Port x lock bit y (y= 0..15) (u1)
            lck5: Lck0, // Port x lock bit y (y= 0..15) (u1)
            lck6: Lck0, // Port x lock bit y (y= 0..15) (u1)
            lck7: Lck0, // Port x lock bit y (y= 0..15) (u1)
            lck8: Lck0, // Port x lock bit y (y= 0..15) (u1)
            lck9: Lck0, // Port x lock bit y (y= 0..15) (u1)
            lck10: Lck0, // Port x lock bit y (y= 0..15) (u1)
            lck11: Lck0, // Port x lock bit y (y= 0..15) (u1)
            lck12: Lck0, // Port x lock bit y (y= 0..15) (u1)
            lck13: Lck0, // Port x lock bit y (y= 0..15) (u1)
            lck14: Lck0, // Port x lock bit y (y= 0..15) (u1)
            lck15: Lck0, // Port x lock bit y (y= 0..15) (u1)
            lckk: Lckk, // Port x lock bit y (y= 0..15) (u1)
            _padding_17_31: u15,
        };
        pub const lckr = mmio(base_address + 0x1c, 32, Lckr);

        /// address: 0x40020020
        /// GPIO alternate function low register
        pub const Afrl = packed struct {
            pub const Afrl0 = enum(u4) {
                af0 = 0b0000, // AF0
                af1 = 0b0001, // AF1
                af2 = 0b0010, // AF2
                af3 = 0b0011, // AF3
                af4 = 0b0100, // AF4
                af5 = 0b0101, // AF5
                af6 = 0b0110, // AF6
                af7 = 0b0111, // AF7
                af8 = 0b1000, // AF8
                af9 = 0b1001, // AF9
                af10 = 0b1010, // AF10
                af11 = 0b1011, // AF11
                af12 = 0b1100, // AF12
                af13 = 0b1101, // AF13
                af14 = 0b1110, // AF14
                af15 = 0b1111, // AF15
            };
            afrl0: Afrl0, // Alternate function selection for port x bit y (y = 0..7) (u4)
            afrl1: Afrl0, // Alternate function selection for port x bit y (y = 0..7) (u4)
            afrl2: Afrl0, // Alternate function selection for port x bit y (y = 0..7) (u4)
            afrl3: Afrl0, // Alternate function selection for port x bit y (y = 0..7) (u4)
            afrl4: Afrl0, // Alternate function selection for port x bit y (y = 0..7) (u4)
            afrl5: Afrl0, // Alternate function selection for port x bit y (y = 0..7) (u4)
            afrl6: Afrl0, // Alternate function selection for port x bit y (y = 0..7) (u4)
            afrl7: Afrl0, // Alternate function selection for port x bit y (y = 0..7) (u4)
        };
        pub const afrl = mmio(base_address + 0x20, 32, Afrl);

        /// address: 0x40020024
        /// GPIO alternate function high register
        pub const Afrh = packed struct {
            pub const Afrh8 = enum(u4) {
                af0 = 0b0000, // AF0
                af1 = 0b0001, // AF1
                af2 = 0b0010, // AF2
                af3 = 0b0011, // AF3
                af4 = 0b0100, // AF4
                af5 = 0b0101, // AF5
                af6 = 0b0110, // AF6
                af7 = 0b0111, // AF7
                af8 = 0b1000, // AF8
                af9 = 0b1001, // AF9
                af10 = 0b1010, // AF10
                af11 = 0b1011, // AF11
                af12 = 0b1100, // AF12
                af13 = 0b1101, // AF13
                af14 = 0b1110, // AF14
                af15 = 0b1111, // AF15
            };
            afrh8: Afrh8, // Alternate function selection for port x bit y (y = 8..15) (u4)
            afrh9: Afrh8, // Alternate function selection for port x bit y (y = 8..15) (u4)
            afrh10: Afrh8, // Alternate function selection for port x bit y (y = 8..15) (u4)
            afrh11: Afrh8, // Alternate function selection for port x bit y (y = 8..15) (u4)
            afrh12: Afrh8, // Alternate function selection for port x bit y (y = 8..15) (u4)
            afrh13: Afrh8, // Alternate function selection for port x bit y (y = 8..15) (u4)
            afrh14: Afrh8, // Alternate function selection for port x bit y (y = 8..15) (u4)
            afrh15: Afrh8, // Alternate function selection for port x bit y (y = 8..15) (u4)
        };
        pub const afrh = mmio(base_address + 0x24, 32, Afrh);
    };
    /// Inter-integrated circuit
    pub const i2c1 = struct {
        pub const base_address = 0x40005400;

        /// address: 0x40005400
        /// Control register 1
        pub const Cr1 = packed struct {
            pub const Pe = enum(u1) {
                disabled = 0, // Peripheral disabled
                enabled = 1, // Peripheral enabled
            };
            pub const Smbus = enum(u1) {
                i2_c = 0, // I2C Mode
                sm_bus = 1, // SMBus
            };
            pub const Smbtype = enum(u1) {
                device = 0, // SMBus Device
                host = 1, // SMBus Host
            };
            pub const Enarp = enum(u1) {
                disabled = 0, // ARP disabled
                enabled = 1, // ARP enabled
            };
            pub const Enpec = enum(u1) {
                disabled = 0, // PEC calculation disabled
                enabled = 1, // PEC calculation enabled
            };
            pub const Engc = enum(u1) {
                disabled = 0, // General call disabled
                enabled = 1, // General call enabled
            };
            pub const Nostretch = enum(u1) {
                enabled = 0, // Clock stretching enabled
                disabled = 1, // Clock stretching disabled
            };
            pub const Start = enum(u1) {
                no_start = 0, // No Start generation
                start = 1, // In master mode: repeated start generation, in slave mode: start generation when bus is free
            };
            pub const Stop = enum(u1) {
                no_stop = 0, // No Stop generation
                stop = 1, // In master mode: stop generation after current byte/start, in slave mode: release SCL and SDA after current byte
            };
            pub const Ack = enum(u1) {
                nak = 0, // No acknowledge returned
                ack = 1, // Acknowledge returned after a byte is received
            };
            pub const Pos = enum(u1) {
                current = 0, // ACK bit controls the (N)ACK of the current byte being received
                next = 1, // ACK bit controls the (N)ACK of the next byte to be received
            };
            pub const Pec = enum(u1) {
                disabled = 0, // No PEC transfer
                enabled = 1, // PEC transfer
            };
            pub const Alert = enum(u1) {
                release = 0, // SMBA pin released high
                drive = 1, // SMBA pin driven low
            };
            pub const Swrst = enum(u1) {
                not_reset = 0, // I2C peripheral not under reset
                reset = 1, // I2C peripheral under reset
            };
            pe: Pe, // Peripheral enable (u1)
            smbus: Smbus, // SMBus mode (u1)
            _reserved_2_2: u1,
            smbtype: Smbtype, // SMBus type (u1)
            enarp: Enarp, // ARP enable (u1)
            enpec: Enpec, // PEC enable (u1)
            engc: Engc, // General call enable (u1)
            nostretch: Nostretch, // Clock stretching disable (Slave mode) (u1)
            start: Start, // Start generation (u1)
            stop: Stop, // Stop generation (u1)
            ack: Ack, // Acknowledge enable (u1)
            pos: Pos, // Acknowledge/PEC Position (for data reception) (u1)
            pec: Pec, // Packet error checking (u1)
            alert: Alert, // SMBus alert (u1)
            _reserved_14_14: u1,
            swrst: Swrst, // Software reset (u1)
            _padding_16_31: u16,
        };
        pub const cr1 = mmio(base_address + 0x0, 32, Cr1);

        /// address: 0x40005404
        /// Control register 2
        pub const Cr2 = packed struct {
            pub const Iterren = enum(u1) {
                disabled = 0, // Error interrupt disabled
                enabled = 1, // Error interrupt enabled
            };
            pub const Itevten = enum(u1) {
                disabled = 0, // Event interrupt disabled
                enabled = 1, // Event interrupt enabled
            };
            pub const Itbufen = enum(u1) {
                disabled = 0, // TxE=1 or RxNE=1 does not generate any interrupt
                enabled = 1, // TxE=1 or RxNE=1 generates Event interrupt
            };
            pub const Dmaen = enum(u1) {
                disabled = 0, // DMA requests disabled
                enabled = 1, // DMA request enabled when TxE=1 or RxNE=1
            };
            pub const Last = enum(u1) {
                not_last = 0, // Next DMA EOT is not the last transfer
                last = 1, // Next DMA EOT is the last transfer
            };
            freq: u6, // Peripheral clock frequency
            _reserved_6_7: u2,
            iterren: Iterren, // Error interrupt enable (u1)
            itevten: Itevten, // Event interrupt enable (u1)
            itbufen: Itbufen, // Buffer interrupt enable (u1)
            dmaen: Dmaen, // DMA requests enable (u1)
            last: Last, // DMA last transfer (u1)
            _padding_13_31: u19,
        };
        pub const cr2 = mmio(base_address + 0x4, 32, Cr2);

        /// address: 0x40005408
        /// Own address register 1
        pub const Oar1 = packed struct {
            pub const Addmode = enum(u1) {
                add7 = 0, // 7-bit slave address
                add10 = 1, // 10-bit slave address
            };
            add: u10, // Interface address
            _reserved_10_14: u5,
            addmode: Addmode, // Addressing mode (slave mode) (u1)
            _padding_16_31: u16,
        };
        pub const oar1 = mmio(base_address + 0x8, 32, Oar1);

        /// address: 0x4000540c
        /// Own address register 2
        pub const Oar2 = packed struct {
            pub const Endual = enum(u1) {
                single = 0, // Single addressing mode
                dual = 1, // Dual addressing mode
            };
            endual: Endual, // Dual addressing mode enable (u1)
            add2: u7, // Interface address
            _padding_8_31: u24,
        };
        pub const oar2 = mmio(base_address + 0xc, 32, Oar2);

        /// address: 0x40005410
        /// Data register
        pub const dr = mmioInt(base_address + 0x10, 32, u8);

        /// address: 0x40005414
        /// Status register 1
        pub const Sr1 = packed struct {
            pub const Sb = enum(u1) {
                no_start = 0, // No Start condition
                start = 1, // Start condition generated
            };
            pub const Addr = enum(u1) {
                not_match = 0, // Adress mismatched or not received
                match = 1, // Received slave address matched with one of the enabled slave addresses
            };
            pub const Btf = enum(u1) {
                not_finished = 0, // Data byte transfer not done
                finished = 1, // Data byte transfer successful
            };
            pub const Stopf = enum(u1) {
                no_stop = 0, // No Stop condition detected
                stop = 1, // Stop condition detected
            };
            pub const Rxne = enum(u1) {
                empty = 0, // Data register empty
                not_empty = 1, // Data register not empty
            };
            pub const Txe = enum(u1) {
                not_empty = 0, // Data register not empty
                empty = 1, // Data register empty
            };
            pub const Berr = enum(u1) {
                no_error = 0, // No misplaced Start or Stop condition
                @"error" = 1, // Misplaced Start or Stop condition
            };
            pub const Arlo = enum(u1) {
                no_lost = 0, // No Arbitration Lost detected
                lost = 1, // Arbitration Lost detected
            };
            pub const Af = enum(u1) {
                no_failure = 0, // No acknowledge failure
                failure = 1, // Acknowledge failure
            };
            pub const Ovr = enum(u1) {
                no_overrun = 0, // No overrun/underrun occured
                overrun = 1, // Overrun/underrun occured
            };
            pub const Pecerr = enum(u1) {
                no_error = 0, // no PEC error: receiver returns ACK after PEC reception (if ACK=1)
                @"error" = 1, // PEC error: receiver returns NACK after PEC reception (whatever ACK)
            };
            pub const Timeout = enum(u1) {
                no_timeout = 0, // No Timeout error
                timeout = 1, // SCL remained LOW for 25 ms
            };
            pub const Smbalert = enum(u1) {
                no_alert = 0, // No SMBALERT occured
                alert = 1, // SMBALERT occurred
            };
            sb: Sb, // Start bit (Master mode) (u1)
            addr: Addr, // Address sent (master mode)/matched (slave mode) (u1)
            btf: Btf, // Byte transfer finished (u1)
            add10: u1, // 10-bit header sent (Master mode)
            stopf: Stopf, // Stop detection (slave mode) (u1)
            _reserved_5_5: u1,
            rxne: Rxne, // Data register not empty (receivers) (u1)
            txe: Txe, // Data register empty (transmitters) (u1)
            berr: Berr, // Bus error (u1)
            arlo: Arlo, // Arbitration lost (master mode) (u1)
            af: Af, // Acknowledge failure (u1)
            ovr: Ovr, // Overrun/Underrun (u1)
            pecerr: Pecerr, // PEC Error in reception (u1)
            _reserved_13_13: u1,
            timeout: Timeout, // Timeout or Tlow error (u1)
            smbalert: Smbalert, // SMBus alert (u1)
            _padding_16_31: u16,
        };
        pub const sr1 = mmio(base_address + 0x14, 32, Sr1);

        /// address: 0x40005418
        /// Status register 2
        pub const Sr2 = packed struct {
            msl: u1, // Master/slave
            busy: u1, // Bus busy
            tra: u1, // Transmitter/receiver
            _reserved_3_3: u1,
            gencall: u1, // General call address (Slave mode)
            smbdefault: u1, // SMBus device default address (Slave mode)
            smbhost: u1, // SMBus host header (Slave mode)
            dualf: u1, // Dual flag (Slave mode)
            pec: u8, // acket error checking register
            _padding_16_31: u16,
        };
        pub const sr2 = mmio(base_address + 0x18, 32, Sr2);

        /// address: 0x4000541c
        /// Clock control register
        pub const Ccr = packed struct {
            pub const Duty = enum(u1) {
                duty2_1 = 0, // Duty cycle t_low/t_high = 2/1
                duty16_9 = 1, // Duty cycle t_low/t_high = 16/9
            };
            pub const FS = enum(u1) {
                standard = 0, // Standard mode I2C
                fast = 1, // Fast mode I2C
            };
            ccr: u12, // Clock control register in Fast/Standard mode (Master mode)
            _reserved_12_13: u2,
            duty: Duty, // Fast mode duty cycle (u1)
            f_s: FS, // I2C master mode selection (u1)
            _padding_16_31: u16,
        };
        pub const ccr = mmio(base_address + 0x1c, 32, Ccr);

        /// address: 0x40005420
        /// TRISE register
        pub const trise = mmioInt(base_address + 0x20, 32, u6);

        /// address: 0x40005424
        /// FLTR register
        pub const Fltr = packed struct {
            pub const Dnf = enum(u4) {
                no_filter = 0b0000, // Digital filter disabled
                filter1 = 0b0001, // Digital filter enabled and filtering capability up to 1 tI2CCLK
                filter2 = 0b0010, // Digital filter enabled and filtering capability up to 2 tI2CCLK
                filter3 = 0b0011, // Digital filter enabled and filtering capability up to 3 tI2CCLK
                filter4 = 0b0100, // Digital filter enabled and filtering capability up to 4 tI2CCLK
                filter5 = 0b0101, // Digital filter enabled and filtering capability up to 5 tI2CCLK
                filter6 = 0b0110, // Digital filter enabled and filtering capability up to 6 tI2CCLK
                filter7 = 0b0111, // Digital filter enabled and filtering capability up to 7 tI2CCLK
                filter8 = 0b1000, // Digital filter enabled and filtering capability up to 8 tI2CCLK
                filter9 = 0b1001, // Digital filter enabled and filtering capability up to 9 tI2CCLK
                filter10 = 0b1010, // Digital filter enabled and filtering capability up to 10 tI2CCLK
                filter11 = 0b1011, // Digital filter enabled and filtering capability up to 11 tI2CCLK
                filter12 = 0b1100, // Digital filter enabled and filtering capability up to 12 tI2CCLK
                filter13 = 0b1101, // Digital filter enabled and filtering capability up to 13 tI2CCLK
                filter14 = 0b1110, // Digital filter enabled and filtering capability up to 14 tI2CCLK
                filter15 = 0b1111, // Digital filter enabled and filtering capability up to 15 tI2CCLK
            };
            pub const Anoff = enum(u1) {
                enabled = 0, // Analog noise filter enabled
                disabled = 1, // Analog noise filter disabled
            };
            dnf: Dnf, // Digital noise filter (u4)
            anoff: Anoff, // Analog noise filter (u1)
            _padding_5_31: u27,
        };
        pub const fltr = mmio(base_address + 36, 32, Fltr);
    };
    /// Serial peripheral interface
    pub const spi1 = struct {
        pub const base_address = 0x40013000;

        /// address: 0x40013000
        /// control register 1
        pub const Cr1 = packed struct {
            pub const Cpha = enum(u1) {
                first_edge = 0, // The first clock transition is the first data capture edge
                second_edge = 1, // The second clock transition is the first data capture edge
            };
            pub const Cpol = enum(u1) {
                idle_low = 0, // CK to 0 when idle
                idle_high = 1, // CK to 1 when idle
            };
            pub const Mstr = enum(u1) {
                slave = 0, // Slave configuration
                master = 1, // Master configuration
            };
            pub const Br = enum(u3) {
                div2 = 0b000, // f_PCLK / 2
                div4 = 0b001, // f_PCLK / 4
                div8 = 0b010, // f_PCLK / 8
                div16 = 0b011, // f_PCLK / 16
                div32 = 0b100, // f_PCLK / 32
                div64 = 0b101, // f_PCLK / 64
                div128 = 0b110, // f_PCLK / 128
                div256 = 0b111, // f_PCLK / 256
            };
            pub const Spe = enum(u1) {
                disabled = 0, // Peripheral disabled
                enabled = 1, // Peripheral enabled
            };
            pub const Lsbfirst = enum(u1) {
                msb_first = 0, // Data is transmitted/received with the MSB first
                lsb_first = 1, // Data is transmitted/received with the LSB first
            };
            pub const Ssi = enum(u1) {
                slave_selected = 0, // 0 is forced onto the NSS pin and the I/O value of the NSS pin is ignored
                slave_not_selected = 1, // 1 is forced onto the NSS pin and the I/O value of the NSS pin is ignored
            };
            pub const Ssm = enum(u1) {
                disabled = 0, // Software slave management disabled
                enabled = 1, // Software slave management enabled
            };
            pub const Rxonly = enum(u1) {
                full_duplex = 0, // Full duplex (Transmit and receive)
                output_disabled = 1, // Output disabled (Receive-only mode)
            };
            pub const Dff = enum(u1) {
                eight_bit = 0, // 8-bit data frame format is selected for transmission/reception
                sixteen_bit = 1, // 16-bit data frame format is selected for transmission/reception
            };
            pub const Crcnext = enum(u1) {
                tx_buffer = 0, // Next transmit value is from Tx buffer
                crc = 1, // Next transmit value is from Tx CRC register
            };
            pub const Crcen = enum(u1) {
                disabled = 0, // CRC calculation disabled
                enabled = 1, // CRC calculation enabled
            };
            pub const Bidioe = enum(u1) {
                output_disabled = 0, // Output disabled (receive-only mode)
                output_enabled = 1, // Output enabled (transmit-only mode)
            };
            pub const Bidimode = enum(u1) {
                unidirectional = 0, // 2-line unidirectional data mode selected
                bidirectional = 1, // 1-line bidirectional data mode selected
            };
            cpha: Cpha, // Clock phase (u1)
            cpol: Cpol, // Clock polarity (u1)
            mstr: Mstr, // Master selection (u1)
            br: Br, // Baud rate control (u3)
            spe: Spe, // SPI enable (u1)
            lsbfirst: Lsbfirst, // Frame format (u1)
            ssi: Ssi, // Internal slave select (u1)
            ssm: Ssm, // Software slave management (u1)
            rxonly: Rxonly, // Receive only (u1)
            dff: Dff, // Data frame format (u1)
            crcnext: Crcnext, // CRC transfer next (u1)
            crcen: Crcen, // Hardware CRC calculation enable (u1)
            bidioe: Bidioe, // Output enable in bidirectional mode (u1)
            bidimode: Bidimode, // Bidirectional data mode enable (u1)
            _padding_16_31: u16,
        };
        pub const cr1 = mmio(base_address + 0x0, 32, Cr1);

        /// address: 0x40013004
        /// control register 2
        pub const Cr2 = packed struct {
            pub const Rxdmaen = enum(u1) {
                disabled = 0, // Rx buffer DMA disabled
                enabled = 1, // Rx buffer DMA enabled
            };
            pub const Txdmaen = enum(u1) {
                disabled = 0, // Tx buffer DMA disabled
                enabled = 1, // Tx buffer DMA enabled
            };
            pub const Ssoe = enum(u1) {
                disabled = 0, // SS output is disabled in master mode
                enabled = 1, // SS output is enabled in master mode
            };
            pub const Frf = enum(u1) {
                motorola = 0, // SPI Motorola mode
                ti = 1, // SPI TI mode
            };
            pub const Errie = enum(u1) {
                masked = 0, // Error interrupt masked
                not_masked = 1, // Error interrupt not masked
            };
            pub const Rxneie = enum(u1) {
                masked = 0, // RXE interrupt masked
                not_masked = 1, // RXE interrupt not masked
            };
            pub const Txeie = enum(u1) {
                masked = 0, // TXE interrupt masked
                not_masked = 1, // TXE interrupt not masked
            };
            rxdmaen: Rxdmaen, // Rx buffer DMA enable (u1)
            txdmaen: Txdmaen, // Tx buffer DMA enable (u1)
            ssoe: Ssoe, // SS output enable (u1)
            _reserved_3_3: u1,
            frf: Frf, // Frame format (u1)
            errie: Errie, // Error interrupt enable (u1)
            rxneie: Rxneie, // RX buffer not empty interrupt enable (u1)
            txeie: Txeie, // Tx buffer empty interrupt enable (u1)
            _padding_8_31: u24,
        };
        pub const cr2 = mmio(base_address + 0x4, 32, Cr2);

        /// address: 0x40013008
        /// status register
        pub const Sr = packed struct {
            pub const Rxne = enum(u1) {
                empty = 0, // Rx buffer empty
                not_empty = 1, // Rx buffer not empty
            };
            pub const Txe = enum(u1) {
                not_empty = 0, // Tx buffer not empty
                empty = 1, // Tx buffer empty
            };
            pub const Chside = enum(u1) {
                left = 0, // Channel left has to be transmitted or has been received
                right = 1, // Channel right has to be transmitted or has been received
            };
            pub const Udrr = enum(u1) {
                no_underrun = 0, // No underrun occurred
                underrun = 1, // Underrun occurred
            };
            pub const Crcerr = enum(u1) {
                match = 0, // CRC value received matches the SPIx_RXCRCR value
                no_match = 1, // CRC value received does not match the SPIx_RXCRCR value
            };
            pub const Modfr = enum(u1) {
                no_fault = 0, // No mode fault occurred
                fault = 1, // Mode fault occurred
            };
            pub const Ovrr = enum(u1) {
                no_overrun = 0, // No overrun occurred
                overrun = 1, // Overrun occurred
            };
            pub const Bsyr = enum(u1) {
                not_busy = 0, // SPI not busy
                busy = 1, // SPI busy
            };
            pub const Frer = enum(u1) {
                no_error = 0, // No frame format error
                @"error" = 1, // A frame format error occurred
            };
            rxne: Rxne, // Receive buffer not empty (u1)
            txe: Txe, // Transmit buffer empty (u1)
            chside: Chside, // Channel side (u1)
            udr: Udrr, // Underrun flag (u1)
            crcerr: Crcerr, // CRC error flag (u1)
            modf: Modfr, // Mode fault (u1)
            ovr: Ovrr, // Overrun flag (u1)
            bsy: Bsyr, // Busy flag (u1)
            fre: Frer, // TI frame format error (u1)
            _padding_9_31: u23,
        };
        pub const sr = mmio(base_address + 0x8, 32, Sr);

        /// address: 0x4001300c
        /// data register
        pub const dr = mmioInt(base_address + 0xc, 32, u16);

        /// address: 0x40013010
        /// CRC polynomial register
        pub const Crcpr = packed struct {
            crcpoly: u16, // CRC polynomial register
            _padding_16_31: u16,
        };
        pub const crcpr = mmio(base_address + 0x10, 32, Crcpr);

        /// address: 0x40013014
        /// RX CRC register
        pub const Rxcrcr = packed struct {
            rxcrc: u16, // Rx CRC register
            _padding_16_31: u16,
        };
        pub const rxcrcr = mmio(base_address + 0x14, 32, Rxcrcr);

        /// address: 0x40013018
        /// TX CRC register
        pub const Txcrcr = packed struct {
            txcrc: u16, // Tx CRC register
            _padding_16_31: u16,
        };
        pub const txcrcr = mmio(base_address + 0x18, 32, Txcrcr);

        /// address: 0x4001301c
        /// I2S configuration register
        pub const I2scfgr = packed struct {
            pub const Chlen = enum(u1) {
                sixteen_bit = 0, // 16-bit wide
                thirty_two_bit = 1, // 32-bit wide
            };
            pub const Datlen = enum(u2) {
                sixteen_bit = 0b00, // 16-bit data length
                twenty_four_bit = 0b01, // 24-bit data length
                thirty_two_bit = 0b10, // 32-bit data length
            };
            pub const Ckpol = enum(u1) {
                idle_low = 0, // I2S clock inactive state is low level
                idle_high = 1, // I2S clock inactive state is high level
            };
            pub const I2sstd = enum(u2) {
                philips = 0b00, // I2S Philips standard
                msb = 0b01, // MSB justified standard
                lsb = 0b10, // LSB justified standard
                pcm = 0b11, // PCM standard
            };
            pub const Pcmsync = enum(u1) {
                short = 0, // Short frame synchronisation
                long = 1, // Long frame synchronisation
            };
            pub const I2scfg = enum(u2) {
                slave_tx = 0b00, // Slave - transmit
                slave_rx = 0b01, // Slave - receive
                master_tx = 0b10, // Master - transmit
                master_rx = 0b11, // Master - receive
            };
            pub const I2se = enum(u1) {
                disabled = 0, // I2S peripheral is disabled
                enabled = 1, // I2S peripheral is enabled
            };
            pub const I2smod = enum(u1) {
                spi_mode = 0, // SPI mode is selected
                i2_s_mode = 1, // I2S mode is selected
            };
            chlen: Chlen, // Channel length (number of bits per audio channel) (u1)
            datlen: Datlen, // Data length to be transferred (u2)
            ckpol: Ckpol, // Steady state clock polarity (u1)
            i2sstd: I2sstd, // I2S standard selection (u2)
            _reserved_6_6: u1,
            pcmsync: Pcmsync, // PCM frame synchronization (u1)
            i2scfg: I2scfg, // I2S configuration mode (u2)
            i2se: I2se, // I2S Enable (u1)
            i2smod: I2smod, // I2S mode selection (u1)
            _padding_12_31: u20,
        };
        pub const i2scfgr = mmio(base_address + 0x1c, 32, I2scfgr);

        /// address: 0x40013020
        /// I2S prescaler register
        pub const I2spr = packed struct {
            pub const Odd = enum(u1) {
                even = 0, // Real divider value is I2SDIV * 2
                odd = 1, // Real divider value is (I2SDIV * 2) + 1
            };
            pub const Mckoe = enum(u1) {
                disabled = 0, // Master clock output is disabled
                enabled = 1, // Master clock output is enabled
            };
            i2sdiv: u8, // I2S Linear prescaler
            odd: Odd, // Odd factor for the prescaler (u1)
            mckoe: Mckoe, // Master clock output enable (u1)
            _padding_10_31: u22,
        };
        pub const i2spr = mmio(base_address + 0x20, 32, I2spr);
    };
    /// Nested Vectored Interrupt Controller
    pub const nvic = struct {
        pub const base_address = 0xe000e100;

        /// address: 0xe000e100
        /// Interrupt Set-Enable Register
        pub const Iser0 = packed struct {
            setena: u32, // SETENA
        };
        pub const iser0 = mmio(base_address + 0x0, 32, Iser0);

        /// address: 0xe000e104
        /// Interrupt Set-Enable Register
        pub const Iser1 = packed struct {
            setena: u32, // SETENA
        };
        pub const iser1 = mmio(base_address + 0x4, 32, Iser1);

        /// address: 0xe000e108
        /// Interrupt Set-Enable Register
        pub const Iser2 = packed struct {
            setena: u32, // SETENA
        };
        pub const iser2 = mmio(base_address + 0x8, 32, Iser2);

        /// address: 0xe000e180
        /// Interrupt Clear-Enable Register
        pub const Icer0 = packed struct {
            clrena: u32, // CLRENA
        };
        pub const icer0 = mmio(base_address + 0x80, 32, Icer0);

        /// address: 0xe000e184
        /// Interrupt Clear-Enable Register
        pub const Icer1 = packed struct {
            clrena: u32, // CLRENA
        };
        pub const icer1 = mmio(base_address + 0x84, 32, Icer1);

        /// address: 0xe000e188
        /// Interrupt Clear-Enable Register
        pub const Icer2 = packed struct {
            clrena: u32, // CLRENA
        };
        pub const icer2 = mmio(base_address + 0x88, 32, Icer2);

        /// address: 0xe000e200
        /// Interrupt Set-Pending Register
        pub const Ispr0 = packed struct {
            setpend: u32, // SETPEND
        };
        pub const ispr0 = mmio(base_address + 0x100, 32, Ispr0);

        /// address: 0xe000e204
        /// Interrupt Set-Pending Register
        pub const Ispr1 = packed struct {
            setpend: u32, // SETPEND
        };
        pub const ispr1 = mmio(base_address + 0x104, 32, Ispr1);

        /// address: 0xe000e208
        /// Interrupt Set-Pending Register
        pub const Ispr2 = packed struct {
            setpend: u32, // SETPEND
        };
        pub const ispr2 = mmio(base_address + 0x108, 32, Ispr2);

        /// address: 0xe000e280
        /// Interrupt Clear-Pending Register
        pub const Icpr0 = packed struct {
            clrpend: u32, // CLRPEND
        };
        pub const icpr0 = mmio(base_address + 0x180, 32, Icpr0);

        /// address: 0xe000e284
        /// Interrupt Clear-Pending Register
        pub const Icpr1 = packed struct {
            clrpend: u32, // CLRPEND
        };
        pub const icpr1 = mmio(base_address + 0x184, 32, Icpr1);

        /// address: 0xe000e288
        /// Interrupt Clear-Pending Register
        pub const Icpr2 = packed struct {
            clrpend: u32, // CLRPEND
        };
        pub const icpr2 = mmio(base_address + 0x188, 32, Icpr2);

        /// address: 0xe000e300
        /// Interrupt Active Bit Register
        pub const Iabr0 = packed struct {
            active: u32, // ACTIVE
        };
        pub const iabr0 = mmio(base_address + 0x200, 32, Iabr0);

        /// address: 0xe000e304
        /// Interrupt Active Bit Register
        pub const Iabr1 = packed struct {
            active: u32, // ACTIVE
        };
        pub const iabr1 = mmio(base_address + 0x204, 32, Iabr1);

        /// address: 0xe000e308
        /// Interrupt Active Bit Register
        pub const Iabr2 = packed struct {
            active: u32, // ACTIVE
        };
        pub const iabr2 = mmio(base_address + 0x208, 32, Iabr2);

        /// address: 0xe000e400
        /// Interrupt Priority Register
        pub const Ipr0 = packed struct {
            ipr_n0: u8, // IPR_N0
            ipr_n1: u8, // IPR_N1
            ipr_n2: u8, // IPR_N2
            ipr_n3: u8, // IPR_N3
        };
        pub const ipr0 = mmio(base_address + 0x300, 32, Ipr0);

        /// address: 0xe000e404
        /// Interrupt Priority Register
        pub const Ipr1 = packed struct {
            ipr_n0: u8, // IPR_N0
            ipr_n1: u8, // IPR_N1
            ipr_n2: u8, // IPR_N2
            ipr_n3: u8, // IPR_N3
        };
        pub const ipr1 = mmio(base_address + 0x304, 32, Ipr1);

        /// address: 0xe000e408
        /// Interrupt Priority Register
        pub const Ipr2 = packed struct {
            ipr_n0: u8, // IPR_N0
            ipr_n1: u8, // IPR_N1
            ipr_n2: u8, // IPR_N2
            ipr_n3: u8, // IPR_N3
        };
        pub const ipr2 = mmio(base_address + 0x308, 32, Ipr2);

        /// address: 0xe000e40c
        /// Interrupt Priority Register
        pub const Ipr3 = packed struct {
            ipr_n0: u8, // IPR_N0
            ipr_n1: u8, // IPR_N1
            ipr_n2: u8, // IPR_N2
            ipr_n3: u8, // IPR_N3
        };
        pub const ipr3 = mmio(base_address + 0x30c, 32, Ipr3);

        /// address: 0xe000e410
        /// Interrupt Priority Register
        pub const Ipr4 = packed struct {
            ipr_n0: u8, // IPR_N0
            ipr_n1: u8, // IPR_N1
            ipr_n2: u8, // IPR_N2
            ipr_n3: u8, // IPR_N3
        };
        pub const ipr4 = mmio(base_address + 0x310, 32, Ipr4);

        /// address: 0xe000e414
        /// Interrupt Priority Register
        pub const Ipr5 = packed struct {
            ipr_n0: u8, // IPR_N0
            ipr_n1: u8, // IPR_N1
            ipr_n2: u8, // IPR_N2
            ipr_n3: u8, // IPR_N3
        };
        pub const ipr5 = mmio(base_address + 0x314, 32, Ipr5);

        /// address: 0xe000e418
        /// Interrupt Priority Register
        pub const Ipr6 = packed struct {
            ipr_n0: u8, // IPR_N0
            ipr_n1: u8, // IPR_N1
            ipr_n2: u8, // IPR_N2
            ipr_n3: u8, // IPR_N3
        };
        pub const ipr6 = mmio(base_address + 0x318, 32, Ipr6);

        /// address: 0xe000e41c
        /// Interrupt Priority Register
        pub const Ipr7 = packed struct {
            ipr_n0: u8, // IPR_N0
            ipr_n1: u8, // IPR_N1
            ipr_n2: u8, // IPR_N2
            ipr_n3: u8, // IPR_N3
        };
        pub const ipr7 = mmio(base_address + 0x31c, 32, Ipr7);

        /// address: 0xe000e420
        /// Interrupt Priority Register
        pub const Ipr8 = packed struct {
            ipr_n0: u8, // IPR_N0
            ipr_n1: u8, // IPR_N1
            ipr_n2: u8, // IPR_N2
            ipr_n3: u8, // IPR_N3
        };
        pub const ipr8 = mmio(base_address + 0x320, 32, Ipr8);

        /// address: 0xe000e424
        /// Interrupt Priority Register
        pub const Ipr9 = packed struct {
            ipr_n0: u8, // IPR_N0
            ipr_n1: u8, // IPR_N1
            ipr_n2: u8, // IPR_N2
            ipr_n3: u8, // IPR_N3
        };
        pub const ipr9 = mmio(base_address + 0x324, 32, Ipr9);

        /// address: 0xe000e428
        /// Interrupt Priority Register
        pub const Ipr10 = packed struct {
            ipr_n0: u8, // IPR_N0
            ipr_n1: u8, // IPR_N1
            ipr_n2: u8, // IPR_N2
            ipr_n3: u8, // IPR_N3
        };
        pub const ipr10 = mmio(base_address + 0x328, 32, Ipr10);

        /// address: 0xe000e42c
        /// Interrupt Priority Register
        pub const Ipr11 = packed struct {
            ipr_n0: u8, // IPR_N0
            ipr_n1: u8, // IPR_N1
            ipr_n2: u8, // IPR_N2
            ipr_n3: u8, // IPR_N3
        };
        pub const ipr11 = mmio(base_address + 0x32c, 32, Ipr11);

        /// address: 0xe000e430
        /// Interrupt Priority Register
        pub const Ipr12 = packed struct {
            ipr_n0: u8, // IPR_N0
            ipr_n1: u8, // IPR_N1
            ipr_n2: u8, // IPR_N2
            ipr_n3: u8, // IPR_N3
        };
        pub const ipr12 = mmio(base_address + 0x330, 32, Ipr12);

        /// address: 0xe000e434
        /// Interrupt Priority Register
        pub const Ipr13 = packed struct {
            ipr_n0: u8, // IPR_N0
            ipr_n1: u8, // IPR_N1
            ipr_n2: u8, // IPR_N2
            ipr_n3: u8, // IPR_N3
        };
        pub const ipr13 = mmio(base_address + 0x334, 32, Ipr13);

        /// address: 0xe000e438
        /// Interrupt Priority Register
        pub const Ipr14 = packed struct {
            ipr_n0: u8, // IPR_N0
            ipr_n1: u8, // IPR_N1
            ipr_n2: u8, // IPR_N2
            ipr_n3: u8, // IPR_N3
        };
        pub const ipr14 = mmio(base_address + 0x338, 32, Ipr14);

        /// address: 0xe000e43c
        /// Interrupt Priority Register
        pub const Ipr15 = packed struct {
            ipr_n0: u8, // IPR_N0
            ipr_n1: u8, // IPR_N1
            ipr_n2: u8, // IPR_N2
            ipr_n3: u8, // IPR_N3
        };
        pub const ipr15 = mmio(base_address + 0x33c, 32, Ipr15);

        /// address: 0xe000e440
        /// Interrupt Priority Register
        pub const Ipr16 = packed struct {
            ipr_n0: u8, // IPR_N0
            ipr_n1: u8, // IPR_N1
            ipr_n2: u8, // IPR_N2
            ipr_n3: u8, // IPR_N3
        };
        pub const ipr16 = mmio(base_address + 0x340, 32, Ipr16);

        /// address: 0xe000e444
        /// Interrupt Priority Register
        pub const Ipr17 = packed struct {
            ipr_n0: u8, // IPR_N0
            ipr_n1: u8, // IPR_N1
            ipr_n2: u8, // IPR_N2
            ipr_n3: u8, // IPR_N3
        };
        pub const ipr17 = mmio(base_address + 0x344, 32, Ipr17);

        /// address: 0xe000e448
        /// Interrupt Priority Register
        pub const Ipr18 = packed struct {
            ipr_n0: u8, // IPR_N0
            ipr_n1: u8, // IPR_N1
            ipr_n2: u8, // IPR_N2
            ipr_n3: u8, // IPR_N3
        };
        pub const ipr18 = mmio(base_address + 0x348, 32, Ipr18);

        /// address: 0xe000e44c
        /// Interrupt Priority Register
        pub const Ipr19 = packed struct {
            ipr_n0: u8, // IPR_N0
            ipr_n1: u8, // IPR_N1
            ipr_n2: u8, // IPR_N2
            ipr_n3: u8, // IPR_N3
        };
        pub const ipr19 = mmio(base_address + 0x34c, 32, Ipr19);
    };
    /// Floting point unit
    pub const fpu = struct {
        pub const base_address = 0xe000ef34;

        /// address: 0xe000ef34
        /// Floating-point context control register
        pub const Fpccr = packed struct {
            lspact: u1, // LSPACT
            user: u1, // USER
            _reserved_2_2: u1,
            thread: u1, // THREAD
            hfrdy: u1, // HFRDY
            mmrdy: u1, // MMRDY
            bfrdy: u1, // BFRDY
            _reserved_7_7: u1,
            monrdy: u1, // MONRDY
            _reserved_9_29: u21,
            lspen: u1, // LSPEN
            aspen: u1, // ASPEN
        };
        pub const fpccr = mmio(base_address + 0x0, 32, Fpccr);

        /// address: 0xe000ef38
        /// Floating-point context address register
        pub const Fpcar = packed struct {
            _reserved_0_2: u3,
            address: u29, // Location of unpopulated floating-point
        };
        pub const fpcar = mmio(base_address + 0x4, 32, Fpcar);

        /// address: 0xe000ef3c
        /// Floating-point status control register
        pub const Fpscr = packed struct {
            ioc: u1, // Invalid operation cumulative exception bit
            dzc: u1, // Division by zero cumulative exception bit.
            ofc: u1, // Overflow cumulative exception bit
            ufc: u1, // Underflow cumulative exception bit
            ixc: u1, // Inexact cumulative exception bit
            _reserved_5_6: u2,
            idc: u1, // Input denormal cumulative exception bit.
            _reserved_8_21: u14,
            rmode: u2, // Rounding Mode control field
            fz: u1, // Flush-to-zero mode control bit:
            dn: u1, // Default NaN mode control bit
            ahp: u1, // Alternative half-precision control bit
            _reserved_27_27: u1,
            v: u1, // Overflow condition code flag
            c: u1, // Carry condition code flag
            z: u1, // Zero condition code flag
            n: u1, // Negative condition code flag
        };
        pub const fpscr = mmio(base_address + 0x8, 32, Fpscr);
    };
    /// Memory protection unit
    pub const mpu = struct {
        pub const base_address = 0xe000ed90;

        /// address: 0xe000ed90
        /// MPU type register
        pub const Typer = packed struct {
            separate: u1, // Separate flag
            _reserved_1_7: u7,
            dregion: u8, // Number of MPU data regions
            iregion: u8, // Number of MPU instruction regions
            _padding_24_31: u8,
        };
        pub const typer = mmio(base_address + 0x0, 32, Typer);

        /// address: 0xe000ed94
        /// MPU control register
        pub const Ctrl = packed struct {
            enable: u1, // Enables the MPU
            hfnmiena: u1, // Enables the operation of MPU during hard fault
            privdefena: u1, // Enable priviliged software access to default memory map
            _padding_3_31: u29,
        };
        pub const ctrl = mmio(base_address + 0x4, 32, Ctrl);

        /// address: 0xe000ed98
        /// MPU region number register
        pub const Rnr = packed struct {
            region: u8, // MPU region
            _padding_8_31: u24,
        };
        pub const rnr = mmio(base_address + 0x8, 32, Rnr);

        /// address: 0xe000ed9c
        /// MPU region base address register
        pub const Rbar = packed struct {
            region: u4, // MPU region field
            valid: u1, // MPU region number valid
            addr: u27, // Region base address field
        };
        pub const rbar = mmio(base_address + 0xc, 32, Rbar);

        /// address: 0xe000eda0
        /// MPU region attribute and size register
        pub const Rasr = packed struct {
            enable: u1, // Region enable bit.
            size: u5, // Size of the MPU protection region
            _reserved_6_7: u2,
            srd: u8, // Subregion disable bits
            b: u1, // memory attribute
            c: u1, // memory attribute
            s: u1, // Shareable memory attribute
            tex: u3, // memory attribute
            _reserved_22_23: u2,
            ap: u3, // Access permission
            _reserved_27_27: u1,
            xn: u1, // Instruction access disable bit
            _padding_29_31: u3,
        };
        pub const rasr = mmio(base_address + 0x10, 32, Rasr);
    };
    /// SysTick timer
    pub const stk = struct {
        pub const base_address = 0xe000e010;

        /// address: 0xe000e010
        /// SysTick control and status register
        pub const Ctrl = packed struct {
            enable: u1, // Counter enable
            tickint: u1, // SysTick exception request enable
            clksource: u1, // Clock source selection
            _reserved_3_15: u13,
            countflag: u1, // COUNTFLAG
            _padding_17_31: u15,
        };
        pub const ctrl = mmio(base_address + 0x0, 32, Ctrl);

        /// address: 0xe000e014
        /// SysTick reload value register
        pub const Load = packed struct {
            reload: u24, // RELOAD value
            _padding_24_31: u8,
        };
        pub const load = mmio(base_address + 0x4, 32, Load);

        /// address: 0xe000e018
        /// SysTick current value register
        pub const Val = packed struct {
            current: u24, // Current counter value
            _padding_24_31: u8,
        };
        pub const val = mmio(base_address + 0x8, 32, Val);

        /// address: 0xe000e01c
        /// SysTick calibration value register
        pub const Calib = packed struct {
            tenms: u24, // Calibration value
            _reserved_24_29: u6,
            skew: u1, // SKEW flag: Indicates whether the TENMS value is exact
            noref: u1, // NOREF flag. Reads as zero
        };
        pub const calib = mmio(base_address + 0xc, 32, Calib);
    };
    /// System control block
    pub const scb = struct {
        pub const base_address = 0xe000ed00;

        /// address: 0xe000ed00
        /// CPUID base register
        pub const Cpuid = packed struct {
            revision: u4, // Revision number
            partno: u12, // Part number of the processor
            constant: u4, // Reads as 0xF
            variant: u4, // Variant number
            implementer: u8, // Implementer code
        };
        pub const cpuid = mmio(base_address + 0x0, 32, Cpuid);

        /// address: 0xe000ed04
        /// Interrupt control and state register
        pub const Icsr = packed struct {
            vectactive: u9, // Active vector
            _reserved_9_10: u2,
            rettobase: u1, // Return to base level
            vectpending: u7, // Pending vector
            _reserved_19_21: u3,
            isrpending: u1, // Interrupt pending flag
            _reserved_23_24: u2,
            pendstclr: u1, // SysTick exception clear-pending bit
            pendstset: u1, // SysTick exception set-pending bit
            pendsvclr: u1, // PendSV clear-pending bit
            pendsvset: u1, // PendSV set-pending bit
            _reserved_29_30: u2,
            nmipendset: u1, // NMI set-pending bit.
        };
        pub const icsr = mmio(base_address + 0x4, 32, Icsr);

        /// address: 0xe000ed08
        /// Vector table offset register
        pub const Vtor = packed struct {
            _reserved_0_8: u9,
            tbloff: u21, // Vector table base offset field
            _padding_30_31: u2,
        };
        pub const vtor = mmio(base_address + 0x8, 32, Vtor);

        /// address: 0xe000ed0c
        /// Application interrupt and reset control register
        pub const Aircr = packed struct {
            vectreset: u1, // VECTRESET
            vectclractive: u1, // VECTCLRACTIVE
            sysresetreq: u1, // SYSRESETREQ
            _reserved_3_7: u5,
            prigroup: u3, // PRIGROUP
            _reserved_11_14: u4,
            endianess: u1, // ENDIANESS
            vectkeystat: u16, // Register key
        };
        pub const aircr = mmio(base_address + 0xc, 32, Aircr);

        /// address: 0xe000ed10
        /// System control register
        pub const Scr = packed struct {
            _reserved_0_0: u1,
            sleeponexit: u1, // SLEEPONEXIT
            sleepdeep: u1, // SLEEPDEEP
            _reserved_3_3: u1,
            seveonpend: u1, // Send Event on Pending bit
            _padding_5_31: u27,
        };
        pub const scr = mmio(base_address + 0x10, 32, Scr);

        /// address: 0xe000ed14
        /// Configuration and control register
        pub const Ccr = packed struct {
            nonbasethrdena: u1, // Configures how the processor enters Thread mode
            usersetmpend: u1, // USERSETMPEND
            _reserved_2_2: u1,
            unalign__trp: u1, // UNALIGN_ TRP
            div_0_trp: u1, // DIV_0_TRP
            _reserved_5_7: u3,
            bfhfnmign: u1, // BFHFNMIGN
            stkalign: u1, // STKALIGN
            _padding_10_31: u22,
        };
        pub const ccr = mmio(base_address + 0x14, 32, Ccr);

        /// address: 0xe000ed18
        /// System handler priority registers
        pub const Shpr1 = packed struct {
            pri_4: u8, // Priority of system handler 4
            pri_5: u8, // Priority of system handler 5
            pri_6: u8, // Priority of system handler 6
            _padding_24_31: u8,
        };
        pub const shpr1 = mmio(base_address + 0x18, 32, Shpr1);

        /// address: 0xe000ed1c
        /// System handler priority registers
        pub const Shpr2 = packed struct {
            _reserved_0_23: u24,
            pri_11: u8, // Priority of system handler 11
        };
        pub const shpr2 = mmio(base_address + 0x1c, 32, Shpr2);

        /// address: 0xe000ed20
        /// System handler priority registers
        pub const Shpr3 = packed struct {
            _reserved_0_15: u16,
            pri_14: u8, // Priority of system handler 14
            pri_15: u8, // Priority of system handler 15
        };
        pub const shpr3 = mmio(base_address + 0x20, 32, Shpr3);

        /// address: 0xe000ed24
        /// System handler control and state register
        pub const Shcrs = packed struct {
            memfaultact: u1, // Memory management fault exception active bit
            busfaultact: u1, // Bus fault exception active bit
            _reserved_2_2: u1,
            usgfaultact: u1, // Usage fault exception active bit
            _reserved_4_6: u3,
            svcallact: u1, // SVC call active bit
            monitoract: u1, // Debug monitor active bit
            _reserved_9_9: u1,
            pendsvact: u1, // PendSV exception active bit
            systickact: u1, // SysTick exception active bit
            usgfaultpended: u1, // Usage fault exception pending bit
            memfaultpended: u1, // Memory management fault exception pending bit
            busfaultpended: u1, // Bus fault exception pending bit
            svcallpended: u1, // SVC call pending bit
            memfaultena: u1, // Memory management fault enable bit
            busfaultena: u1, // Bus fault enable bit
            usgfaultena: u1, // Usage fault enable bit
            _padding_19_31: u13,
        };
        pub const shcrs = mmio(base_address + 0x24, 32, Shcrs);

        /// address: 0xe000ed28
        /// Configurable fault status register
        pub const CfsrUfsrBfsrMmfsr = packed struct {
            _reserved_0_0: u1,
            iaccviol: u1, // Instruction access violation flag
            _reserved_2_2: u1,
            munstkerr: u1, // Memory manager fault on unstacking for a return from exception
            mstkerr: u1, // Memory manager fault on stacking for exception entry.
            mlsperr: u1, // MLSPERR
            _reserved_6_6: u1,
            mmarvalid: u1, // Memory Management Fault Address Register (MMAR) valid flag
            ibuserr: u1, // Instruction bus error
            preciserr: u1, // Precise data bus error
            impreciserr: u1, // Imprecise data bus error
            unstkerr: u1, // Bus fault on unstacking for a return from exception
            stkerr: u1, // Bus fault on stacking for exception entry
            lsperr: u1, // Bus fault on floating-point lazy state preservation
            _reserved_14_14: u1,
            bfarvalid: u1, // Bus Fault Address Register (BFAR) valid flag
            undefinstr: u1, // Undefined instruction usage fault
            invstate: u1, // Invalid state usage fault
            invpc: u1, // Invalid PC load usage fault
            nocp: u1, // No coprocessor usage fault.
            _reserved_20_23: u4,
            unaligned: u1, // Unaligned access usage fault
            divbyzero: u1, // Divide by zero usage fault
            _padding_26_31: u6,
        };
        pub const cfsr_ufsr_bfsr_mmfsr = mmio(base_address + 0x28, 32, CfsrUfsrBfsrMmfsr);

        /// address: 0xe000ed2c
        /// Hard fault status register
        pub const Hfsr = packed struct {
            _reserved_0_0: u1,
            vecttbl: u1, // Vector table hard fault
            _reserved_2_29: u28,
            forced: u1, // Forced hard fault
            debug_vt: u1, // Reserved for Debug use
        };
        pub const hfsr = mmio(base_address + 0x2c, 32, Hfsr);

        /// address: 0xe000ed34
        /// Memory management fault address register
        pub const mmfar = @intToPtr(*volatile u32, base_address + 0x34);

        /// address: 0xe000ed38
        /// Bus fault address register
        pub const bfar = @intToPtr(*volatile u32, base_address + 0x38);

        /// address: 0xe000ed3c
        /// Auxiliary fault status register
        pub const Afsr = packed struct {
            impdef: u32, // Implementation defined
        };
        pub const afsr = mmio(base_address + 0x3c, 32, Afsr);
    };
    /// Nested vectored interrupt controller
    pub const nvic_stir = struct {
        pub const base_address = 0xe000ef00;

        /// address: 0xe000ef00
        /// Software trigger interrupt register
        pub const Stir = packed struct {
            intid: u9, // Software generated interrupt ID
            _padding_9_31: u23,
        };
        pub const stir = mmio(base_address + 0x0, 32, Stir);
    };
    /// Floating point unit CPACR
    pub const fpu_cpacr = struct {
        pub const base_address = 0xe000ed88;

        /// address: 0xe000ed88
        /// Coprocessor access control register
        pub const Cpacr = packed struct {
            _reserved_0_19: u20,
            cp: u4, // CP
            _padding_24_31: u8,
        };
        pub const cpacr = mmio(base_address + 0x0, 32, Cpacr);
    };
    /// System control block ACTLR
    pub const scb_actrl = struct {
        pub const base_address = 0xe000e008;

        /// address: 0xe000e008
        /// Auxiliary control register
        pub const Actrl = packed struct {
            dismcycint: u1, // DISMCYCINT
            disdefwbuf: u1, // DISDEFWBUF
            disfold: u1, // DISFOLD
            _reserved_3_7: u5,
            disfpca: u1, // DISFPCA
            disoofp: u1, // DISOOFP
            _padding_10_31: u22,
        };
        pub const actrl = mmio(base_address + 0x0, 32, Actrl);
    };
    /// Advanced-timers
    pub const tim8 = struct {
        pub const base_address = 0x40010400;

        /// address: 0x40010400
        /// control register 1
        pub const Cr1 = packed struct {
            pub const Cen = enum(u1) {
                disabled = 0, // Counter disabled
                enabled = 1, // Counter enabled
            };
            pub const Udis = enum(u1) {
                enabled = 0, // Update event enabled
                disabled = 1, // Update event disabled
            };
            pub const Urs = enum(u1) {
                any_event = 0, // Any of counter overflow/underflow, setting UG, or update through slave mode, generates an update interrupt or DMA request
                counter_only = 1, // Only counter overflow/underflow generates an update interrupt or DMA request
            };
            pub const Opm = enum(u1) {
                disabled = 0, // Counter is not stopped at update event
                enabled = 1, // Counter stops counting at the next update event (clearing the CEN bit)
            };
            pub const Dir = enum(u1) {
                up = 0, // Counter used as upcounter
                down = 1, // Counter used as downcounter
            };
            pub const Cms = enum(u2) {
                edge_aligned = 0b00, // The counter counts up or down depending on the direction bit
                center_aligned1 = 0b01, // The counter counts up and down alternatively. Output compare interrupt flags are set only when the counter is counting down.
                center_aligned2 = 0b10, // The counter counts up and down alternatively. Output compare interrupt flags are set only when the counter is counting up.
                center_aligned3 = 0b11, // The counter counts up and down alternatively. Output compare interrupt flags are set both when the counter is counting up or down.
            };
            pub const Arpe = enum(u1) {
                disabled = 0, // TIMx_APRR register is not buffered
                enabled = 1, // TIMx_APRR register is buffered
            };
            pub const Ckd = enum(u2) {
                div1 = 0b00, // t_DTS = t_CK_INT
                div2 = 0b01, // t_DTS = 2  t_CK_INT
                div4 = 0b10, // t_DTS = 4  t_CK_INT
            };
            cen: Cen, // Counter enable (u1)
            udis: Udis, // Update disable (u1)
            urs: Urs, // Update request source (u1)
            opm: Opm, // One-pulse mode (u1)
            dir: Dir, // Direction (u1)
            cms: Cms, // Center-aligned mode selection (u2)
            arpe: Arpe, // Auto-reload preload enable (u1)
            ckd: Ckd, // Clock division (u2)
            _padding_10_31: u22,
        };
        pub const cr1 = mmio(base_address + 0x0, 32, Cr1);

        /// address: 0x40010404
        /// control register 2
        pub const Cr2 = packed struct {
            pub const Ccds = enum(u1) {
                on_compare = 0, // CCx DMA request sent when CCx event occurs
                on_update = 1, // CCx DMA request sent when update event occurs
            };
            pub const Mms = enum(u3) {
                reset = 0b000, // The UG bit from the TIMx_EGR register is used as trigger output
                enable = 0b001, // The counter enable signal, CNT_EN, is used as trigger output
                update = 0b010, // The update event is selected as trigger output
                compare_pulse = 0b011, // The trigger output send a positive pulse when the CC1IF flag it to be set, as soon as a capture or a compare match occurred
                compare_oc1 = 0b100, // OC1REF signal is used as trigger output
                compare_oc2 = 0b101, // OC2REF signal is used as trigger output
                compare_oc3 = 0b110, // OC3REF signal is used as trigger output
                compare_oc4 = 0b111, // OC4REF signal is used as trigger output
            };
            pub const Ti1s = enum(u1) {
                normal = 0, // The TIMx_CH1 pin is connected to TI1 input
                xor = 1, // The TIMx_CH1, CH2, CH3 pins are connected to TI1 input
            };
            ccpc: u1, // Capture/compare preloaded control
            _reserved_1_1: u1,
            ccus: u1, // Capture/compare control update selection
            ccds: Ccds, // Capture/compare DMA selection (u1)
            mms: Mms, // Master mode selection (u3)
            ti1s: Ti1s, // TI1 selection (u1)
            ois1: u1, // Output Idle state 1
            ois1n: u1, // Output Idle state 1
            ois2: u1, // Output Idle state 2
            ois2n: u1, // Output Idle state 2
            ois3: u1, // Output Idle state 3
            ois3n: u1, // Output Idle state 3
            ois4: u1, // Output Idle state 4
            _padding_15_31: u17,
        };
        pub const cr2 = mmio(base_address + 0x4, 32, Cr2);

        /// address: 0x40010408
        /// slave mode control register
        pub const Smcr = packed struct {
            pub const Sms = enum(u3) {
                disabled = 0b000, // Slave mode disabled - if CEN = 1 then the prescaler is clocked directly by the internal clock.
                encoder_mode_1 = 0b001, // Encoder mode 1 - Counter counts up/down on TI2FP1 edge depending on TI1FP2 level.
                encoder_mode_2 = 0b010, // Encoder mode 2 - Counter counts up/down on TI1FP2 edge depending on TI2FP1 level.
                encoder_mode_3 = 0b011, // Encoder mode 3 - Counter counts up/down on both TI1FP1 and TI2FP2 edges depending on the level of the other input.
                reset_mode = 0b100, // Reset Mode - Rising edge of the selected trigger input (TRGI) reinitializes the counter and generates an update of the registers.
                gated_mode = 0b101, // Gated Mode - The counter clock is enabled when the trigger input (TRGI) is high. The counter stops (but is not reset) as soon as the trigger becomes low. Both start and stop of the counter are controlled.
                trigger_mode = 0b110, // Trigger Mode - The counter starts at a rising edge of the trigger TRGI (but it is not reset). Only the start of the counter is controlled.
                ext_clock_mode = 0b111, // External Clock Mode 1 - Rising edges of the selected trigger (TRGI) clock the counter.
            };
            pub const Ts = enum(u3) {
                itr0 = 0b000, // Internal Trigger 0 (ITR0)
                itr1 = 0b001, // Internal Trigger 1 (ITR1)
                itr2 = 0b010, // Internal Trigger 2 (ITR2)
                ti1_f_ed = 0b100, // TI1 Edge Detector (TI1F_ED)
                ti1_fp1 = 0b101, // Filtered Timer Input 1 (TI1FP1)
                ti2_fp2 = 0b110, // Filtered Timer Input 2 (TI2FP2)
                etrf = 0b111, // External Trigger input (ETRF)
            };
            pub const Msm = enum(u1) {
                no_sync = 0, // No action
                sync = 1, // The effect of an event on the trigger input (TRGI) is delayed to allow a perfect synchronization between the current timer and its slaves (through TRGO). It is useful if we want to synchronize several timers on a single external event.
            };
            pub const Etf = enum(u4) {
                no_filter = 0b0000, // No filter, sampling is done at fDTS
                fck_int_n2 = 0b0001, // fSAMPLING=fCK_INT, N=2
                fck_int_n4 = 0b0010, // fSAMPLING=fCK_INT, N=4
                fck_int_n8 = 0b0011, // fSAMPLING=fCK_INT, N=8
                fdts_div2_n6 = 0b0100, // fSAMPLING=fDTS/2, N=6
                fdts_div2_n8 = 0b0101, // fSAMPLING=fDTS/2, N=8
                fdts_div4_n6 = 0b0110, // fSAMPLING=fDTS/4, N=6
                fdts_div4_n8 = 0b0111, // fSAMPLING=fDTS/4, N=8
                fdts_div8_n6 = 0b1000, // fSAMPLING=fDTS/8, N=6
                fdts_div8_n8 = 0b1001, // fSAMPLING=fDTS/8, N=8
                fdts_div16_n5 = 0b1010, // fSAMPLING=fDTS/16, N=5
                fdts_div16_n6 = 0b1011, // fSAMPLING=fDTS/16, N=6
                fdts_div16_n8 = 0b1100, // fSAMPLING=fDTS/16, N=8
                fdts_div32_n5 = 0b1101, // fSAMPLING=fDTS/32, N=5
                fdts_div32_n6 = 0b1110, // fSAMPLING=fDTS/32, N=6
                fdts_div32_n8 = 0b1111, // fSAMPLING=fDTS/32, N=8
            };
            pub const Etps = enum(u2) {
                div1 = 0b00, // Prescaler OFF
                div2 = 0b01, // ETRP frequency divided by 2
                div4 = 0b10, // ETRP frequency divided by 4
                div8 = 0b11, // ETRP frequency divided by 8
            };
            pub const Ece = enum(u1) {
                disabled = 0, // External clock mode 2 disabled
                enabled = 1, // External clock mode 2 enabled. The counter is clocked by any active edge on the ETRF signal.
            };
            pub const Etp = enum(u1) {
                not_inverted = 0, // ETR is noninverted, active at high level or rising edge
                inverted = 1, // ETR is inverted, active at low level or falling edge
            };
            sms: Sms, // Slave mode selection (u3)
            _reserved_3_3: u1,
            ts: Ts, // Trigger selection (u3)
            msm: Msm, // Master/Slave mode (u1)
            etf: Etf, // External trigger filter (u4)
            etps: Etps, // External trigger prescaler (u2)
            ece: Ece, // External clock enable (u1)
            etp: Etp, // External trigger polarity (u1)
            _padding_16_31: u16,
        };
        pub const smcr = mmio(base_address + 0x8, 32, Smcr);

        /// address: 0x4001040c
        /// DMA/Interrupt enable register
        pub const Dier = packed struct {
            pub const Uie = enum(u1) {
                disabled = 0, // Update interrupt disabled
                enabled = 1, // Update interrupt enabled
            };
            pub const Cc1ie = enum(u1) {
                disabled = 0, // CCx interrupt disabled
                enabled = 1, // CCx interrupt enabled
            };
            pub const Tie = enum(u1) {
                disabled = 0, // Trigger interrupt disabled
                enabled = 1, // Trigger interrupt enabled
            };
            pub const Ude = enum(u1) {
                disabled = 0, // Update DMA request disabled
                enabled = 1, // Update DMA request enabled
            };
            pub const Cc1de = enum(u1) {
                disabled = 0, // CCx DMA request disabled
                enabled = 1, // CCx DMA request enabled
            };
            pub const Tde = enum(u1) {
                disabled = 0, // Trigger DMA request disabled
                enabled = 1, // Trigger DMA request enabled
            };
            uie: Uie, // Update interrupt enable (u1)
            cc1ie: Cc1ie, // Capture/Compare 1 interrupt enable (u1)
            cc2ie: Cc1ie, // Capture/Compare 2 interrupt enable (u1)
            cc3ie: Cc1ie, // Capture/Compare 3 interrupt enable (u1)
            cc4ie: Cc1ie, // Capture/Compare 4 interrupt enable (u1)
            comie: u1, // COM interrupt enable
            tie: Tie, // Trigger interrupt enable (u1)
            bie: u1, // Break interrupt enable
            ude: Ude, // Update DMA request enable (u1)
            cc1de: Cc1de, // Capture/Compare 1 DMA request enable (u1)
            cc2de: Cc1de, // Capture/Compare 2 DMA request enable (u1)
            cc3de: Cc1de, // Capture/Compare 3 DMA request enable (u1)
            cc4de: Cc1de, // Capture/Compare 4 DMA request enable (u1)
            comde: u1, // COM DMA request enable
            tde: Tde, // Trigger DMA request enable (u1)
            _padding_15_31: u17,
        };
        pub const dier = mmio(base_address + 0xc, 32, Dier);

        /// address: 0x40010410
        /// status register
        pub const Sr = packed struct {
            pub const Uif = enum(u1) {
                clear = 0, // No update occurred
                update_pending = 1, // Update interrupt pending.
            };
            pub const Cc1if = enum(u1) {
                match = 1, // If CC1 is an output: The content of the counter TIMx_CNT matches the content of the TIMx_CCR1 register. If CC1 is an input: The counter value has been captured in TIMx_CCR1 register.
                clear = 0, // Clear flag
            };
            pub const Tif = enum(u1) {
                no_trigger = 0, // No trigger event occurred
                trigger = 1, // Trigger interrupt pending
                pub const clear = @intToEnum(Tif, 0); // Clear flag
            };
            pub const Cc1of = enum(u1) {
                overcapture = 1, // The counter value has been captured in TIMx_CCRx register while CCxIF flag was already set
                clear = 0, // Clear flag
            };
            uif: Uif, // Update interrupt flag (u1)
            cc1if: Cc1if, // Capture/compare 1 interrupt flag (u1)
            cc2if: Cc1if, // Capture/Compare 2 interrupt flag (u1)
            cc3if: Cc1if, // Capture/Compare 3 interrupt flag (u1)
            cc4if: Cc1if, // Capture/Compare 4 interrupt flag (u1)
            comif: u1, // COM interrupt flag
            tif: Tif, // Trigger interrupt flag (u1)
            bif: u1, // Break interrupt flag
            _reserved_8_8: u1,
            cc1of: Cc1of, // Capture/Compare 1 overcapture flag (u1)
            cc2of: Cc1of, // Capture/compare 2 overcapture flag (u1)
            cc3of: Cc1of, // Capture/Compare 3 overcapture flag (u1)
            cc4of: Cc1of, // Capture/Compare 4 overcapture flag (u1)
            _padding_13_31: u19,
        };
        pub const sr = mmio(base_address + 0x10, 32, Sr);

        /// address: 0x40010414
        /// event generation register
        pub const Egr = packed struct {
            pub const Ug = enum(u1) {
                update = 1, // Re-initializes the timer counter and generates an update of the registers.
            };
            pub const Cc1gw = enum(u1) {
                trigger = 1, // If CC1 is an output: CC1IF flag is set, Corresponding interrupt or DMA request is sent if enabled. If CC1 is an input: The current value of the counter is captured in TIMx_CCR1 register.
            };
            pub const Tgw = enum(u1) {
                trigger = 1, // The TIF flag is set in TIMx_SR register. Related interrupt or DMA transfer can occur if enabled.
            };
            ug: Ug, // Update generation (u1)
            cc1g: Cc1gw, // Capture/compare 1 generation (u1)
            cc2g: Cc1gw, // Capture/compare 2 generation (u1)
            cc3g: Cc1gw, // Capture/compare 3 generation (u1)
            cc4g: Cc1gw, // Capture/compare 4 generation (u1)
            comg: u1, // Capture/Compare control update generation
            tg: Tgw, // Trigger generation (u1)
            bg: u1, // Break generation
            _padding_8_31: u24,
        };
        pub const egr = mmio(base_address + 0x14, 32, Egr);

        /// address: 0x40010418
        /// capture/compare mode register 1 (output mode)
        pub const Ccmr1Output = packed struct {
            pub const Cc1s = enum(u2) {
                output = 0b00, // CC1 channel is configured as output
            };
            pub const Oc1pe = enum(u1) {
                disabled = 0, // Preload register on CCR1 disabled. New values written to CCR1 are taken into account immediately
                enabled = 1, // Preload register on CCR1 enabled. Preload value is loaded into active register on each update event
            };
            pub const Oc1m = enum(u3) {
                frozen = 0b000, // The comparison between the output compare register TIMx_CCRy and the counter TIMx_CNT has no effect on the outputs
                active_on_match = 0b001, // Set channel to active level on match. OCyREF signal is forced high when the counter matches the capture/compare register
                inactive_on_match = 0b010, // Set channel to inactive level on match. OCyREF signal is forced low when the counter matches the capture/compare register
                toggle = 0b011, // OCyREF toggles when TIMx_CNT=TIMx_CCRy
                force_inactive = 0b100, // OCyREF is forced low
                force_active = 0b101, // OCyREF is forced high
                pwm_mode1 = 0b110, // In upcounting, channel is active as long as TIMx_CNT<TIMx_CCRy else inactive. In downcounting, channel is inactive as long as TIMx_CNT>TIMx_CCRy else active
                pwm_mode2 = 0b111, // Inversely to PwmMode1
            };
            pub const Cc2s = enum(u2) {
                output = 0b00, // CC2 channel is configured as output
            };
            pub const Oc2pe = enum(u1) {
                disabled = 0, // Preload register on CCR2 disabled. New values written to CCR2 are taken into account immediately
                enabled = 1, // Preload register on CCR2 enabled. Preload value is loaded into active register on each update event
            };
            cc1s: Cc1s, // Capture/Compare 1 selection (u2)
            oc1fe: u1, // Output Compare 1 fast enable
            oc1pe: Oc1pe, // Output Compare 1 preload enable (u1)
            oc1m: Oc1m, // Output Compare 1 mode (u3)
            oc1ce: u1, // Output Compare 1 clear enable
            cc2s: Cc2s, // Capture/Compare 2 selection (u2)
            oc2fe: u1, // Output Compare 2 fast enable
            oc2pe: Oc2pe, // Output Compare 2 preload enable (u1)
            oc2m: Oc1m, // Output Compare 2 mode (u3)
            oc2ce: u1, // Output Compare 2 clear enable
            _padding_16_31: u16,
        };
        pub const ccmr1_output = mmio(base_address + 0x18, 32, Ccmr1Output);

        /// address: 0x40010418
        /// capture/compare mode register 1 (input mode)
        pub const Ccmr1Input = packed struct {
            pub const Cc1s = enum(u2) {
                ti1 = 0b01, // CC1 channel is configured as input, IC1 is mapped on TI1
                ti2 = 0b10, // CC1 channel is configured as input, IC1 is mapped on TI2
                trc = 0b11, // CC1 channel is configured as input, IC1 is mapped on TRC
            };
            pub const Ic1f = enum(u4) {
                no_filter = 0b0000, // No filter, sampling is done at fDTS
                fck_int_n2 = 0b0001, // fSAMPLING=fCK_INT, N=2
                fck_int_n4 = 0b0010, // fSAMPLING=fCK_INT, N=4
                fck_int_n8 = 0b0011, // fSAMPLING=fCK_INT, N=8
                fdts_div2_n6 = 0b0100, // fSAMPLING=fDTS/2, N=6
                fdts_div2_n8 = 0b0101, // fSAMPLING=fDTS/2, N=8
                fdts_div4_n6 = 0b0110, // fSAMPLING=fDTS/4, N=6
                fdts_div4_n8 = 0b0111, // fSAMPLING=fDTS/4, N=8
                fdts_div8_n6 = 0b1000, // fSAMPLING=fDTS/8, N=6
                fdts_div8_n8 = 0b1001, // fSAMPLING=fDTS/8, N=8
                fdts_div16_n5 = 0b1010, // fSAMPLING=fDTS/16, N=5
                fdts_div16_n6 = 0b1011, // fSAMPLING=fDTS/16, N=6
                fdts_div16_n8 = 0b1100, // fSAMPLING=fDTS/16, N=8
                fdts_div32_n5 = 0b1101, // fSAMPLING=fDTS/32, N=5
                fdts_div32_n6 = 0b1110, // fSAMPLING=fDTS/32, N=6
                fdts_div32_n8 = 0b1111, // fSAMPLING=fDTS/32, N=8
            };
            pub const Cc2s = enum(u2) {
                ti2 = 0b01, // CC2 channel is configured as input, IC2 is mapped on TI2
                ti1 = 0b10, // CC2 channel is configured as input, IC2 is mapped on TI1
                trc = 0b11, // CC2 channel is configured as input, IC2 is mapped on TRC
            };
            cc1s: Cc1s, // Capture/Compare 1 selection (u2)
            ic1psc: u2, // Input capture 1 prescaler
            ic1f: Ic1f, // Input capture 1 filter (u4)
            cc2s: Cc2s, // Capture/Compare 2 selection (u2)
            ic2psc: u2, // Input capture 2 prescaler
            ic2f: u4, // Input capture 2 filter
            _padding_16_31: u16,
        };
        pub const ccmr1_input = mmio(base_address + 0x18, 32, Ccmr1Input);

        /// address: 0x4001041c
        /// capture/compare mode register 2 (output mode)
        pub const Ccmr2Output = packed struct {
            pub const Cc3s = enum(u2) {
                output = 0b00, // CC3 channel is configured as output
            };
            pub const Oc3pe = enum(u1) {
                disabled = 0, // Preload register on CCR3 disabled. New values written to CCR3 are taken into account immediately
                enabled = 1, // Preload register on CCR3 enabled. Preload value is loaded into active register on each update event
            };
            pub const Oc3m = enum(u3) {
                frozen = 0b000, // The comparison between the output compare register TIMx_CCRy and the counter TIMx_CNT has no effect on the outputs
                active_on_match = 0b001, // Set channel to active level on match. OCyREF signal is forced high when the counter matches the capture/compare register
                inactive_on_match = 0b010, // Set channel to inactive level on match. OCyREF signal is forced low when the counter matches the capture/compare register
                toggle = 0b011, // OCyREF toggles when TIMx_CNT=TIMx_CCRy
                force_inactive = 0b100, // OCyREF is forced low
                force_active = 0b101, // OCyREF is forced high
                pwm_mode1 = 0b110, // In upcounting, channel is active as long as TIMx_CNT<TIMx_CCRy else inactive. In downcounting, channel is inactive as long as TIMx_CNT>TIMx_CCRy else active
                pwm_mode2 = 0b111, // Inversely to PwmMode1
            };
            pub const Cc4s = enum(u2) {
                output = 0b00, // CC4 channel is configured as output
            };
            pub const Oc4pe = enum(u1) {
                disabled = 0, // Preload register on CCR4 disabled. New values written to CCR4 are taken into account immediately
                enabled = 1, // Preload register on CCR4 enabled. Preload value is loaded into active register on each update event
            };
            cc3s: Cc3s, // Capture/Compare 3 selection (u2)
            oc3fe: u1, // Output compare 3 fast enable
            oc3pe: Oc3pe, // Output compare 3 preload enable (u1)
            oc3m: Oc3m, // Output compare 3 mode (u3)
            oc3ce: u1, // Output compare 3 clear enable
            cc4s: Cc4s, // Capture/Compare 4 selection (u2)
            oc4fe: u1, // Output compare 4 fast enable
            oc4pe: Oc4pe, // Output compare 4 preload enable (u1)
            oc4m: Oc3m, // Output compare 4 mode (u3)
            oc4ce: u1, // Output compare 4 clear enable
            _padding_16_31: u16,
        };
        pub const ccmr2_output = mmio(base_address + 0x1c, 32, Ccmr2Output);

        /// address: 0x4001041c
        /// capture/compare mode register 2 (input mode)
        pub const Ccmr2Input = packed struct {
            pub const Cc3s = enum(u2) {
                ti3 = 0b01, // CC3 channel is configured as input, IC3 is mapped on TI3
                ti4 = 0b10, // CC3 channel is configured as input, IC3 is mapped on TI4
                trc = 0b11, // CC3 channel is configured as input, IC3 is mapped on TRC
            };
            pub const Cc4s = enum(u2) {
                ti4 = 0b01, // CC4 channel is configured as input, IC4 is mapped on TI4
                ti3 = 0b10, // CC4 channel is configured as input, IC4 is mapped on TI3
                trc = 0b11, // CC4 channel is configured as input, IC4 is mapped on TRC
            };
            cc3s: Cc3s, // Capture/compare 3 selection (u2)
            ic3psc: u2, // Input capture 3 prescaler
            ic3f: u4, // Input capture 3 filter
            cc4s: Cc4s, // Capture/Compare 4 selection (u2)
            ic4psc: u2, // Input capture 4 prescaler
            ic4f: u4, // Input capture 4 filter
            _padding_16_31: u16,
        };
        pub const ccmr2_input = mmio(base_address + 0x1c, 32, Ccmr2Input);

        /// address: 0x40010420
        /// capture/compare enable register
        pub const Ccer = packed struct {
            cc1e: u1, // Capture/Compare 1 output enable
            cc1p: u1, // Capture/Compare 1 output Polarity
            cc1ne: u1, // Capture/Compare 1 complementary output enable
            cc1np: u1, // Capture/Compare 1 output Polarity
            cc2e: u1, // Capture/Compare 2 output enable
            cc2p: u1, // Capture/Compare 2 output Polarity
            cc2ne: u1, // Capture/Compare 2 complementary output enable
            cc2np: u1, // Capture/Compare 2 output Polarity
            cc3e: u1, // Capture/Compare 3 output enable
            cc3p: u1, // Capture/Compare 3 output Polarity
            cc3ne: u1, // Capture/Compare 3 complementary output enable
            cc3np: u1, // Capture/Compare 3 output Polarity
            cc4e: u1, // Capture/Compare 4 output enable
            cc4p: u1, // Capture/Compare 3 output Polarity
            _padding_14_31: u18,
        };
        pub const ccer = mmio(base_address + 0x20, 32, Ccer);

        /// address: 0x40010424
        /// counter
        pub const cnt = mmioInt(base_address + 0x24, 32, u16);

        /// address: 0x40010428
        /// prescaler
        pub const psc = mmioInt(base_address + 0x28, 32, u16);

        /// address: 0x4001042c
        /// auto-reload register
        pub const arr = mmioInt(base_address + 0x2c, 32, u16);

        /// address: 0x40010434
        /// capture/compare register
        pub const Ccr1 = packed struct {
            ccr: u16, // Capture/Compare value
            _padding_16_31: u16,
        };
        pub const ccr1 = mmio(base_address + 0x34, 32, Ccr1);

        /// address: 0x40010438
        /// capture/compare register
        pub const Ccr2 = packed struct {
            ccr: u16, // Capture/Compare value
            _padding_16_31: u16,
        };
        pub const ccr2 = mmio(base_address + 0x38, 32, Ccr2);

        /// address: 0x4001043c
        /// capture/compare register
        pub const Ccr3 = packed struct {
            ccr: u16, // Capture/Compare value
            _padding_16_31: u16,
        };
        pub const ccr3 = mmio(base_address + 0x3c, 32, Ccr3);

        /// address: 0x40010440
        /// capture/compare register
        pub const Ccr4 = packed struct {
            ccr: u16, // Capture/Compare value
            _padding_16_31: u16,
        };
        pub const ccr4 = mmio(base_address + 0x40, 32, Ccr4);

        /// address: 0x40010448
        /// DMA control register
        pub const Dcr = packed struct {
            dba: u5, // DMA base address
            _reserved_5_7: u3,
            dbl: u5, // DMA burst length
            _padding_13_31: u19,
        };
        pub const dcr = mmio(base_address + 0x48, 32, Dcr);

        /// address: 0x4001044c
        /// DMA address for full transfer
        pub const Dmar = packed struct {
            dmab: u16, // DMA register for burst accesses
            _padding_16_31: u16,
        };
        pub const dmar = mmio(base_address + 0x4c, 32, Dmar);

        /// address: 0x40010430
        /// repetition counter register
        pub const Rcr = packed struct {
            rep: u8, // Repetition counter value
            _padding_8_31: u24,
        };
        pub const rcr = mmio(base_address + 0x30, 32, Rcr);

        /// address: 0x40010444
        /// break and dead-time register
        pub const Bdtr = packed struct {
            pub const Ossi = enum(u1) {
                disabled = 0, // When inactive, OC/OCN outputs are disabled
                idle_level = 1, // When inactive, OC/OCN outputs are forced to idle level
            };
            pub const Ossr = enum(u1) {
                disabled = 0, // When inactive, OC/OCN outputs are disabled
                idle_level = 1, // When inactive, OC/OCN outputs are enabled with their inactive level
            };
            pub const Moe = enum(u1) {
                disabled_idle = 0, // OC/OCN are disabled or forced idle depending on OSSI
                enabled = 1, // OC/OCN are enabled if CCxE/CCxNE are set
            };
            dtg: u8, // Dead-time generator setup
            lock: u2, // Lock configuration
            ossi: Ossi, // Off-state selection for Idle mode (u1)
            ossr: Ossr, // Off-state selection for Run mode (u1)
            bke: u1, // Break enable
            bkp: u1, // Break polarity
            aoe: u1, // Automatic output enable
            moe: Moe, // Main output enable (u1)
            _padding_16_31: u16,
        };
        pub const bdtr = mmio(base_address + 0x44, 32, Bdtr);
    };
    /// General purpose timers
    pub const tim4 = struct {
        pub const base_address = 0x40000800;

        /// address: 0x40000800
        /// control register 1
        pub const Cr1 = packed struct {
            pub const Cen = enum(u1) {
                disabled = 0, // Counter disabled
                enabled = 1, // Counter enabled
            };
            pub const Udis = enum(u1) {
                enabled = 0, // Update event enabled
                disabled = 1, // Update event disabled
            };
            pub const Urs = enum(u1) {
                any_event = 0, // Any of counter overflow/underflow, setting UG, or update through slave mode, generates an update interrupt or DMA request
                counter_only = 1, // Only counter overflow/underflow generates an update interrupt or DMA request
            };
            pub const Opm = enum(u1) {
                disabled = 0, // Counter is not stopped at update event
                enabled = 1, // Counter stops counting at the next update event (clearing the CEN bit)
            };
            pub const Dir = enum(u1) {
                up = 0, // Counter used as upcounter
                down = 1, // Counter used as downcounter
            };
            pub const Cms = enum(u2) {
                edge_aligned = 0b00, // The counter counts up or down depending on the direction bit
                center_aligned1 = 0b01, // The counter counts up and down alternatively. Output compare interrupt flags are set only when the counter is counting down.
                center_aligned2 = 0b10, // The counter counts up and down alternatively. Output compare interrupt flags are set only when the counter is counting up.
                center_aligned3 = 0b11, // The counter counts up and down alternatively. Output compare interrupt flags are set both when the counter is counting up or down.
            };
            pub const Arpe = enum(u1) {
                disabled = 0, // TIMx_APRR register is not buffered
                enabled = 1, // TIMx_APRR register is buffered
            };
            pub const Ckd = enum(u2) {
                div1 = 0b00, // t_DTS = t_CK_INT
                div2 = 0b01, // t_DTS = 2  t_CK_INT
                div4 = 0b10, // t_DTS = 4  t_CK_INT
            };
            cen: Cen, // Counter enable (u1)
            udis: Udis, // Update disable (u1)
            urs: Urs, // Update request source (u1)
            opm: Opm, // One-pulse mode (u1)
            dir: Dir, // Direction (u1)
            cms: Cms, // Center-aligned mode selection (u2)
            arpe: Arpe, // Auto-reload preload enable (u1)
            ckd: Ckd, // Clock division (u2)
            _padding_10_31: u22,
        };
        pub const cr1 = mmio(base_address + 0x0, 32, Cr1);

        /// address: 0x40000804
        /// control register 2
        pub const Cr2 = packed struct {
            pub const Ccds = enum(u1) {
                on_compare = 0, // CCx DMA request sent when CCx event occurs
                on_update = 1, // CCx DMA request sent when update event occurs
            };
            pub const Mms = enum(u3) {
                reset = 0b000, // The UG bit from the TIMx_EGR register is used as trigger output
                enable = 0b001, // The counter enable signal, CNT_EN, is used as trigger output
                update = 0b010, // The update event is selected as trigger output
                compare_pulse = 0b011, // The trigger output send a positive pulse when the CC1IF flag it to be set, as soon as a capture or a compare match occurred
                compare_oc1 = 0b100, // OC1REF signal is used as trigger output
                compare_oc2 = 0b101, // OC2REF signal is used as trigger output
                compare_oc3 = 0b110, // OC3REF signal is used as trigger output
                compare_oc4 = 0b111, // OC4REF signal is used as trigger output
            };
            pub const Ti1s = enum(u1) {
                normal = 0, // The TIMx_CH1 pin is connected to TI1 input
                xor = 1, // The TIMx_CH1, CH2, CH3 pins are connected to TI1 input
            };
            _reserved_0_2: u3,
            ccds: Ccds, // Capture/compare DMA selection (u1)
            mms: Mms, // Master mode selection (u3)
            ti1s: Ti1s, // TI1 selection (u1)
            _padding_8_31: u24,
        };
        pub const cr2 = mmio(base_address + 0x4, 32, Cr2);

        /// address: 0x40000808
        /// slave mode control register
        pub const Smcr = packed struct {
            pub const Sms = enum(u3) {
                disabled = 0b000, // Slave mode disabled - if CEN = 1 then the prescaler is clocked directly by the internal clock.
                encoder_mode_1 = 0b001, // Encoder mode 1 - Counter counts up/down on TI2FP1 edge depending on TI1FP2 level.
                encoder_mode_2 = 0b010, // Encoder mode 2 - Counter counts up/down on TI1FP2 edge depending on TI2FP1 level.
                encoder_mode_3 = 0b011, // Encoder mode 3 - Counter counts up/down on both TI1FP1 and TI2FP2 edges depending on the level of the other input.
                reset_mode = 0b100, // Reset Mode - Rising edge of the selected trigger input (TRGI) reinitializes the counter and generates an update of the registers.
                gated_mode = 0b101, // Gated Mode - The counter clock is enabled when the trigger input (TRGI) is high. The counter stops (but is not reset) as soon as the trigger becomes low. Both start and stop of the counter are controlled.
                trigger_mode = 0b110, // Trigger Mode - The counter starts at a rising edge of the trigger TRGI (but it is not reset). Only the start of the counter is controlled.
                ext_clock_mode = 0b111, // External Clock Mode 1 - Rising edges of the selected trigger (TRGI) clock the counter.
            };
            pub const Ts = enum(u3) {
                itr0 = 0b000, // Internal Trigger 0 (ITR0)
                itr1 = 0b001, // Internal Trigger 1 (ITR1)
                itr2 = 0b010, // Internal Trigger 2 (ITR2)
                ti1_f_ed = 0b100, // TI1 Edge Detector (TI1F_ED)
                ti1_fp1 = 0b101, // Filtered Timer Input 1 (TI1FP1)
                ti2_fp2 = 0b110, // Filtered Timer Input 2 (TI2FP2)
                etrf = 0b111, // External Trigger input (ETRF)
            };
            pub const Msm = enum(u1) {
                no_sync = 0, // No action
                sync = 1, // The effect of an event on the trigger input (TRGI) is delayed to allow a perfect synchronization between the current timer and its slaves (through TRGO). It is useful if we want to synchronize several timers on a single external event.
            };
            pub const Etf = enum(u4) {
                no_filter = 0b0000, // No filter, sampling is done at fDTS
                fck_int_n2 = 0b0001, // fSAMPLING=fCK_INT, N=2
                fck_int_n4 = 0b0010, // fSAMPLING=fCK_INT, N=4
                fck_int_n8 = 0b0011, // fSAMPLING=fCK_INT, N=8
                fdts_div2_n6 = 0b0100, // fSAMPLING=fDTS/2, N=6
                fdts_div2_n8 = 0b0101, // fSAMPLING=fDTS/2, N=8
                fdts_div4_n6 = 0b0110, // fSAMPLING=fDTS/4, N=6
                fdts_div4_n8 = 0b0111, // fSAMPLING=fDTS/4, N=8
                fdts_div8_n6 = 0b1000, // fSAMPLING=fDTS/8, N=6
                fdts_div8_n8 = 0b1001, // fSAMPLING=fDTS/8, N=8
                fdts_div16_n5 = 0b1010, // fSAMPLING=fDTS/16, N=5
                fdts_div16_n6 = 0b1011, // fSAMPLING=fDTS/16, N=6
                fdts_div16_n8 = 0b1100, // fSAMPLING=fDTS/16, N=8
                fdts_div32_n5 = 0b1101, // fSAMPLING=fDTS/32, N=5
                fdts_div32_n6 = 0b1110, // fSAMPLING=fDTS/32, N=6
                fdts_div32_n8 = 0b1111, // fSAMPLING=fDTS/32, N=8
            };
            pub const Etps = enum(u2) {
                div1 = 0b00, // Prescaler OFF
                div2 = 0b01, // ETRP frequency divided by 2
                div4 = 0b10, // ETRP frequency divided by 4
                div8 = 0b11, // ETRP frequency divided by 8
            };
            pub const Ece = enum(u1) {
                disabled = 0, // External clock mode 2 disabled
                enabled = 1, // External clock mode 2 enabled. The counter is clocked by any active edge on the ETRF signal.
            };
            pub const Etp = enum(u1) {
                not_inverted = 0, // ETR is noninverted, active at high level or rising edge
                inverted = 1, // ETR is inverted, active at low level or falling edge
            };
            sms: Sms, // Slave mode selection (u3)
            _reserved_3_3: u1,
            ts: Ts, // Trigger selection (u3)
            msm: Msm, // Master/Slave mode (u1)
            etf: Etf, // External trigger filter (u4)
            etps: Etps, // External trigger prescaler (u2)
            ece: Ece, // External clock enable (u1)
            etp: Etp, // External trigger polarity (u1)
            _padding_16_31: u16,
        };
        pub const smcr = mmio(base_address + 0x8, 32, Smcr);

        /// address: 0x4000080c
        /// DMA/Interrupt enable register
        pub const Dier = packed struct {
            pub const Uie = enum(u1) {
                disabled = 0, // Update interrupt disabled
                enabled = 1, // Update interrupt enabled
            };
            pub const Cc1ie = enum(u1) {
                disabled = 0, // CCx interrupt disabled
                enabled = 1, // CCx interrupt enabled
            };
            pub const Tie = enum(u1) {
                disabled = 0, // Trigger interrupt disabled
                enabled = 1, // Trigger interrupt enabled
            };
            pub const Ude = enum(u1) {
                disabled = 0, // Update DMA request disabled
                enabled = 1, // Update DMA request enabled
            };
            pub const Cc1de = enum(u1) {
                disabled = 0, // CCx DMA request disabled
                enabled = 1, // CCx DMA request enabled
            };
            pub const Tde = enum(u1) {
                disabled = 0, // Trigger DMA request disabled
                enabled = 1, // Trigger DMA request enabled
            };
            uie: Uie, // Update interrupt enable (u1)
            cc1ie: Cc1ie, // Capture/Compare 1 interrupt enable (u1)
            cc2ie: Cc1ie, // Capture/Compare 2 interrupt enable (u1)
            cc3ie: Cc1ie, // Capture/Compare 3 interrupt enable (u1)
            cc4ie: Cc1ie, // Capture/Compare 4 interrupt enable (u1)
            _reserved_5_5: u1,
            tie: Tie, // Trigger interrupt enable (u1)
            _reserved_7_7: u1,
            ude: Ude, // Update DMA request enable (u1)
            cc1de: Cc1de, // Capture/Compare 1 DMA request enable (u1)
            cc2de: Cc1de, // Capture/Compare 2 DMA request enable (u1)
            cc3de: Cc1de, // Capture/Compare 3 DMA request enable (u1)
            cc4de: Cc1de, // Capture/Compare 4 DMA request enable (u1)
            _reserved_13_13: u1,
            tde: Tde, // Trigger DMA request enable (u1)
            _padding_15_31: u17,
        };
        pub const dier = mmio(base_address + 0xc, 32, Dier);

        /// address: 0x40000810
        /// status register
        pub const Sr = packed struct {
            pub const Uif = enum(u1) {
                clear = 0, // No update occurred
                update_pending = 1, // Update interrupt pending.
            };
            pub const Cc1if = enum(u1) {
                match = 1, // If CC1 is an output: The content of the counter TIMx_CNT matches the content of the TIMx_CCR1 register. If CC1 is an input: The counter value has been captured in TIMx_CCR1 register.
                clear = 0, // Clear flag
            };
            pub const Tif = enum(u1) {
                no_trigger = 0, // No trigger event occurred
                trigger = 1, // Trigger interrupt pending
                pub const clear = @intToEnum(Tif, 0); // Clear flag
            };
            pub const Cc1of = enum(u1) {
                overcapture = 1, // The counter value has been captured in TIMx_CCRx register while CCxIF flag was already set
                clear = 0, // Clear flag
            };
            uif: Uif, // Update interrupt flag (u1)
            cc1if: Cc1if, // Capture/compare 1 interrupt flag (u1)
            cc2if: Cc1if, // Capture/Compare 2 interrupt flag (u1)
            cc3if: Cc1if, // Capture/Compare 3 interrupt flag (u1)
            cc4if: Cc1if, // Capture/Compare 4 interrupt flag (u1)
            _reserved_5_5: u1,
            tif: Tif, // Trigger interrupt flag (u1)
            _reserved_7_8: u2,
            cc1of: Cc1of, // Capture/Compare 1 overcapture flag (u1)
            cc2of: Cc1of, // Capture/compare 2 overcapture flag (u1)
            cc3of: Cc1of, // Capture/Compare 3 overcapture flag (u1)
            cc4of: Cc1of, // Capture/Compare 4 overcapture flag (u1)
            _padding_13_31: u19,
        };
        pub const sr = mmio(base_address + 0x10, 32, Sr);

        /// address: 0x40000814
        /// event generation register
        pub const Egr = packed struct {
            pub const Ug = enum(u1) {
                update = 1, // Re-initializes the timer counter and generates an update of the registers.
            };
            pub const Cc1gw = enum(u1) {
                trigger = 1, // If CC1 is an output: CC1IF flag is set, Corresponding interrupt or DMA request is sent if enabled. If CC1 is an input: The current value of the counter is captured in TIMx_CCR1 register.
            };
            pub const Tgw = enum(u1) {
                trigger = 1, // The TIF flag is set in TIMx_SR register. Related interrupt or DMA transfer can occur if enabled.
            };
            ug: Ug, // Update generation (u1)
            cc1g: Cc1gw, // Capture/compare 1 generation (u1)
            cc2g: Cc1gw, // Capture/compare 2 generation (u1)
            cc3g: Cc1gw, // Capture/compare 3 generation (u1)
            cc4g: Cc1gw, // Capture/compare 4 generation (u1)
            _reserved_5_5: u1,
            tg: Tgw, // Trigger generation (u1)
            _padding_7_31: u25,
        };
        pub const egr = mmio(base_address + 0x14, 32, Egr);

        /// address: 0x40000818
        /// capture/compare mode register 1 (output mode)
        pub const Ccmr1Output = packed struct {
            pub const Cc1s = enum(u2) {
                output = 0b00, // CC1 channel is configured as output
            };
            pub const Oc1pe = enum(u1) {
                disabled = 0, // Preload register on CCR1 disabled. New values written to CCR1 are taken into account immediately
                enabled = 1, // Preload register on CCR1 enabled. Preload value is loaded into active register on each update event
            };
            pub const Oc1m = enum(u3) {
                frozen = 0b000, // The comparison between the output compare register TIMx_CCRy and the counter TIMx_CNT has no effect on the outputs
                active_on_match = 0b001, // Set channel to active level on match. OCyREF signal is forced high when the counter matches the capture/compare register
                inactive_on_match = 0b010, // Set channel to inactive level on match. OCyREF signal is forced low when the counter matches the capture/compare register
                toggle = 0b011, // OCyREF toggles when TIMx_CNT=TIMx_CCRy
                force_inactive = 0b100, // OCyREF is forced low
                force_active = 0b101, // OCyREF is forced high
                pwm_mode1 = 0b110, // In upcounting, channel is active as long as TIMx_CNT<TIMx_CCRy else inactive. In downcounting, channel is inactive as long as TIMx_CNT>TIMx_CCRy else active
                pwm_mode2 = 0b111, // Inversely to PwmMode1
            };
            pub const Cc2s = enum(u2) {
                output = 0b00, // CC2 channel is configured as output
            };
            pub const Oc2pe = enum(u1) {
                disabled = 0, // Preload register on CCR2 disabled. New values written to CCR2 are taken into account immediately
                enabled = 1, // Preload register on CCR2 enabled. Preload value is loaded into active register on each update event
            };
            cc1s: Cc1s, // CC1S (u2)
            oc1fe: u1, // OC1FE
            oc1pe: Oc1pe, // OC1PE (u1)
            oc1m: Oc1m, // OC1M (u3)
            oc1ce: u1, // OC1CE
            cc2s: Cc2s, // CC2S (u2)
            oc2fe: u1, // OC2FE
            oc2pe: Oc2pe, // OC2PE (u1)
            oc2m: Oc1m, // OC2M (u3)
            oc2ce: u1, // OC2CE
            _padding_16_31: u16,
        };
        pub const ccmr1_output = mmio(base_address + 0x18, 32, Ccmr1Output);

        /// address: 0x40000818
        /// capture/compare mode register 1 (input mode)
        pub const Ccmr1Input = packed struct {
            pub const Cc1s = enum(u2) {
                ti1 = 0b01, // CC1 channel is configured as input, IC1 is mapped on TI1
                ti2 = 0b10, // CC1 channel is configured as input, IC1 is mapped on TI2
                trc = 0b11, // CC1 channel is configured as input, IC1 is mapped on TRC
            };
            pub const Ic1f = enum(u4) {
                no_filter = 0b0000, // No filter, sampling is done at fDTS
                fck_int_n2 = 0b0001, // fSAMPLING=fCK_INT, N=2
                fck_int_n4 = 0b0010, // fSAMPLING=fCK_INT, N=4
                fck_int_n8 = 0b0011, // fSAMPLING=fCK_INT, N=8
                fdts_div2_n6 = 0b0100, // fSAMPLING=fDTS/2, N=6
                fdts_div2_n8 = 0b0101, // fSAMPLING=fDTS/2, N=8
                fdts_div4_n6 = 0b0110, // fSAMPLING=fDTS/4, N=6
                fdts_div4_n8 = 0b0111, // fSAMPLING=fDTS/4, N=8
                fdts_div8_n6 = 0b1000, // fSAMPLING=fDTS/8, N=6
                fdts_div8_n8 = 0b1001, // fSAMPLING=fDTS/8, N=8
                fdts_div16_n5 = 0b1010, // fSAMPLING=fDTS/16, N=5
                fdts_div16_n6 = 0b1011, // fSAMPLING=fDTS/16, N=6
                fdts_div16_n8 = 0b1100, // fSAMPLING=fDTS/16, N=8
                fdts_div32_n5 = 0b1101, // fSAMPLING=fDTS/32, N=5
                fdts_div32_n6 = 0b1110, // fSAMPLING=fDTS/32, N=6
                fdts_div32_n8 = 0b1111, // fSAMPLING=fDTS/32, N=8
            };
            pub const Cc2s = enum(u2) {
                ti2 = 0b01, // CC2 channel is configured as input, IC2 is mapped on TI2
                ti1 = 0b10, // CC2 channel is configured as input, IC2 is mapped on TI1
                trc = 0b11, // CC2 channel is configured as input, IC2 is mapped on TRC
            };
            cc1s: Cc1s, // Capture/Compare 1 selection (u2)
            ic1psc: u2, // Input capture 1 prescaler
            ic1f: Ic1f, // Input capture 1 filter (u4)
            cc2s: Cc2s, // Capture/Compare 2 selection (u2)
            ic2psc: u2, // Input capture 2 prescaler
            ic2f: u4, // Input capture 2 filter
            _padding_16_31: u16,
        };
        pub const ccmr1_input = mmio(base_address + 0x18, 32, Ccmr1Input);

        /// address: 0x4000081c
        /// capture/compare mode register 2 (output mode)
        pub const Ccmr2Output = packed struct {
            pub const Cc3s = enum(u2) {
                output = 0b00, // CC3 channel is configured as output
            };
            pub const Oc3pe = enum(u1) {
                disabled = 0, // Preload register on CCR3 disabled. New values written to CCR3 are taken into account immediately
                enabled = 1, // Preload register on CCR3 enabled. Preload value is loaded into active register on each update event
            };
            pub const Oc3m = enum(u3) {
                frozen = 0b000, // The comparison between the output compare register TIMx_CCRy and the counter TIMx_CNT has no effect on the outputs
                active_on_match = 0b001, // Set channel to active level on match. OCyREF signal is forced high when the counter matches the capture/compare register
                inactive_on_match = 0b010, // Set channel to inactive level on match. OCyREF signal is forced low when the counter matches the capture/compare register
                toggle = 0b011, // OCyREF toggles when TIMx_CNT=TIMx_CCRy
                force_inactive = 0b100, // OCyREF is forced low
                force_active = 0b101, // OCyREF is forced high
                pwm_mode1 = 0b110, // In upcounting, channel is active as long as TIMx_CNT<TIMx_CCRy else inactive. In downcounting, channel is inactive as long as TIMx_CNT>TIMx_CCRy else active
                pwm_mode2 = 0b111, // Inversely to PwmMode1
            };
            pub const Cc4s = enum(u2) {
                output = 0b00, // CC4 channel is configured as output
            };
            pub const Oc4pe = enum(u1) {
                disabled = 0, // Preload register on CCR4 disabled. New values written to CCR4 are taken into account immediately
                enabled = 1, // Preload register on CCR4 enabled. Preload value is loaded into active register on each update event
            };
            cc3s: Cc3s, // CC3S (u2)
            oc3fe: u1, // OC3FE
            oc3pe: Oc3pe, // OC3PE (u1)
            oc3m: Oc3m, // OC3M (u3)
            oc3ce: u1, // OC3CE
            cc4s: Cc4s, // CC4S (u2)
            oc4fe: u1, // OC4FE
            oc4pe: Oc4pe, // OC4PE (u1)
            oc4m: Oc3m, // OC4M (u3)
            oc4ce: u1, // O24CE
            _padding_16_31: u16,
        };
        pub const ccmr2_output = mmio(base_address + 0x1c, 32, Ccmr2Output);

        /// address: 0x4000081c
        /// capture/compare mode register 2 (input mode)
        pub const Ccmr2Input = packed struct {
            pub const Cc3s = enum(u2) {
                ti3 = 0b01, // CC3 channel is configured as input, IC3 is mapped on TI3
                ti4 = 0b10, // CC3 channel is configured as input, IC3 is mapped on TI4
                trc = 0b11, // CC3 channel is configured as input, IC3 is mapped on TRC
            };
            pub const Cc4s = enum(u2) {
                ti4 = 0b01, // CC4 channel is configured as input, IC4 is mapped on TI4
                ti3 = 0b10, // CC4 channel is configured as input, IC4 is mapped on TI3
                trc = 0b11, // CC4 channel is configured as input, IC4 is mapped on TRC
            };
            cc3s: Cc3s, // Capture/compare 3 selection (u2)
            ic3psc: u2, // Input capture 3 prescaler
            ic3f: u4, // Input capture 3 filter
            cc4s: Cc4s, // Capture/Compare 4 selection (u2)
            ic4psc: u2, // Input capture 4 prescaler
            ic4f: u4, // Input capture 4 filter
            _padding_16_31: u16,
        };
        pub const ccmr2_input = mmio(base_address + 0x1c, 32, Ccmr2Input);

        /// address: 0x40000820
        /// capture/compare enable register
        pub const Ccer = packed struct {
            cc1e: u1, // Capture/Compare 1 output enable
            cc1p: u1, // Capture/Compare 1 output Polarity
            _reserved_2_2: u1,
            cc1np: u1, // Capture/Compare 1 output Polarity
            cc2e: u1, // Capture/Compare 2 output enable
            cc2p: u1, // Capture/Compare 2 output Polarity
            _reserved_6_6: u1,
            cc2np: u1, // Capture/Compare 2 output Polarity
            cc3e: u1, // Capture/Compare 3 output enable
            cc3p: u1, // Capture/Compare 3 output Polarity
            _reserved_10_10: u1,
            cc3np: u1, // Capture/Compare 3 output Polarity
            cc4e: u1, // Capture/Compare 4 output enable
            cc4p: u1, // Capture/Compare 3 output Polarity
            _reserved_14_14: u1,
            cc4np: u1, // Capture/Compare 4 output Polarity
            _padding_16_31: u16,
        };
        pub const ccer = mmio(base_address + 0x20, 32, Ccer);

        /// address: 0x40000824
        /// counter
        pub const cnt = mmioInt(base_address + 0x24, 32, u16);

        /// address: 0x40000828
        /// prescaler
        pub const psc = mmioInt(base_address + 0x28, 32, u16);

        /// address: 0x4000082c
        /// auto-reload register
        pub const arr = mmioInt(base_address + 0x2c, 32, u16);

        /// address: 0x40000834
        /// capture/compare register
        pub const Ccr1 = packed struct {
            ccr: u16, // Capture/Compare value
            _padding_16_31: u16,
        };
        pub const ccr1 = mmio(base_address + 0x34, 32, Ccr1);

        /// address: 0x40000838
        /// capture/compare register
        pub const Ccr2 = packed struct {
            ccr: u16, // Capture/Compare value
            _padding_16_31: u16,
        };
        pub const ccr2 = mmio(base_address + 0x38, 32, Ccr2);

        /// address: 0x4000083c
        /// capture/compare register
        pub const Ccr3 = packed struct {
            ccr: u16, // Capture/Compare value
            _padding_16_31: u16,
        };
        pub const ccr3 = mmio(base_address + 0x3c, 32, Ccr3);

        /// address: 0x40000840
        /// capture/compare register
        pub const Ccr4 = packed struct {
            ccr: u16, // Capture/Compare value
            _padding_16_31: u16,
        };
        pub const ccr4 = mmio(base_address + 0x40, 32, Ccr4);

        /// address: 0x40000848
        /// DMA control register
        pub const Dcr = packed struct {
            dba: u5, // DMA base address
            _reserved_5_7: u3,
            dbl: u5, // DMA burst length
            _padding_13_31: u19,
        };
        pub const dcr = mmio(base_address + 0x48, 32, Dcr);

        /// address: 0x4000084c
        /// DMA address for full transfer
        pub const Dmar = packed struct {
            dmab: u16, // DMA register for burst accesses
            _padding_16_31: u16,
        };
        pub const dmar = mmio(base_address + 0x4c, 32, Dmar);
    };
    /// Universal synchronous asynchronous receiver transmitter
    pub const usart2 = struct {
        pub const base_address = 0x40004400;

        /// address: 0x40004400
        /// Status register
        pub const Sr = packed struct {
            pe: u1, // Parity error
            fe: u1, // Framing error
            nf: u1, // Noise detected flag
            ore: u1, // Overrun error
            idle: u1, // IDLE line detected
            rxne: u1, // Read data register not empty
            tc: u1, // Transmission complete
            txe: u1, // Transmit data register empty
            lbd: u1, // LIN break detection flag
            cts: u1, // CTS flag
            _padding_10_31: u22,
        };
        pub const sr = mmio(base_address + 0x0, 32, Sr);

        /// address: 0x40004404
        /// Data register
        pub const dr = mmioInt(base_address + 0x4, 32, u9);

        /// address: 0x40004408
        /// Baud rate register
        pub const Brr = packed struct {
            div_fraction: u4, // fraction of USARTDIV
            div_mantissa: u12, // mantissa of USARTDIV
            _padding_16_31: u16,
        };
        pub const brr = mmio(base_address + 0x8, 32, Brr);

        /// address: 0x4000440c
        /// Control register 1
        pub const Cr1 = packed struct {
            pub const Sbk = enum(u1) {
                no_break = 0, // No break character is transmitted
                @"break" = 1, // Break character transmitted
            };
            pub const Rwu = enum(u1) {
                active = 0, // Receiver in active mode
                mute = 1, // Receiver in mute mode
            };
            pub const Re = enum(u1) {
                disabled = 0, // Receiver disabled
                enabled = 1, // Receiver enabled
            };
            pub const Te = enum(u1) {
                disabled = 0, // Transmitter disabled
                enabled = 1, // Transmitter enabled
            };
            pub const Idleie = enum(u1) {
                disabled = 0, // IDLE interrupt disabled
                enabled = 1, // IDLE interrupt enabled
            };
            pub const Rxneie = enum(u1) {
                disabled = 0, // RXNE interrupt disabled
                enabled = 1, // RXNE interrupt enabled
            };
            pub const Tcie = enum(u1) {
                disabled = 0, // TC interrupt disabled
                enabled = 1, // TC interrupt enabled
            };
            pub const Txeie = enum(u1) {
                disabled = 0, // TXE interrupt disabled
                enabled = 1, // TXE interrupt enabled
            };
            pub const Peie = enum(u1) {
                disabled = 0, // PE interrupt disabled
                enabled = 1, // PE interrupt enabled
            };
            pub const Ps = enum(u1) {
                even = 0, // Even parity
                odd = 1, // Odd parity
            };
            pub const Pce = enum(u1) {
                disabled = 0, // Parity control disabled
                enabled = 1, // Parity control enabled
            };
            pub const Wake = enum(u1) {
                idle_line = 0, // USART wakeup on idle line
                address_mark = 1, // USART wakeup on address mark
            };
            pub const M = enum(u1) {
                m8 = 0, // 8 data bits
                m9 = 1, // 9 data bits
            };
            pub const Ue = enum(u1) {
                disabled = 0, // USART prescaler and outputs disabled
                enabled = 1, // USART enabled
            };
            pub const Over8 = enum(u1) {
                oversample16 = 0, // Oversampling by 16
                oversample8 = 1, // Oversampling by 8
            };
            sbk: Sbk, // Send break (u1)
            rwu: Rwu, // Receiver wakeup (u1)
            re: Re, // Receiver enable (u1)
            te: Te, // Transmitter enable (u1)
            idleie: Idleie, // IDLE interrupt enable (u1)
            rxneie: Rxneie, // RXNE interrupt enable (u1)
            tcie: Tcie, // Transmission complete interrupt enable (u1)
            txeie: Txeie, // TXE interrupt enable (u1)
            peie: Peie, // PE interrupt enable (u1)
            ps: Ps, // Parity selection (u1)
            pce: Pce, // Parity control enable (u1)
            wake: Wake, // Wakeup method (u1)
            m: M, // Word length (u1)
            ue: Ue, // USART enable (u1)
            _reserved_14_14: u1,
            over8: Over8, // Oversampling mode (u1)
            _padding_16_31: u16,
        };
        pub const cr1 = mmio(base_address + 0xc, 32, Cr1);

        /// address: 0x40004410
        /// Control register 2
        pub const Cr2 = packed struct {
            pub const Lbdl = enum(u1) {
                lbdl10 = 0, // 10-bit break detection
                lbdl11 = 1, // 11-bit break detection
            };
            pub const Lbdie = enum(u1) {
                disabled = 0, // LIN break detection interrupt disabled
                enabled = 1, // LIN break detection interrupt enabled
            };
            pub const Cpha = enum(u1) {
                first = 0, // The first clock transition is the first data capture edge
                second = 1, // The second clock transition is the first data capture edge
            };
            pub const Cpol = enum(u1) {
                low = 0, // Steady low value on CK pin outside transmission window
                high = 1, // Steady high value on CK pin outside transmission window
            };
            pub const Clken = enum(u1) {
                disabled = 0, // CK pin disabled
                enabled = 1, // CK pin enabled
            };
            pub const Stop = enum(u2) {
                stop1 = 0b00, // 1 stop bit
                stop0p5 = 0b01, // 0.5 stop bits
                stop2 = 0b10, // 2 stop bits
                stop1p5 = 0b11, // 1.5 stop bits
            };
            pub const Linen = enum(u1) {
                disabled = 0, // LIN mode disabled
                enabled = 1, // LIN mode enabled
            };
            add: u4, // Address of the USART node
            _reserved_4_4: u1,
            lbdl: Lbdl, // lin break detection length (u1)
            lbdie: Lbdie, // LIN break detection interrupt enable (u1)
            _reserved_7_7: u1,
            lbcl: u1, // Last bit clock pulse
            cpha: Cpha, // Clock phase (u1)
            cpol: Cpol, // Clock polarity (u1)
            clken: Clken, // Clock enable (u1)
            stop: Stop, // STOP bits (u2)
            linen: Linen, // LIN mode enable (u1)
            _padding_15_31: u17,
        };
        pub const cr2 = mmio(base_address + 0x10, 32, Cr2);

        /// address: 0x40004414
        /// Control register 3
        pub const Cr3 = packed struct {
            pub const Eie = enum(u1) {
                disabled = 0, // Error interrupt disabled
                enabled = 1, // Error interrupt enabled
            };
            pub const Iren = enum(u1) {
                disabled = 0, // IrDA disabled
                enabled = 1, // IrDA enabled
            };
            pub const Irlp = enum(u1) {
                normal = 0, // Normal mode
                low_power = 1, // Low-power mode
            };
            pub const Hdsel = enum(u1) {
                full_duplex = 0, // Half duplex mode is not selected
                half_duplex = 1, // Half duplex mode is selected
            };
            pub const Nack = enum(u1) {
                disabled = 0, // NACK transmission in case of parity error is disabled
                enabled = 1, // NACK transmission during parity error is enabled
            };
            pub const Scen = enum(u1) {
                disabled = 0, // Smartcard mode disabled
                enabled = 1, // Smartcard mode enabled
            };
            pub const Dmar = enum(u1) {
                disabled = 0, // DMA mode is disabled for reception
                enabled = 1, // DMA mode is enabled for reception
            };
            pub const Dmat = enum(u1) {
                disabled = 0, // DMA mode is disabled for transmission
                enabled = 1, // DMA mode is enabled for transmission
            };
            pub const Rtse = enum(u1) {
                disabled = 0, // RTS hardware flow control disabled
                enabled = 1, // RTS hardware flow control enabled
            };
            pub const Ctse = enum(u1) {
                disabled = 0, // CTS hardware flow control disabled
                enabled = 1, // CTS hardware flow control enabled
            };
            pub const Ctsie = enum(u1) {
                disabled = 0, // CTS interrupt disabled
                enabled = 1, // CTS interrupt enabled
            };
            pub const Onebit = enum(u1) {
                sample3 = 0, // Three sample bit method
                sample1 = 1, // One sample bit method
            };
            eie: Eie, // Error interrupt enable (u1)
            iren: Iren, // IrDA mode enable (u1)
            irlp: Irlp, // IrDA low-power (u1)
            hdsel: Hdsel, // Half-duplex selection (u1)
            nack: Nack, // Smartcard NACK enable (u1)
            scen: Scen, // Smartcard mode enable (u1)
            dmar: Dmar, // DMA enable receiver (u1)
            dmat: Dmat, // DMA enable transmitter (u1)
            rtse: Rtse, // RTS enable (u1)
            ctse: Ctse, // CTS enable (u1)
            ctsie: Ctsie, // CTS interrupt enable (u1)
            onebit: Onebit, // One sample bit method enable (u1)
            _padding_12_31: u20,
        };
        pub const cr3 = mmio(base_address + 0x14, 32, Cr3);

        /// address: 0x40004418
        /// Guard time and prescaler register
        pub const Gtpr = packed struct {
            psc: u8, // Prescaler value
            gt: u8, // Guard time value
            _padding_16_31: u16,
        };
        pub const gtpr = mmio(base_address + 0x18, 32, Gtpr);
    };
    /// Universal synchronous asynchronous receiver transmitter
    pub const usart6 = struct {
        pub const base_address = 0x40011400;

        /// address: 0x40011400
        /// Status register
        pub const Sr = packed struct {
            pe: u1, // Parity error
            fe: u1, // Framing error
            nf: u1, // Noise detected flag
            ore: u1, // Overrun error
            idle: u1, // IDLE line detected
            rxne: u1, // Read data register not empty
            tc: u1, // Transmission complete
            txe: u1, // Transmit data register empty
            lbd: u1, // LIN break detection flag
            cts: u1, // CTS flag
            _padding_10_31: u22,
        };
        pub const sr = mmio(base_address + 0x0, 32, Sr);

        /// address: 0x40011404
        /// Data register
        pub const dr = mmioInt(base_address + 0x4, 32, u9);

        /// address: 0x40011408
        /// Baud rate register
        pub const Brr = packed struct {
            div_fraction: u4, // fraction of USARTDIV
            div_mantissa: u12, // mantissa of USARTDIV
            _padding_16_31: u16,
        };
        pub const brr = mmio(base_address + 0x8, 32, Brr);

        /// address: 0x4001140c
        /// Control register 1
        pub const Cr1 = packed struct {
            pub const Sbk = enum(u1) {
                no_break = 0, // No break character is transmitted
                @"break" = 1, // Break character transmitted
            };
            pub const Rwu = enum(u1) {
                active = 0, // Receiver in active mode
                mute = 1, // Receiver in mute mode
            };
            pub const Re = enum(u1) {
                disabled = 0, // Receiver disabled
                enabled = 1, // Receiver enabled
            };
            pub const Te = enum(u1) {
                disabled = 0, // Transmitter disabled
                enabled = 1, // Transmitter enabled
            };
            pub const Idleie = enum(u1) {
                disabled = 0, // IDLE interrupt disabled
                enabled = 1, // IDLE interrupt enabled
            };
            pub const Rxneie = enum(u1) {
                disabled = 0, // RXNE interrupt disabled
                enabled = 1, // RXNE interrupt enabled
            };
            pub const Tcie = enum(u1) {
                disabled = 0, // TC interrupt disabled
                enabled = 1, // TC interrupt enabled
            };
            pub const Txeie = enum(u1) {
                disabled = 0, // TXE interrupt disabled
                enabled = 1, // TXE interrupt enabled
            };
            pub const Peie = enum(u1) {
                disabled = 0, // PE interrupt disabled
                enabled = 1, // PE interrupt enabled
            };
            pub const Ps = enum(u1) {
                even = 0, // Even parity
                odd = 1, // Odd parity
            };
            pub const Pce = enum(u1) {
                disabled = 0, // Parity control disabled
                enabled = 1, // Parity control enabled
            };
            pub const Wake = enum(u1) {
                idle_line = 0, // USART wakeup on idle line
                address_mark = 1, // USART wakeup on address mark
            };
            pub const M = enum(u1) {
                m8 = 0, // 8 data bits
                m9 = 1, // 9 data bits
            };
            pub const Ue = enum(u1) {
                disabled = 0, // USART prescaler and outputs disabled
                enabled = 1, // USART enabled
            };
            pub const Over8 = enum(u1) {
                oversample16 = 0, // Oversampling by 16
                oversample8 = 1, // Oversampling by 8
            };
            sbk: Sbk, // Send break (u1)
            rwu: Rwu, // Receiver wakeup (u1)
            re: Re, // Receiver enable (u1)
            te: Te, // Transmitter enable (u1)
            idleie: Idleie, // IDLE interrupt enable (u1)
            rxneie: Rxneie, // RXNE interrupt enable (u1)
            tcie: Tcie, // Transmission complete interrupt enable (u1)
            txeie: Txeie, // TXE interrupt enable (u1)
            peie: Peie, // PE interrupt enable (u1)
            ps: Ps, // Parity selection (u1)
            pce: Pce, // Parity control enable (u1)
            wake: Wake, // Wakeup method (u1)
            m: M, // Word length (u1)
            ue: Ue, // USART enable (u1)
            _reserved_14_14: u1,
            over8: Over8, // Oversampling mode (u1)
            _padding_16_31: u16,
        };
        pub const cr1 = mmio(base_address + 0xc, 32, Cr1);

        /// address: 0x40011410
        /// Control register 2
        pub const Cr2 = packed struct {
            pub const Lbdl = enum(u1) {
                lbdl10 = 0, // 10-bit break detection
                lbdl11 = 1, // 11-bit break detection
            };
            pub const Lbdie = enum(u1) {
                disabled = 0, // LIN break detection interrupt disabled
                enabled = 1, // LIN break detection interrupt enabled
            };
            pub const Cpha = enum(u1) {
                first = 0, // The first clock transition is the first data capture edge
                second = 1, // The second clock transition is the first data capture edge
            };
            pub const Cpol = enum(u1) {
                low = 0, // Steady low value on CK pin outside transmission window
                high = 1, // Steady high value on CK pin outside transmission window
            };
            pub const Clken = enum(u1) {
                disabled = 0, // CK pin disabled
                enabled = 1, // CK pin enabled
            };
            pub const Stop = enum(u2) {
                stop1 = 0b00, // 1 stop bit
                stop0p5 = 0b01, // 0.5 stop bits
                stop2 = 0b10, // 2 stop bits
                stop1p5 = 0b11, // 1.5 stop bits
            };
            pub const Linen = enum(u1) {
                disabled = 0, // LIN mode disabled
                enabled = 1, // LIN mode enabled
            };
            add: u4, // Address of the USART node
            _reserved_4_4: u1,
            lbdl: Lbdl, // lin break detection length (u1)
            lbdie: Lbdie, // LIN break detection interrupt enable (u1)
            _reserved_7_7: u1,
            lbcl: u1, // Last bit clock pulse
            cpha: Cpha, // Clock phase (u1)
            cpol: Cpol, // Clock polarity (u1)
            clken: Clken, // Clock enable (u1)
            stop: Stop, // STOP bits (u2)
            linen: Linen, // LIN mode enable (u1)
            _padding_15_31: u17,
        };
        pub const cr2 = mmio(base_address + 0x10, 32, Cr2);

        /// address: 0x40011414
        /// Control register 3
        pub const Cr3 = packed struct {
            pub const Eie = enum(u1) {
                disabled = 0, // Error interrupt disabled
                enabled = 1, // Error interrupt enabled
            };
            pub const Iren = enum(u1) {
                disabled = 0, // IrDA disabled
                enabled = 1, // IrDA enabled
            };
            pub const Irlp = enum(u1) {
                normal = 0, // Normal mode
                low_power = 1, // Low-power mode
            };
            pub const Hdsel = enum(u1) {
                full_duplex = 0, // Half duplex mode is not selected
                half_duplex = 1, // Half duplex mode is selected
            };
            pub const Nack = enum(u1) {
                disabled = 0, // NACK transmission in case of parity error is disabled
                enabled = 1, // NACK transmission during parity error is enabled
            };
            pub const Scen = enum(u1) {
                disabled = 0, // Smartcard mode disabled
                enabled = 1, // Smartcard mode enabled
            };
            pub const Dmar = enum(u1) {
                disabled = 0, // DMA mode is disabled for reception
                enabled = 1, // DMA mode is enabled for reception
            };
            pub const Dmat = enum(u1) {
                disabled = 0, // DMA mode is disabled for transmission
                enabled = 1, // DMA mode is enabled for transmission
            };
            pub const Rtse = enum(u1) {
                disabled = 0, // RTS hardware flow control disabled
                enabled = 1, // RTS hardware flow control enabled
            };
            pub const Ctse = enum(u1) {
                disabled = 0, // CTS hardware flow control disabled
                enabled = 1, // CTS hardware flow control enabled
            };
            pub const Ctsie = enum(u1) {
                disabled = 0, // CTS interrupt disabled
                enabled = 1, // CTS interrupt enabled
            };
            pub const Onebit = enum(u1) {
                sample3 = 0, // Three sample bit method
                sample1 = 1, // One sample bit method
            };
            eie: Eie, // Error interrupt enable (u1)
            iren: Iren, // IrDA mode enable (u1)
            irlp: Irlp, // IrDA low-power (u1)
            hdsel: Hdsel, // Half-duplex selection (u1)
            nack: Nack, // Smartcard NACK enable (u1)
            scen: Scen, // Smartcard mode enable (u1)
            dmar: Dmar, // DMA enable receiver (u1)
            dmat: Dmat, // DMA enable transmitter (u1)
            rtse: Rtse, // RTS enable (u1)
            ctse: Ctse, // CTS enable (u1)
            ctsie: Ctsie, // CTS interrupt enable (u1)
            onebit: Onebit, // One sample bit method enable (u1)
            _padding_12_31: u20,
        };
        pub const cr3 = mmio(base_address + 0x14, 32, Cr3);

        /// address: 0x40011418
        /// Guard time and prescaler register
        pub const Gtpr = packed struct {
            psc: u8, // Prescaler value
            gt: u8, // Guard time value
            _padding_16_31: u16,
        };
        pub const gtpr = mmio(base_address + 0x18, 32, Gtpr);
    };
    /// DMA controller
    pub const dma2 = struct {
        pub const base_address = 0x40026400;

        /// address: 0x40026400
        /// low interrupt status register
        pub const Lisr = packed struct {
            pub const Feif0 = enum(u1) {
                no_error = 0, // No FIFO error event on stream x
                @"error" = 1, // A FIFO error event occurred on stream x
            };
            pub const Dmeif0 = enum(u1) {
                no_error = 0, // No Direct Mode error on stream x
                @"error" = 1, // A Direct Mode error occurred on stream x
            };
            pub const Teif0 = enum(u1) {
                no_error = 0, // No transfer error on stream x
                @"error" = 1, // A transfer error occurred on stream x
            };
            pub const Htif0 = enum(u1) {
                not_half = 0, // No half transfer event on stream x
                half = 1, // A half transfer event occurred on stream x
            };
            pub const Tcif0 = enum(u1) {
                not_complete = 0, // No transfer complete event on stream x
                complete = 1, // A transfer complete event occurred on stream x
            };
            feif0: Feif0, // Stream x FIFO error interrupt flag (x=3..0) (u1)
            _reserved_1_1: u1,
            dmeif0: Dmeif0, // Stream x direct mode error interrupt flag (x=3..0) (u1)
            teif0: Teif0, // Stream x transfer error interrupt flag (x=3..0) (u1)
            htif0: Htif0, // Stream x half transfer interrupt flag (x=3..0) (u1)
            tcif0: Tcif0, // Stream x transfer complete interrupt flag (x = 3..0) (u1)
            feif1: Feif0, // Stream x FIFO error interrupt flag (x=3..0) (u1)
            _reserved_7_7: u1,
            dmeif1: Dmeif0, // Stream x direct mode error interrupt flag (x=3..0) (u1)
            teif1: Teif0, // Stream x transfer error interrupt flag (x=3..0) (u1)
            htif1: Htif0, // Stream x half transfer interrupt flag (x=3..0) (u1)
            tcif1: Tcif0, // Stream x transfer complete interrupt flag (x = 3..0) (u1)
            _reserved_12_15: u4,
            feif2: Feif0, // Stream x FIFO error interrupt flag (x=3..0) (u1)
            _reserved_17_17: u1,
            dmeif2: Dmeif0, // Stream x direct mode error interrupt flag (x=3..0) (u1)
            teif2: Teif0, // Stream x transfer error interrupt flag (x=3..0) (u1)
            htif2: Htif0, // Stream x half transfer interrupt flag (x=3..0) (u1)
            tcif2: Tcif0, // Stream x transfer complete interrupt flag (x = 3..0) (u1)
            feif3: Feif0, // Stream x FIFO error interrupt flag (x=3..0) (u1)
            _reserved_23_23: u1,
            dmeif3: Dmeif0, // Stream x direct mode error interrupt flag (x=3..0) (u1)
            teif3: Teif0, // Stream x transfer error interrupt flag (x=3..0) (u1)
            htif3: Htif0, // Stream x half transfer interrupt flag (x=3..0) (u1)
            tcif3: Tcif0, // Stream x transfer complete interrupt flag (x = 3..0) (u1)
            _padding_28_31: u4,
        };
        pub const lisr = mmio(base_address + 0x0, 32, Lisr);

        /// address: 0x40026404
        /// high interrupt status register
        pub const Hisr = packed struct {
            pub const Feif4 = enum(u1) {
                no_error = 0, // No FIFO error event on stream x
                @"error" = 1, // A FIFO error event occurred on stream x
            };
            pub const Dmeif4 = enum(u1) {
                no_error = 0, // No Direct Mode error on stream x
                @"error" = 1, // A Direct Mode error occurred on stream x
            };
            pub const Teif4 = enum(u1) {
                no_error = 0, // No transfer error on stream x
                @"error" = 1, // A transfer error occurred on stream x
            };
            pub const Htif4 = enum(u1) {
                not_half = 0, // No half transfer event on stream x
                half = 1, // A half transfer event occurred on stream x
            };
            pub const Tcif4 = enum(u1) {
                not_complete = 0, // No transfer complete event on stream x
                complete = 1, // A transfer complete event occurred on stream x
            };
            feif4: Feif4, // Stream x FIFO error interrupt flag (x=7..4) (u1)
            _reserved_1_1: u1,
            dmeif4: Dmeif4, // Stream x direct mode error interrupt flag (x=7..4) (u1)
            teif4: Teif4, // Stream x transfer error interrupt flag (x=7..4) (u1)
            htif4: Htif4, // Stream x half transfer interrupt flag (x=7..4) (u1)
            tcif4: Tcif4, // Stream x transfer complete interrupt flag (x=7..4) (u1)
            feif5: Feif4, // Stream x FIFO error interrupt flag (x=7..4) (u1)
            _reserved_7_7: u1,
            dmeif5: Dmeif4, // Stream x direct mode error interrupt flag (x=7..4) (u1)
            teif5: Teif4, // Stream x transfer error interrupt flag (x=7..4) (u1)
            htif5: Htif4, // Stream x half transfer interrupt flag (x=7..4) (u1)
            tcif5: Tcif4, // Stream x transfer complete interrupt flag (x=7..4) (u1)
            _reserved_12_15: u4,
            feif6: Feif4, // Stream x FIFO error interrupt flag (x=7..4) (u1)
            _reserved_17_17: u1,
            dmeif6: Dmeif4, // Stream x direct mode error interrupt flag (x=7..4) (u1)
            teif6: Teif4, // Stream x transfer error interrupt flag (x=7..4) (u1)
            htif6: Htif4, // Stream x half transfer interrupt flag (x=7..4) (u1)
            tcif6: Tcif4, // Stream x transfer complete interrupt flag (x=7..4) (u1)
            feif7: Feif4, // Stream x FIFO error interrupt flag (x=7..4) (u1)
            _reserved_23_23: u1,
            dmeif7: Dmeif4, // Stream x direct mode error interrupt flag (x=7..4) (u1)
            teif7: Teif4, // Stream x transfer error interrupt flag (x=7..4) (u1)
            htif7: Htif4, // Stream x half transfer interrupt flag (x=7..4) (u1)
            tcif7: Tcif4, // Stream x transfer complete interrupt flag (x=7..4) (u1)
            _padding_28_31: u4,
        };
        pub const hisr = mmio(base_address + 0x4, 32, Hisr);

        /// address: 0x40026408
        /// low interrupt flag clear register
        pub const Lifcr = packed struct {
            pub const Cfeif0 = enum(u1) {
                clear = 1, // Clear the corresponding CFEIFx flag
            };
            pub const Cdmeif0 = enum(u1) {
                clear = 1, // Clear the corresponding DMEIFx flag
            };
            pub const Cteif0 = enum(u1) {
                clear = 1, // Clear the corresponding TEIFx flag
            };
            pub const Chtif0 = enum(u1) {
                clear = 1, // Clear the corresponding HTIFx flag
            };
            pub const Ctcif0 = enum(u1) {
                clear = 1, // Clear the corresponding TCIFx flag
            };
            cfeif0: Cfeif0, // Stream x clear FIFO error interrupt flag (x = 3..0) (u1)
            _reserved_1_1: u1,
            cdmeif0: Cdmeif0, // Stream x clear direct mode error interrupt flag (x = 3..0) (u1)
            cteif0: Cteif0, // Stream x clear transfer error interrupt flag (x = 3..0) (u1)
            chtif0: Chtif0, // Stream x clear half transfer interrupt flag (x = 3..0) (u1)
            ctcif0: Ctcif0, // Stream x clear transfer complete interrupt flag (x = 3..0) (u1)
            cfeif1: Cfeif0, // Stream x clear FIFO error interrupt flag (x = 3..0) (u1)
            _reserved_7_7: u1,
            cdmeif1: Cdmeif0, // Stream x clear direct mode error interrupt flag (x = 3..0) (u1)
            cteif1: Cteif0, // Stream x clear transfer error interrupt flag (x = 3..0) (u1)
            chtif1: Chtif0, // Stream x clear half transfer interrupt flag (x = 3..0) (u1)
            ctcif1: Ctcif0, // Stream x clear transfer complete interrupt flag (x = 3..0) (u1)
            _reserved_12_15: u4,
            cfeif2: Cfeif0, // Stream x clear FIFO error interrupt flag (x = 3..0) (u1)
            _reserved_17_17: u1,
            cdmeif2: Cdmeif0, // Stream x clear direct mode error interrupt flag (x = 3..0) (u1)
            cteif2: Cteif0, // Stream x clear transfer error interrupt flag (x = 3..0) (u1)
            chtif2: Chtif0, // Stream x clear half transfer interrupt flag (x = 3..0) (u1)
            ctcif2: Ctcif0, // Stream x clear transfer complete interrupt flag (x = 3..0) (u1)
            cfeif3: Cfeif0, // Stream x clear FIFO error interrupt flag (x = 3..0) (u1)
            _reserved_23_23: u1,
            cdmeif3: Cdmeif0, // Stream x clear direct mode error interrupt flag (x = 3..0) (u1)
            cteif3: Cteif0, // Stream x clear transfer error interrupt flag (x = 3..0) (u1)
            chtif3: Chtif0, // Stream x clear half transfer interrupt flag (x = 3..0) (u1)
            ctcif3: Ctcif0, // Stream x clear transfer complete interrupt flag (x = 3..0) (u1)
            _padding_28_31: u4,
        };
        pub const lifcr = mmio(base_address + 0x8, 32, Lifcr);

        /// address: 0x4002640c
        /// high interrupt flag clear register
        pub const Hifcr = packed struct {
            pub const Cfeif4 = enum(u1) {
                clear = 1, // Clear the corresponding CFEIFx flag
            };
            pub const Cdmeif4 = enum(u1) {
                clear = 1, // Clear the corresponding DMEIFx flag
            };
            pub const Cteif4 = enum(u1) {
                clear = 1, // Clear the corresponding TEIFx flag
            };
            pub const Chtif4 = enum(u1) {
                clear = 1, // Clear the corresponding HTIFx flag
            };
            pub const Ctcif4 = enum(u1) {
                clear = 1, // Clear the corresponding TCIFx flag
            };
            cfeif4: Cfeif4, // Stream x clear FIFO error interrupt flag (x = 7..4) (u1)
            _reserved_1_1: u1,
            cdmeif4: Cdmeif4, // Stream x clear direct mode error interrupt flag (x = 7..4) (u1)
            cteif4: Cteif4, // Stream x clear transfer error interrupt flag (x = 7..4) (u1)
            chtif4: Chtif4, // Stream x clear half transfer interrupt flag (x = 7..4) (u1)
            ctcif4: Ctcif4, // Stream x clear transfer complete interrupt flag (x = 7..4) (u1)
            cfeif5: Cfeif4, // Stream x clear FIFO error interrupt flag (x = 7..4) (u1)
            _reserved_7_7: u1,
            cdmeif5: Cdmeif4, // Stream x clear direct mode error interrupt flag (x = 7..4) (u1)
            cteif5: Cteif4, // Stream x clear transfer error interrupt flag (x = 7..4) (u1)
            chtif5: Chtif4, // Stream x clear half transfer interrupt flag (x = 7..4) (u1)
            ctcif5: Ctcif4, // Stream x clear transfer complete interrupt flag (x = 7..4) (u1)
            _reserved_12_15: u4,
            cfeif6: Cfeif4, // Stream x clear FIFO error interrupt flag (x = 7..4) (u1)
            _reserved_17_17: u1,
            cdmeif6: Cdmeif4, // Stream x clear direct mode error interrupt flag (x = 7..4) (u1)
            cteif6: Cteif4, // Stream x clear transfer error interrupt flag (x = 7..4) (u1)
            chtif6: Chtif4, // Stream x clear half transfer interrupt flag (x = 7..4) (u1)
            ctcif6: Ctcif4, // Stream x clear transfer complete interrupt flag (x = 7..4) (u1)
            cfeif7: Cfeif4, // Stream x clear FIFO error interrupt flag (x = 7..4) (u1)
            _reserved_23_23: u1,
            cdmeif7: Cdmeif4, // Stream x clear direct mode error interrupt flag (x = 7..4) (u1)
            cteif7: Cteif4, // Stream x clear transfer error interrupt flag (x = 7..4) (u1)
            chtif7: Chtif4, // Stream x clear half transfer interrupt flag (x = 7..4) (u1)
            ctcif7: Ctcif4, // Stream x clear transfer complete interrupt flag (x = 7..4) (u1)
            _padding_28_31: u4,
        };
        pub const hifcr = mmio(base_address + 0xc, 32, Hifcr);

        /// address: 0x40026410
        /// stream x configuration register
        pub const St0cr = packed struct {
            pub const En = enum(u1) {
                disabled = 0, // Stream disabled
                enabled = 1, // Stream enabled
            };
            pub const Dmeie = enum(u1) {
                disabled = 0, // DME interrupt disabled
                enabled = 1, // DME interrupt enabled
            };
            pub const Teie = enum(u1) {
                disabled = 0, // TE interrupt disabled
                enabled = 1, // TE interrupt enabled
            };
            pub const Htie = enum(u1) {
                disabled = 0, // HT interrupt disabled
                enabled = 1, // HT interrupt enabled
            };
            pub const Tcie = enum(u1) {
                disabled = 0, // TC interrupt disabled
                enabled = 1, // TC interrupt enabled
            };
            pub const Pfctrl = enum(u1) {
                dma = 0, // The DMA is the flow controller
                peripheral = 1, // The peripheral is the flow controller
            };
            pub const Dir = enum(u2) {
                peripheral_to_memory = 0b00, // Peripheral-to-memory
                memory_to_peripheral = 0b01, // Memory-to-peripheral
                memory_to_memory = 0b10, // Memory-to-memory
            };
            pub const Circ = enum(u1) {
                disabled = 0, // Circular mode disabled
                enabled = 1, // Circular mode enabled
            };
            pub const Pinc = enum(u1) {
                fixed = 0, // Address pointer is fixed
                incremented = 1, // Address pointer is incremented after each data transfer
            };
            pub const Psize = enum(u2) {
                bits8 = 0b00, // Byte (8-bit)
                bits16 = 0b01, // Half-word (16-bit)
                bits32 = 0b10, // Word (32-bit)
            };
            pub const Pincos = enum(u1) {
                psize = 0, // The offset size for the peripheral address calculation is linked to the PSIZE
                fixed4 = 1, // The offset size for the peripheral address calculation is fixed to 4 (32-bit alignment)
            };
            pub const Pl = enum(u2) {
                low = 0b00, // Low
                medium = 0b01, // Medium
                high = 0b10, // High
                very_high = 0b11, // Very high
            };
            pub const Dbm = enum(u1) {
                disabled = 0, // No buffer switching at the end of transfer
                enabled = 1, // Memory target switched at the end of the DMA transfer
            };
            pub const Ct = enum(u1) {
                memory0 = 0, // The current target memory is Memory 0
                memory1 = 1, // The current target memory is Memory 1
            };
            pub const Pburst = enum(u2) {
                single = 0b00, // Single transfer
                incr4 = 0b01, // Incremental burst of 4 beats
                incr8 = 0b10, // Incremental burst of 8 beats
                incr16 = 0b11, // Incremental burst of 16 beats
            };
            en: En, // Stream enable / flag stream ready when read low (u1)
            dmeie: Dmeie, // Direct mode error interrupt enable (u1)
            teie: Teie, // Transfer error interrupt enable (u1)
            htie: Htie, // Half transfer interrupt enable (u1)
            tcie: Tcie, // Transfer complete interrupt enable (u1)
            pfctrl: Pfctrl, // Peripheral flow controller (u1)
            dir: Dir, // Data transfer direction (u2)
            circ: Circ, // Circular mode (u1)
            pinc: Pinc, // Peripheral increment mode (u1)
            minc: Pinc, // Memory increment mode (u1)
            psize: Psize, // Peripheral data size (u2)
            msize: Psize, // Memory data size (u2)
            pincos: Pincos, // Peripheral increment offset size (u1)
            pl: Pl, // Priority level (u2)
            dbm: Dbm, // Double buffer mode (u1)
            ct: Ct, // Current target (only in double buffer mode) (u1)
            _reserved_20_20: u1,
            pburst: Pburst, // Peripheral burst transfer configuration (u2)
            mburst: Pburst, // Memory burst transfer configuration (u2)
            chsel: u3, // Channel selection
            _padding_28_31: u4,
        };
        pub const st0cr = mmio(base_address + 0x10, 32, St0cr);

        /// address: 0x40026414
        /// stream x number of data register
        pub const St0ndtr = packed struct {
            ndt: u16, // Number of data items to transfer
            _padding_16_31: u16,
        };
        pub const st0ndtr = mmio(base_address + 0x14, 32, St0ndtr);

        /// address: 0x40026418
        /// stream x peripheral address register
        pub const St0par = packed struct {
            pa: u32, // Peripheral address
        };
        pub const st0par = mmio(base_address + 0x18, 32, St0par);

        /// address: 0x4002641c
        /// stream x memory 0 address register
        pub const St0m0ar = packed struct {
            m0a: u32, // Memory 0 address
        };
        pub const st0m0ar = mmio(base_address + 0x1c, 32, St0m0ar);

        /// address: 0x40026420
        /// stream x memory 1 address register
        pub const St0m1ar = packed struct {
            m1a: u32, // Memory 1 address (used in case of Double buffer mode)
        };
        pub const st0m1ar = mmio(base_address + 0x20, 32, St0m1ar);

        /// address: 0x40026424
        /// stream x FIFO control register
        pub const St0fcr = packed struct {
            pub const Fth = enum(u2) {
                quarter = 0b00, // 1/4 full FIFO
                half = 0b01, // 1/2 full FIFO
                three_quarters = 0b10, // 3/4 full FIFO
                full = 0b11, // Full FIFO
            };
            pub const Dmdis = enum(u1) {
                enabled = 0, // Direct mode is enabled
                disabled = 1, // Direct mode is disabled
            };
            pub const Fs = enum(u3) {
                quarter1 = 0b000, // 0 < fifo_level < 1/4
                quarter2 = 0b001, // 1/4 <= fifo_level < 1/2
                quarter3 = 0b010, // 1/2 <= fifo_level < 3/4
                quarter4 = 0b011, // 3/4 <= fifo_level < full
                empty = 0b100, // FIFO is empty
                full = 0b101, // FIFO is full
            };
            pub const Feie = enum(u1) {
                disabled = 0, // FE interrupt disabled
                enabled = 1, // FE interrupt enabled
            };
            fth: Fth, // FIFO threshold selection (u2)
            dmdis: Dmdis, // Direct mode disable (u1)
            fs: Fs, // FIFO status (u3)
            _reserved_6_6: u1,
            feie: Feie, // FIFO error interrupt enable (u1)
            _padding_8_31: u24,
        };
        pub const st0fcr = mmio(base_address + 0x24, 32, St0fcr);

        /// address: 0x40026428
        /// stream x configuration register
        pub const St1cr = packed struct {
            pub const En = enum(u1) {
                disabled = 0, // Stream disabled
                enabled = 1, // Stream enabled
            };
            pub const Dmeie = enum(u1) {
                disabled = 0, // DME interrupt disabled
                enabled = 1, // DME interrupt enabled
            };
            pub const Teie = enum(u1) {
                disabled = 0, // TE interrupt disabled
                enabled = 1, // TE interrupt enabled
            };
            pub const Htie = enum(u1) {
                disabled = 0, // HT interrupt disabled
                enabled = 1, // HT interrupt enabled
            };
            pub const Tcie = enum(u1) {
                disabled = 0, // TC interrupt disabled
                enabled = 1, // TC interrupt enabled
            };
            pub const Pfctrl = enum(u1) {
                dma = 0, // The DMA is the flow controller
                peripheral = 1, // The peripheral is the flow controller
            };
            pub const Dir = enum(u2) {
                peripheral_to_memory = 0b00, // Peripheral-to-memory
                memory_to_peripheral = 0b01, // Memory-to-peripheral
                memory_to_memory = 0b10, // Memory-to-memory
            };
            pub const Circ = enum(u1) {
                disabled = 0, // Circular mode disabled
                enabled = 1, // Circular mode enabled
            };
            pub const Pinc = enum(u1) {
                fixed = 0, // Address pointer is fixed
                incremented = 1, // Address pointer is incremented after each data transfer
            };
            pub const Psize = enum(u2) {
                bits8 = 0b00, // Byte (8-bit)
                bits16 = 0b01, // Half-word (16-bit)
                bits32 = 0b10, // Word (32-bit)
            };
            pub const Pincos = enum(u1) {
                psize = 0, // The offset size for the peripheral address calculation is linked to the PSIZE
                fixed4 = 1, // The offset size for the peripheral address calculation is fixed to 4 (32-bit alignment)
            };
            pub const Pl = enum(u2) {
                low = 0b00, // Low
                medium = 0b01, // Medium
                high = 0b10, // High
                very_high = 0b11, // Very high
            };
            pub const Dbm = enum(u1) {
                disabled = 0, // No buffer switching at the end of transfer
                enabled = 1, // Memory target switched at the end of the DMA transfer
            };
            pub const Ct = enum(u1) {
                memory0 = 0, // The current target memory is Memory 0
                memory1 = 1, // The current target memory is Memory 1
            };
            pub const Pburst = enum(u2) {
                single = 0b00, // Single transfer
                incr4 = 0b01, // Incremental burst of 4 beats
                incr8 = 0b10, // Incremental burst of 8 beats
                incr16 = 0b11, // Incremental burst of 16 beats
            };
            en: En, // Stream enable / flag stream ready when read low (u1)
            dmeie: Dmeie, // Direct mode error interrupt enable (u1)
            teie: Teie, // Transfer error interrupt enable (u1)
            htie: Htie, // Half transfer interrupt enable (u1)
            tcie: Tcie, // Transfer complete interrupt enable (u1)
            pfctrl: Pfctrl, // Peripheral flow controller (u1)
            dir: Dir, // Data transfer direction (u2)
            circ: Circ, // Circular mode (u1)
            pinc: Pinc, // Peripheral increment mode (u1)
            minc: Pinc, // Memory increment mode (u1)
            psize: Psize, // Peripheral data size (u2)
            msize: Psize, // Memory data size (u2)
            pincos: Pincos, // Peripheral increment offset size (u1)
            pl: Pl, // Priority level (u2)
            dbm: Dbm, // Double buffer mode (u1)
            ct: Ct, // Current target (only in double buffer mode) (u1)
            _reserved_20_20: u1,
            pburst: Pburst, // Peripheral burst transfer configuration (u2)
            mburst: Pburst, // Memory burst transfer configuration (u2)
            chsel: u3, // Channel selection
            _padding_28_31: u4,
        };
        pub const st1cr = mmio(base_address + 0x28, 32, St1cr);

        /// address: 0x4002642c
        /// stream x number of data register
        pub const St1ndtr = packed struct {
            ndt: u16, // Number of data items to transfer
            _padding_16_31: u16,
        };
        pub const st1ndtr = mmio(base_address + 0x2c, 32, St1ndtr);

        /// address: 0x40026430
        /// stream x peripheral address register
        pub const St1par = packed struct {
            pa: u32, // Peripheral address
        };
        pub const st1par = mmio(base_address + 0x30, 32, St1par);

        /// address: 0x40026434
        /// stream x memory 0 address register
        pub const St1m0ar = packed struct {
            m0a: u32, // Memory 0 address
        };
        pub const st1m0ar = mmio(base_address + 0x34, 32, St1m0ar);

        /// address: 0x40026438
        /// stream x memory 1 address register
        pub const St1m1ar = packed struct {
            m1a: u32, // Memory 1 address (used in case of Double buffer mode)
        };
        pub const st1m1ar = mmio(base_address + 0x38, 32, St1m1ar);

        /// address: 0x4002643c
        /// stream x FIFO control register
        pub const St1fcr = packed struct {
            pub const Fth = enum(u2) {
                quarter = 0b00, // 1/4 full FIFO
                half = 0b01, // 1/2 full FIFO
                three_quarters = 0b10, // 3/4 full FIFO
                full = 0b11, // Full FIFO
            };
            pub const Dmdis = enum(u1) {
                enabled = 0, // Direct mode is enabled
                disabled = 1, // Direct mode is disabled
            };
            pub const Fs = enum(u3) {
                quarter1 = 0b000, // 0 < fifo_level < 1/4
                quarter2 = 0b001, // 1/4 <= fifo_level < 1/2
                quarter3 = 0b010, // 1/2 <= fifo_level < 3/4
                quarter4 = 0b011, // 3/4 <= fifo_level < full
                empty = 0b100, // FIFO is empty
                full = 0b101, // FIFO is full
            };
            pub const Feie = enum(u1) {
                disabled = 0, // FE interrupt disabled
                enabled = 1, // FE interrupt enabled
            };
            fth: Fth, // FIFO threshold selection (u2)
            dmdis: Dmdis, // Direct mode disable (u1)
            fs: Fs, // FIFO status (u3)
            _reserved_6_6: u1,
            feie: Feie, // FIFO error interrupt enable (u1)
            _padding_8_31: u24,
        };
        pub const st1fcr = mmio(base_address + 0x3c, 32, St1fcr);

        /// address: 0x40026440
        /// stream x configuration register
        pub const St2cr = packed struct {
            pub const En = enum(u1) {
                disabled = 0, // Stream disabled
                enabled = 1, // Stream enabled
            };
            pub const Dmeie = enum(u1) {
                disabled = 0, // DME interrupt disabled
                enabled = 1, // DME interrupt enabled
            };
            pub const Teie = enum(u1) {
                disabled = 0, // TE interrupt disabled
                enabled = 1, // TE interrupt enabled
            };
            pub const Htie = enum(u1) {
                disabled = 0, // HT interrupt disabled
                enabled = 1, // HT interrupt enabled
            };
            pub const Tcie = enum(u1) {
                disabled = 0, // TC interrupt disabled
                enabled = 1, // TC interrupt enabled
            };
            pub const Pfctrl = enum(u1) {
                dma = 0, // The DMA is the flow controller
                peripheral = 1, // The peripheral is the flow controller
            };
            pub const Dir = enum(u2) {
                peripheral_to_memory = 0b00, // Peripheral-to-memory
                memory_to_peripheral = 0b01, // Memory-to-peripheral
                memory_to_memory = 0b10, // Memory-to-memory
            };
            pub const Circ = enum(u1) {
                disabled = 0, // Circular mode disabled
                enabled = 1, // Circular mode enabled
            };
            pub const Pinc = enum(u1) {
                fixed = 0, // Address pointer is fixed
                incremented = 1, // Address pointer is incremented after each data transfer
            };
            pub const Psize = enum(u2) {
                bits8 = 0b00, // Byte (8-bit)
                bits16 = 0b01, // Half-word (16-bit)
                bits32 = 0b10, // Word (32-bit)
            };
            pub const Pincos = enum(u1) {
                psize = 0, // The offset size for the peripheral address calculation is linked to the PSIZE
                fixed4 = 1, // The offset size for the peripheral address calculation is fixed to 4 (32-bit alignment)
            };
            pub const Pl = enum(u2) {
                low = 0b00, // Low
                medium = 0b01, // Medium
                high = 0b10, // High
                very_high = 0b11, // Very high
            };
            pub const Dbm = enum(u1) {
                disabled = 0, // No buffer switching at the end of transfer
                enabled = 1, // Memory target switched at the end of the DMA transfer
            };
            pub const Ct = enum(u1) {
                memory0 = 0, // The current target memory is Memory 0
                memory1 = 1, // The current target memory is Memory 1
            };
            pub const Pburst = enum(u2) {
                single = 0b00, // Single transfer
                incr4 = 0b01, // Incremental burst of 4 beats
                incr8 = 0b10, // Incremental burst of 8 beats
                incr16 = 0b11, // Incremental burst of 16 beats
            };
            en: En, // Stream enable / flag stream ready when read low (u1)
            dmeie: Dmeie, // Direct mode error interrupt enable (u1)
            teie: Teie, // Transfer error interrupt enable (u1)
            htie: Htie, // Half transfer interrupt enable (u1)
            tcie: Tcie, // Transfer complete interrupt enable (u1)
            pfctrl: Pfctrl, // Peripheral flow controller (u1)
            dir: Dir, // Data transfer direction (u2)
            circ: Circ, // Circular mode (u1)
            pinc: Pinc, // Peripheral increment mode (u1)
            minc: Pinc, // Memory increment mode (u1)
            psize: Psize, // Peripheral data size (u2)
            msize: Psize, // Memory data size (u2)
            pincos: Pincos, // Peripheral increment offset size (u1)
            pl: Pl, // Priority level (u2)
            dbm: Dbm, // Double buffer mode (u1)
            ct: Ct, // Current target (only in double buffer mode) (u1)
            _reserved_20_20: u1,
            pburst: Pburst, // Peripheral burst transfer configuration (u2)
            mburst: Pburst, // Memory burst transfer configuration (u2)
            chsel: u3, // Channel selection
            _padding_28_31: u4,
        };
        pub const st2cr = mmio(base_address + 0x40, 32, St2cr);

        /// address: 0x40026444
        /// stream x number of data register
        pub const St2ndtr = packed struct {
            ndt: u16, // Number of data items to transfer
            _padding_16_31: u16,
        };
        pub const st2ndtr = mmio(base_address + 0x44, 32, St2ndtr);

        /// address: 0x40026448
        /// stream x peripheral address register
        pub const St2par = packed struct {
            pa: u32, // Peripheral address
        };
        pub const st2par = mmio(base_address + 0x48, 32, St2par);

        /// address: 0x4002644c
        /// stream x memory 0 address register
        pub const St2m0ar = packed struct {
            m0a: u32, // Memory 0 address
        };
        pub const st2m0ar = mmio(base_address + 0x4c, 32, St2m0ar);

        /// address: 0x40026450
        /// stream x memory 1 address register
        pub const St2m1ar = packed struct {
            m1a: u32, // Memory 1 address (used in case of Double buffer mode)
        };
        pub const st2m1ar = mmio(base_address + 0x50, 32, St2m1ar);

        /// address: 0x40026454
        /// stream x FIFO control register
        pub const St2fcr = packed struct {
            pub const Fth = enum(u2) {
                quarter = 0b00, // 1/4 full FIFO
                half = 0b01, // 1/2 full FIFO
                three_quarters = 0b10, // 3/4 full FIFO
                full = 0b11, // Full FIFO
            };
            pub const Dmdis = enum(u1) {
                enabled = 0, // Direct mode is enabled
                disabled = 1, // Direct mode is disabled
            };
            pub const Fs = enum(u3) {
                quarter1 = 0b000, // 0 < fifo_level < 1/4
                quarter2 = 0b001, // 1/4 <= fifo_level < 1/2
                quarter3 = 0b010, // 1/2 <= fifo_level < 3/4
                quarter4 = 0b011, // 3/4 <= fifo_level < full
                empty = 0b100, // FIFO is empty
                full = 0b101, // FIFO is full
            };
            pub const Feie = enum(u1) {
                disabled = 0, // FE interrupt disabled
                enabled = 1, // FE interrupt enabled
            };
            fth: Fth, // FIFO threshold selection (u2)
            dmdis: Dmdis, // Direct mode disable (u1)
            fs: Fs, // FIFO status (u3)
            _reserved_6_6: u1,
            feie: Feie, // FIFO error interrupt enable (u1)
            _padding_8_31: u24,
        };
        pub const st2fcr = mmio(base_address + 0x54, 32, St2fcr);

        /// address: 0x40026458
        /// stream x configuration register
        pub const St3cr = packed struct {
            pub const En = enum(u1) {
                disabled = 0, // Stream disabled
                enabled = 1, // Stream enabled
            };
            pub const Dmeie = enum(u1) {
                disabled = 0, // DME interrupt disabled
                enabled = 1, // DME interrupt enabled
            };
            pub const Teie = enum(u1) {
                disabled = 0, // TE interrupt disabled
                enabled = 1, // TE interrupt enabled
            };
            pub const Htie = enum(u1) {
                disabled = 0, // HT interrupt disabled
                enabled = 1, // HT interrupt enabled
            };
            pub const Tcie = enum(u1) {
                disabled = 0, // TC interrupt disabled
                enabled = 1, // TC interrupt enabled
            };
            pub const Pfctrl = enum(u1) {
                dma = 0, // The DMA is the flow controller
                peripheral = 1, // The peripheral is the flow controller
            };
            pub const Dir = enum(u2) {
                peripheral_to_memory = 0b00, // Peripheral-to-memory
                memory_to_peripheral = 0b01, // Memory-to-peripheral
                memory_to_memory = 0b10, // Memory-to-memory
            };
            pub const Circ = enum(u1) {
                disabled = 0, // Circular mode disabled
                enabled = 1, // Circular mode enabled
            };
            pub const Pinc = enum(u1) {
                fixed = 0, // Address pointer is fixed
                incremented = 1, // Address pointer is incremented after each data transfer
            };
            pub const Psize = enum(u2) {
                bits8 = 0b00, // Byte (8-bit)
                bits16 = 0b01, // Half-word (16-bit)
                bits32 = 0b10, // Word (32-bit)
            };
            pub const Pincos = enum(u1) {
                psize = 0, // The offset size for the peripheral address calculation is linked to the PSIZE
                fixed4 = 1, // The offset size for the peripheral address calculation is fixed to 4 (32-bit alignment)
            };
            pub const Pl = enum(u2) {
                low = 0b00, // Low
                medium = 0b01, // Medium
                high = 0b10, // High
                very_high = 0b11, // Very high
            };
            pub const Dbm = enum(u1) {
                disabled = 0, // No buffer switching at the end of transfer
                enabled = 1, // Memory target switched at the end of the DMA transfer
            };
            pub const Ct = enum(u1) {
                memory0 = 0, // The current target memory is Memory 0
                memory1 = 1, // The current target memory is Memory 1
            };
            pub const Pburst = enum(u2) {
                single = 0b00, // Single transfer
                incr4 = 0b01, // Incremental burst of 4 beats
                incr8 = 0b10, // Incremental burst of 8 beats
                incr16 = 0b11, // Incremental burst of 16 beats
            };
            en: En, // Stream enable / flag stream ready when read low (u1)
            dmeie: Dmeie, // Direct mode error interrupt enable (u1)
            teie: Teie, // Transfer error interrupt enable (u1)
            htie: Htie, // Half transfer interrupt enable (u1)
            tcie: Tcie, // Transfer complete interrupt enable (u1)
            pfctrl: Pfctrl, // Peripheral flow controller (u1)
            dir: Dir, // Data transfer direction (u2)
            circ: Circ, // Circular mode (u1)
            pinc: Pinc, // Peripheral increment mode (u1)
            minc: Pinc, // Memory increment mode (u1)
            psize: Psize, // Peripheral data size (u2)
            msize: Psize, // Memory data size (u2)
            pincos: Pincos, // Peripheral increment offset size (u1)
            pl: Pl, // Priority level (u2)
            dbm: Dbm, // Double buffer mode (u1)
            ct: Ct, // Current target (only in double buffer mode) (u1)
            _reserved_20_20: u1,
            pburst: Pburst, // Peripheral burst transfer configuration (u2)
            mburst: Pburst, // Memory burst transfer configuration (u2)
            chsel: u3, // Channel selection
            _padding_28_31: u4,
        };
        pub const st3cr = mmio(base_address + 0x58, 32, St3cr);

        /// address: 0x4002645c
        /// stream x number of data register
        pub const St3ndtr = packed struct {
            ndt: u16, // Number of data items to transfer
            _padding_16_31: u16,
        };
        pub const st3ndtr = mmio(base_address + 0x5c, 32, St3ndtr);

        /// address: 0x40026460
        /// stream x peripheral address register
        pub const St3par = packed struct {
            pa: u32, // Peripheral address
        };
        pub const st3par = mmio(base_address + 0x60, 32, St3par);

        /// address: 0x40026464
        /// stream x memory 0 address register
        pub const St3m0ar = packed struct {
            m0a: u32, // Memory 0 address
        };
        pub const st3m0ar = mmio(base_address + 0x64, 32, St3m0ar);

        /// address: 0x40026468
        /// stream x memory 1 address register
        pub const St3m1ar = packed struct {
            m1a: u32, // Memory 1 address (used in case of Double buffer mode)
        };
        pub const st3m1ar = mmio(base_address + 0x68, 32, St3m1ar);

        /// address: 0x4002646c
        /// stream x FIFO control register
        pub const St3fcr = packed struct {
            pub const Fth = enum(u2) {
                quarter = 0b00, // 1/4 full FIFO
                half = 0b01, // 1/2 full FIFO
                three_quarters = 0b10, // 3/4 full FIFO
                full = 0b11, // Full FIFO
            };
            pub const Dmdis = enum(u1) {
                enabled = 0, // Direct mode is enabled
                disabled = 1, // Direct mode is disabled
            };
            pub const Fs = enum(u3) {
                quarter1 = 0b000, // 0 < fifo_level < 1/4
                quarter2 = 0b001, // 1/4 <= fifo_level < 1/2
                quarter3 = 0b010, // 1/2 <= fifo_level < 3/4
                quarter4 = 0b011, // 3/4 <= fifo_level < full
                empty = 0b100, // FIFO is empty
                full = 0b101, // FIFO is full
            };
            pub const Feie = enum(u1) {
                disabled = 0, // FE interrupt disabled
                enabled = 1, // FE interrupt enabled
            };
            fth: Fth, // FIFO threshold selection (u2)
            dmdis: Dmdis, // Direct mode disable (u1)
            fs: Fs, // FIFO status (u3)
            _reserved_6_6: u1,
            feie: Feie, // FIFO error interrupt enable (u1)
            _padding_8_31: u24,
        };
        pub const st3fcr = mmio(base_address + 0x6c, 32, St3fcr);

        /// address: 0x40026470
        /// stream x configuration register
        pub const St4cr = packed struct {
            pub const En = enum(u1) {
                disabled = 0, // Stream disabled
                enabled = 1, // Stream enabled
            };
            pub const Dmeie = enum(u1) {
                disabled = 0, // DME interrupt disabled
                enabled = 1, // DME interrupt enabled
            };
            pub const Teie = enum(u1) {
                disabled = 0, // TE interrupt disabled
                enabled = 1, // TE interrupt enabled
            };
            pub const Htie = enum(u1) {
                disabled = 0, // HT interrupt disabled
                enabled = 1, // HT interrupt enabled
            };
            pub const Tcie = enum(u1) {
                disabled = 0, // TC interrupt disabled
                enabled = 1, // TC interrupt enabled
            };
            pub const Pfctrl = enum(u1) {
                dma = 0, // The DMA is the flow controller
                peripheral = 1, // The peripheral is the flow controller
            };
            pub const Dir = enum(u2) {
                peripheral_to_memory = 0b00, // Peripheral-to-memory
                memory_to_peripheral = 0b01, // Memory-to-peripheral
                memory_to_memory = 0b10, // Memory-to-memory
            };
            pub const Circ = enum(u1) {
                disabled = 0, // Circular mode disabled
                enabled = 1, // Circular mode enabled
            };
            pub const Pinc = enum(u1) {
                fixed = 0, // Address pointer is fixed
                incremented = 1, // Address pointer is incremented after each data transfer
            };
            pub const Psize = enum(u2) {
                bits8 = 0b00, // Byte (8-bit)
                bits16 = 0b01, // Half-word (16-bit)
                bits32 = 0b10, // Word (32-bit)
            };
            pub const Pincos = enum(u1) {
                psize = 0, // The offset size for the peripheral address calculation is linked to the PSIZE
                fixed4 = 1, // The offset size for the peripheral address calculation is fixed to 4 (32-bit alignment)
            };
            pub const Pl = enum(u2) {
                low = 0b00, // Low
                medium = 0b01, // Medium
                high = 0b10, // High
                very_high = 0b11, // Very high
            };
            pub const Dbm = enum(u1) {
                disabled = 0, // No buffer switching at the end of transfer
                enabled = 1, // Memory target switched at the end of the DMA transfer
            };
            pub const Ct = enum(u1) {
                memory0 = 0, // The current target memory is Memory 0
                memory1 = 1, // The current target memory is Memory 1
            };
            pub const Pburst = enum(u2) {
                single = 0b00, // Single transfer
                incr4 = 0b01, // Incremental burst of 4 beats
                incr8 = 0b10, // Incremental burst of 8 beats
                incr16 = 0b11, // Incremental burst of 16 beats
            };
            en: En, // Stream enable / flag stream ready when read low (u1)
            dmeie: Dmeie, // Direct mode error interrupt enable (u1)
            teie: Teie, // Transfer error interrupt enable (u1)
            htie: Htie, // Half transfer interrupt enable (u1)
            tcie: Tcie, // Transfer complete interrupt enable (u1)
            pfctrl: Pfctrl, // Peripheral flow controller (u1)
            dir: Dir, // Data transfer direction (u2)
            circ: Circ, // Circular mode (u1)
            pinc: Pinc, // Peripheral increment mode (u1)
            minc: Pinc, // Memory increment mode (u1)
            psize: Psize, // Peripheral data size (u2)
            msize: Psize, // Memory data size (u2)
            pincos: Pincos, // Peripheral increment offset size (u1)
            pl: Pl, // Priority level (u2)
            dbm: Dbm, // Double buffer mode (u1)
            ct: Ct, // Current target (only in double buffer mode) (u1)
            _reserved_20_20: u1,
            pburst: Pburst, // Peripheral burst transfer configuration (u2)
            mburst: Pburst, // Memory burst transfer configuration (u2)
            chsel: u3, // Channel selection
            _padding_28_31: u4,
        };
        pub const st4cr = mmio(base_address + 0x70, 32, St4cr);

        /// address: 0x40026474
        /// stream x number of data register
        pub const St4ndtr = packed struct {
            ndt: u16, // Number of data items to transfer
            _padding_16_31: u16,
        };
        pub const st4ndtr = mmio(base_address + 0x74, 32, St4ndtr);

        /// address: 0x40026478
        /// stream x peripheral address register
        pub const St4par = packed struct {
            pa: u32, // Peripheral address
        };
        pub const st4par = mmio(base_address + 0x78, 32, St4par);

        /// address: 0x4002647c
        /// stream x memory 0 address register
        pub const St4m0ar = packed struct {
            m0a: u32, // Memory 0 address
        };
        pub const st4m0ar = mmio(base_address + 0x7c, 32, St4m0ar);

        /// address: 0x40026480
        /// stream x memory 1 address register
        pub const St4m1ar = packed struct {
            m1a: u32, // Memory 1 address (used in case of Double buffer mode)
        };
        pub const st4m1ar = mmio(base_address + 0x80, 32, St4m1ar);

        /// address: 0x40026484
        /// stream x FIFO control register
        pub const St4fcr = packed struct {
            pub const Fth = enum(u2) {
                quarter = 0b00, // 1/4 full FIFO
                half = 0b01, // 1/2 full FIFO
                three_quarters = 0b10, // 3/4 full FIFO
                full = 0b11, // Full FIFO
            };
            pub const Dmdis = enum(u1) {
                enabled = 0, // Direct mode is enabled
                disabled = 1, // Direct mode is disabled
            };
            pub const Fs = enum(u3) {
                quarter1 = 0b000, // 0 < fifo_level < 1/4
                quarter2 = 0b001, // 1/4 <= fifo_level < 1/2
                quarter3 = 0b010, // 1/2 <= fifo_level < 3/4
                quarter4 = 0b011, // 3/4 <= fifo_level < full
                empty = 0b100, // FIFO is empty
                full = 0b101, // FIFO is full
            };
            pub const Feie = enum(u1) {
                disabled = 0, // FE interrupt disabled
                enabled = 1, // FE interrupt enabled
            };
            fth: Fth, // FIFO threshold selection (u2)
            dmdis: Dmdis, // Direct mode disable (u1)
            fs: Fs, // FIFO status (u3)
            _reserved_6_6: u1,
            feie: Feie, // FIFO error interrupt enable (u1)
            _padding_8_31: u24,
        };
        pub const st4fcr = mmio(base_address + 0x84, 32, St4fcr);

        /// address: 0x40026488
        /// stream x configuration register
        pub const St5cr = packed struct {
            pub const En = enum(u1) {
                disabled = 0, // Stream disabled
                enabled = 1, // Stream enabled
            };
            pub const Dmeie = enum(u1) {
                disabled = 0, // DME interrupt disabled
                enabled = 1, // DME interrupt enabled
            };
            pub const Teie = enum(u1) {
                disabled = 0, // TE interrupt disabled
                enabled = 1, // TE interrupt enabled
            };
            pub const Htie = enum(u1) {
                disabled = 0, // HT interrupt disabled
                enabled = 1, // HT interrupt enabled
            };
            pub const Tcie = enum(u1) {
                disabled = 0, // TC interrupt disabled
                enabled = 1, // TC interrupt enabled
            };
            pub const Pfctrl = enum(u1) {
                dma = 0, // The DMA is the flow controller
                peripheral = 1, // The peripheral is the flow controller
            };
            pub const Dir = enum(u2) {
                peripheral_to_memory = 0b00, // Peripheral-to-memory
                memory_to_peripheral = 0b01, // Memory-to-peripheral
                memory_to_memory = 0b10, // Memory-to-memory
            };
            pub const Circ = enum(u1) {
                disabled = 0, // Circular mode disabled
                enabled = 1, // Circular mode enabled
            };
            pub const Pinc = enum(u1) {
                fixed = 0, // Address pointer is fixed
                incremented = 1, // Address pointer is incremented after each data transfer
            };
            pub const Psize = enum(u2) {
                bits8 = 0b00, // Byte (8-bit)
                bits16 = 0b01, // Half-word (16-bit)
                bits32 = 0b10, // Word (32-bit)
            };
            pub const Pincos = enum(u1) {
                psize = 0, // The offset size for the peripheral address calculation is linked to the PSIZE
                fixed4 = 1, // The offset size for the peripheral address calculation is fixed to 4 (32-bit alignment)
            };
            pub const Pl = enum(u2) {
                low = 0b00, // Low
                medium = 0b01, // Medium
                high = 0b10, // High
                very_high = 0b11, // Very high
            };
            pub const Dbm = enum(u1) {
                disabled = 0, // No buffer switching at the end of transfer
                enabled = 1, // Memory target switched at the end of the DMA transfer
            };
            pub const Ct = enum(u1) {
                memory0 = 0, // The current target memory is Memory 0
                memory1 = 1, // The current target memory is Memory 1
            };
            pub const Pburst = enum(u2) {
                single = 0b00, // Single transfer
                incr4 = 0b01, // Incremental burst of 4 beats
                incr8 = 0b10, // Incremental burst of 8 beats
                incr16 = 0b11, // Incremental burst of 16 beats
            };
            en: En, // Stream enable / flag stream ready when read low (u1)
            dmeie: Dmeie, // Direct mode error interrupt enable (u1)
            teie: Teie, // Transfer error interrupt enable (u1)
            htie: Htie, // Half transfer interrupt enable (u1)
            tcie: Tcie, // Transfer complete interrupt enable (u1)
            pfctrl: Pfctrl, // Peripheral flow controller (u1)
            dir: Dir, // Data transfer direction (u2)
            circ: Circ, // Circular mode (u1)
            pinc: Pinc, // Peripheral increment mode (u1)
            minc: Pinc, // Memory increment mode (u1)
            psize: Psize, // Peripheral data size (u2)
            msize: Psize, // Memory data size (u2)
            pincos: Pincos, // Peripheral increment offset size (u1)
            pl: Pl, // Priority level (u2)
            dbm: Dbm, // Double buffer mode (u1)
            ct: Ct, // Current target (only in double buffer mode) (u1)
            _reserved_20_20: u1,
            pburst: Pburst, // Peripheral burst transfer configuration (u2)
            mburst: Pburst, // Memory burst transfer configuration (u2)
            chsel: u3, // Channel selection
            _padding_28_31: u4,
        };
        pub const st5cr = mmio(base_address + 0x88, 32, St5cr);

        /// address: 0x4002648c
        /// stream x number of data register
        pub const St5ndtr = packed struct {
            ndt: u16, // Number of data items to transfer
            _padding_16_31: u16,
        };
        pub const st5ndtr = mmio(base_address + 0x8c, 32, St5ndtr);

        /// address: 0x40026490
        /// stream x peripheral address register
        pub const St5par = packed struct {
            pa: u32, // Peripheral address
        };
        pub const st5par = mmio(base_address + 0x90, 32, St5par);

        /// address: 0x40026494
        /// stream x memory 0 address register
        pub const St5m0ar = packed struct {
            m0a: u32, // Memory 0 address
        };
        pub const st5m0ar = mmio(base_address + 0x94, 32, St5m0ar);

        /// address: 0x40026498
        /// stream x memory 1 address register
        pub const St5m1ar = packed struct {
            m1a: u32, // Memory 1 address (used in case of Double buffer mode)
        };
        pub const st5m1ar = mmio(base_address + 0x98, 32, St5m1ar);

        /// address: 0x4002649c
        /// stream x FIFO control register
        pub const St5fcr = packed struct {
            pub const Fth = enum(u2) {
                quarter = 0b00, // 1/4 full FIFO
                half = 0b01, // 1/2 full FIFO
                three_quarters = 0b10, // 3/4 full FIFO
                full = 0b11, // Full FIFO
            };
            pub const Dmdis = enum(u1) {
                enabled = 0, // Direct mode is enabled
                disabled = 1, // Direct mode is disabled
            };
            pub const Fs = enum(u3) {
                quarter1 = 0b000, // 0 < fifo_level < 1/4
                quarter2 = 0b001, // 1/4 <= fifo_level < 1/2
                quarter3 = 0b010, // 1/2 <= fifo_level < 3/4
                quarter4 = 0b011, // 3/4 <= fifo_level < full
                empty = 0b100, // FIFO is empty
                full = 0b101, // FIFO is full
            };
            pub const Feie = enum(u1) {
                disabled = 0, // FE interrupt disabled
                enabled = 1, // FE interrupt enabled
            };
            fth: Fth, // FIFO threshold selection (u2)
            dmdis: Dmdis, // Direct mode disable (u1)
            fs: Fs, // FIFO status (u3)
            _reserved_6_6: u1,
            feie: Feie, // FIFO error interrupt enable (u1)
            _padding_8_31: u24,
        };
        pub const st5fcr = mmio(base_address + 0x9c, 32, St5fcr);

        /// address: 0x400264a0
        /// stream x configuration register
        pub const St6cr = packed struct {
            pub const En = enum(u1) {
                disabled = 0, // Stream disabled
                enabled = 1, // Stream enabled
            };
            pub const Dmeie = enum(u1) {
                disabled = 0, // DME interrupt disabled
                enabled = 1, // DME interrupt enabled
            };
            pub const Teie = enum(u1) {
                disabled = 0, // TE interrupt disabled
                enabled = 1, // TE interrupt enabled
            };
            pub const Htie = enum(u1) {
                disabled = 0, // HT interrupt disabled
                enabled = 1, // HT interrupt enabled
            };
            pub const Tcie = enum(u1) {
                disabled = 0, // TC interrupt disabled
                enabled = 1, // TC interrupt enabled
            };
            pub const Pfctrl = enum(u1) {
                dma = 0, // The DMA is the flow controller
                peripheral = 1, // The peripheral is the flow controller
            };
            pub const Dir = enum(u2) {
                peripheral_to_memory = 0b00, // Peripheral-to-memory
                memory_to_peripheral = 0b01, // Memory-to-peripheral
                memory_to_memory = 0b10, // Memory-to-memory
            };
            pub const Circ = enum(u1) {
                disabled = 0, // Circular mode disabled
                enabled = 1, // Circular mode enabled
            };
            pub const Pinc = enum(u1) {
                fixed = 0, // Address pointer is fixed
                incremented = 1, // Address pointer is incremented after each data transfer
            };
            pub const Psize = enum(u2) {
                bits8 = 0b00, // Byte (8-bit)
                bits16 = 0b01, // Half-word (16-bit)
                bits32 = 0b10, // Word (32-bit)
            };
            pub const Pincos = enum(u1) {
                psize = 0, // The offset size for the peripheral address calculation is linked to the PSIZE
                fixed4 = 1, // The offset size for the peripheral address calculation is fixed to 4 (32-bit alignment)
            };
            pub const Pl = enum(u2) {
                low = 0b00, // Low
                medium = 0b01, // Medium
                high = 0b10, // High
                very_high = 0b11, // Very high
            };
            pub const Dbm = enum(u1) {
                disabled = 0, // No buffer switching at the end of transfer
                enabled = 1, // Memory target switched at the end of the DMA transfer
            };
            pub const Ct = enum(u1) {
                memory0 = 0, // The current target memory is Memory 0
                memory1 = 1, // The current target memory is Memory 1
            };
            pub const Pburst = enum(u2) {
                single = 0b00, // Single transfer
                incr4 = 0b01, // Incremental burst of 4 beats
                incr8 = 0b10, // Incremental burst of 8 beats
                incr16 = 0b11, // Incremental burst of 16 beats
            };
            en: En, // Stream enable / flag stream ready when read low (u1)
            dmeie: Dmeie, // Direct mode error interrupt enable (u1)
            teie: Teie, // Transfer error interrupt enable (u1)
            htie: Htie, // Half transfer interrupt enable (u1)
            tcie: Tcie, // Transfer complete interrupt enable (u1)
            pfctrl: Pfctrl, // Peripheral flow controller (u1)
            dir: Dir, // Data transfer direction (u2)
            circ: Circ, // Circular mode (u1)
            pinc: Pinc, // Peripheral increment mode (u1)
            minc: Pinc, // Memory increment mode (u1)
            psize: Psize, // Peripheral data size (u2)
            msize: Psize, // Memory data size (u2)
            pincos: Pincos, // Peripheral increment offset size (u1)
            pl: Pl, // Priority level (u2)
            dbm: Dbm, // Double buffer mode (u1)
            ct: Ct, // Current target (only in double buffer mode) (u1)
            _reserved_20_20: u1,
            pburst: Pburst, // Peripheral burst transfer configuration (u2)
            mburst: Pburst, // Memory burst transfer configuration (u2)
            chsel: u3, // Channel selection
            _padding_28_31: u4,
        };
        pub const st6cr = mmio(base_address + 0xa0, 32, St6cr);

        /// address: 0x400264a4
        /// stream x number of data register
        pub const St6ndtr = packed struct {
            ndt: u16, // Number of data items to transfer
            _padding_16_31: u16,
        };
        pub const st6ndtr = mmio(base_address + 0xa4, 32, St6ndtr);

        /// address: 0x400264a8
        /// stream x peripheral address register
        pub const St6par = packed struct {
            pa: u32, // Peripheral address
        };
        pub const st6par = mmio(base_address + 0xa8, 32, St6par);

        /// address: 0x400264ac
        /// stream x memory 0 address register
        pub const St6m0ar = packed struct {
            m0a: u32, // Memory 0 address
        };
        pub const st6m0ar = mmio(base_address + 0xac, 32, St6m0ar);

        /// address: 0x400264b0
        /// stream x memory 1 address register
        pub const St6m1ar = packed struct {
            m1a: u32, // Memory 1 address (used in case of Double buffer mode)
        };
        pub const st6m1ar = mmio(base_address + 0xb0, 32, St6m1ar);

        /// address: 0x400264b4
        /// stream x FIFO control register
        pub const St6fcr = packed struct {
            pub const Fth = enum(u2) {
                quarter = 0b00, // 1/4 full FIFO
                half = 0b01, // 1/2 full FIFO
                three_quarters = 0b10, // 3/4 full FIFO
                full = 0b11, // Full FIFO
            };
            pub const Dmdis = enum(u1) {
                enabled = 0, // Direct mode is enabled
                disabled = 1, // Direct mode is disabled
            };
            pub const Fs = enum(u3) {
                quarter1 = 0b000, // 0 < fifo_level < 1/4
                quarter2 = 0b001, // 1/4 <= fifo_level < 1/2
                quarter3 = 0b010, // 1/2 <= fifo_level < 3/4
                quarter4 = 0b011, // 3/4 <= fifo_level < full
                empty = 0b100, // FIFO is empty
                full = 0b101, // FIFO is full
            };
            pub const Feie = enum(u1) {
                disabled = 0, // FE interrupt disabled
                enabled = 1, // FE interrupt enabled
            };
            fth: Fth, // FIFO threshold selection (u2)
            dmdis: Dmdis, // Direct mode disable (u1)
            fs: Fs, // FIFO status (u3)
            _reserved_6_6: u1,
            feie: Feie, // FIFO error interrupt enable (u1)
            _padding_8_31: u24,
        };
        pub const st6fcr = mmio(base_address + 0xb4, 32, St6fcr);

        /// address: 0x400264b8
        /// stream x configuration register
        pub const St7cr = packed struct {
            pub const En = enum(u1) {
                disabled = 0, // Stream disabled
                enabled = 1, // Stream enabled
            };
            pub const Dmeie = enum(u1) {
                disabled = 0, // DME interrupt disabled
                enabled = 1, // DME interrupt enabled
            };
            pub const Teie = enum(u1) {
                disabled = 0, // TE interrupt disabled
                enabled = 1, // TE interrupt enabled
            };
            pub const Htie = enum(u1) {
                disabled = 0, // HT interrupt disabled
                enabled = 1, // HT interrupt enabled
            };
            pub const Tcie = enum(u1) {
                disabled = 0, // TC interrupt disabled
                enabled = 1, // TC interrupt enabled
            };
            pub const Pfctrl = enum(u1) {
                dma = 0, // The DMA is the flow controller
                peripheral = 1, // The peripheral is the flow controller
            };
            pub const Dir = enum(u2) {
                peripheral_to_memory = 0b00, // Peripheral-to-memory
                memory_to_peripheral = 0b01, // Memory-to-peripheral
                memory_to_memory = 0b10, // Memory-to-memory
            };
            pub const Circ = enum(u1) {
                disabled = 0, // Circular mode disabled
                enabled = 1, // Circular mode enabled
            };
            pub const Pinc = enum(u1) {
                fixed = 0, // Address pointer is fixed
                incremented = 1, // Address pointer is incremented after each data transfer
            };
            pub const Psize = enum(u2) {
                bits8 = 0b00, // Byte (8-bit)
                bits16 = 0b01, // Half-word (16-bit)
                bits32 = 0b10, // Word (32-bit)
            };
            pub const Pincos = enum(u1) {
                psize = 0, // The offset size for the peripheral address calculation is linked to the PSIZE
                fixed4 = 1, // The offset size for the peripheral address calculation is fixed to 4 (32-bit alignment)
            };
            pub const Pl = enum(u2) {
                low = 0b00, // Low
                medium = 0b01, // Medium
                high = 0b10, // High
                very_high = 0b11, // Very high
            };
            pub const Dbm = enum(u1) {
                disabled = 0, // No buffer switching at the end of transfer
                enabled = 1, // Memory target switched at the end of the DMA transfer
            };
            pub const Ct = enum(u1) {
                memory0 = 0, // The current target memory is Memory 0
                memory1 = 1, // The current target memory is Memory 1
            };
            pub const Pburst = enum(u2) {
                single = 0b00, // Single transfer
                incr4 = 0b01, // Incremental burst of 4 beats
                incr8 = 0b10, // Incremental burst of 8 beats
                incr16 = 0b11, // Incremental burst of 16 beats
            };
            en: En, // Stream enable / flag stream ready when read low (u1)
            dmeie: Dmeie, // Direct mode error interrupt enable (u1)
            teie: Teie, // Transfer error interrupt enable (u1)
            htie: Htie, // Half transfer interrupt enable (u1)
            tcie: Tcie, // Transfer complete interrupt enable (u1)
            pfctrl: Pfctrl, // Peripheral flow controller (u1)
            dir: Dir, // Data transfer direction (u2)
            circ: Circ, // Circular mode (u1)
            pinc: Pinc, // Peripheral increment mode (u1)
            minc: Pinc, // Memory increment mode (u1)
            psize: Psize, // Peripheral data size (u2)
            msize: Psize, // Memory data size (u2)
            pincos: Pincos, // Peripheral increment offset size (u1)
            pl: Pl, // Priority level (u2)
            dbm: Dbm, // Double buffer mode (u1)
            ct: Ct, // Current target (only in double buffer mode) (u1)
            _reserved_20_20: u1,
            pburst: Pburst, // Peripheral burst transfer configuration (u2)
            mburst: Pburst, // Memory burst transfer configuration (u2)
            chsel: u3, // Channel selection
            _padding_28_31: u4,
        };
        pub const st7cr = mmio(base_address + 0xb8, 32, St7cr);

        /// address: 0x400264bc
        /// stream x number of data register
        pub const St7ndtr = packed struct {
            ndt: u16, // Number of data items to transfer
            _padding_16_31: u16,
        };
        pub const st7ndtr = mmio(base_address + 0xbc, 32, St7ndtr);

        /// address: 0x400264c0
        /// stream x peripheral address register
        pub const St7par = packed struct {
            pa: u32, // Peripheral address
        };
        pub const st7par = mmio(base_address + 0xc0, 32, St7par);

        /// address: 0x400264c4
        /// stream x memory 0 address register
        pub const St7m0ar = packed struct {
            m0a: u32, // Memory 0 address
        };
        pub const st7m0ar = mmio(base_address + 0xc4, 32, St7m0ar);

        /// address: 0x400264c8
        /// stream x memory 1 address register
        pub const St7m1ar = packed struct {
            m1a: u32, // Memory 1 address (used in case of Double buffer mode)
        };
        pub const st7m1ar = mmio(base_address + 0xc8, 32, St7m1ar);

        /// address: 0x400264cc
        /// stream x FIFO control register
        pub const St7fcr = packed struct {
            pub const Fth = enum(u2) {
                quarter = 0b00, // 1/4 full FIFO
                half = 0b01, // 1/2 full FIFO
                three_quarters = 0b10, // 3/4 full FIFO
                full = 0b11, // Full FIFO
            };
            pub const Dmdis = enum(u1) {
                enabled = 0, // Direct mode is enabled
                disabled = 1, // Direct mode is disabled
            };
            pub const Fs = enum(u3) {
                quarter1 = 0b000, // 0 < fifo_level < 1/4
                quarter2 = 0b001, // 1/4 <= fifo_level < 1/2
                quarter3 = 0b010, // 1/2 <= fifo_level < 3/4
                quarter4 = 0b011, // 3/4 <= fifo_level < full
                empty = 0b100, // FIFO is empty
                full = 0b101, // FIFO is full
            };
            pub const Feie = enum(u1) {
                disabled = 0, // FE interrupt disabled
                enabled = 1, // FE interrupt enabled
            };
            fth: Fth, // FIFO threshold selection (u2)
            dmdis: Dmdis, // Direct mode disable (u1)
            fs: Fs, // FIFO status (u3)
            _reserved_6_6: u1,
            feie: Feie, // FIFO error interrupt enable (u1)
            _padding_8_31: u24,
        };
        pub const st7fcr = mmio(base_address + 0xcc, 32, St7fcr);
    };
    /// General-purpose I/Os
    pub const gpioe = struct {
        pub const base_address = 0x40021000;

        /// address: 0x40021000
        /// GPIO port mode register
        pub const Moder = packed struct {
            pub const Moder0 = enum(u2) {
                input = 0b00, // Input mode (reset state)
                output = 0b01, // General purpose output mode
                alternate = 0b10, // Alternate function mode
                analog = 0b11, // Analog mode
            };
            moder0: Moder0, // Port x configuration bits (y = 0..15) (u2)
            moder1: Moder0, // Port x configuration bits (y = 0..15) (u2)
            moder2: Moder0, // Port x configuration bits (y = 0..15) (u2)
            moder3: Moder0, // Port x configuration bits (y = 0..15) (u2)
            moder4: Moder0, // Port x configuration bits (y = 0..15) (u2)
            moder5: Moder0, // Port x configuration bits (y = 0..15) (u2)
            moder6: Moder0, // Port x configuration bits (y = 0..15) (u2)
            moder7: Moder0, // Port x configuration bits (y = 0..15) (u2)
            moder8: Moder0, // Port x configuration bits (y = 0..15) (u2)
            moder9: Moder0, // Port x configuration bits (y = 0..15) (u2)
            moder10: Moder0, // Port x configuration bits (y = 0..15) (u2)
            moder11: Moder0, // Port x configuration bits (y = 0..15) (u2)
            moder12: Moder0, // Port x configuration bits (y = 0..15) (u2)
            moder13: Moder0, // Port x configuration bits (y = 0..15) (u2)
            moder14: Moder0, // Port x configuration bits (y = 0..15) (u2)
            moder15: Moder0, // Port x configuration bits (y = 0..15) (u2)
        };
        pub const moder = mmio(base_address + 0x0, 32, Moder);

        /// address: 0x40021004
        /// GPIO port output type register
        pub const Otyper = packed struct {
            pub const Ot0 = enum(u1) {
                push_pull = 0, // Output push-pull (reset state)
                open_drain = 1, // Output open-drain
            };
            ot0: Ot0, // Port x configuration bits (y = 0..15) (u1)
            ot1: Ot0, // Port x configuration bits (y = 0..15) (u1)
            ot2: Ot0, // Port x configuration bits (y = 0..15) (u1)
            ot3: Ot0, // Port x configuration bits (y = 0..15) (u1)
            ot4: Ot0, // Port x configuration bits (y = 0..15) (u1)
            ot5: Ot0, // Port x configuration bits (y = 0..15) (u1)
            ot6: Ot0, // Port x configuration bits (y = 0..15) (u1)
            ot7: Ot0, // Port x configuration bits (y = 0..15) (u1)
            ot8: Ot0, // Port x configuration bits (y = 0..15) (u1)
            ot9: Ot0, // Port x configuration bits (y = 0..15) (u1)
            ot10: Ot0, // Port x configuration bits (y = 0..15) (u1)
            ot11: Ot0, // Port x configuration bits (y = 0..15) (u1)
            ot12: Ot0, // Port x configuration bits (y = 0..15) (u1)
            ot13: Ot0, // Port x configuration bits (y = 0..15) (u1)
            ot14: Ot0, // Port x configuration bits (y = 0..15) (u1)
            ot15: Ot0, // Port x configuration bits (y = 0..15) (u1)
            _padding_16_31: u16,
        };
        pub const otyper = mmio(base_address + 0x4, 32, Otyper);

        /// address: 0x40021008
        /// GPIO port output speed register
        pub const Ospeedr = packed struct {
            pub const Ospeedr0 = enum(u2) {
                low_speed = 0b00, // Low speed
                medium_speed = 0b01, // Medium speed
                high_speed = 0b10, // High speed
                very_high_speed = 0b11, // Very high speed
            };
            ospeedr0: Ospeedr0, // Port x configuration bits (y = 0..15) (u2)
            ospeedr1: Ospeedr0, // Port x configuration bits (y = 0..15) (u2)
            ospeedr2: Ospeedr0, // Port x configuration bits (y = 0..15) (u2)
            ospeedr3: Ospeedr0, // Port x configuration bits (y = 0..15) (u2)
            ospeedr4: Ospeedr0, // Port x configuration bits (y = 0..15) (u2)
            ospeedr5: Ospeedr0, // Port x configuration bits (y = 0..15) (u2)
            ospeedr6: Ospeedr0, // Port x configuration bits (y = 0..15) (u2)
            ospeedr7: Ospeedr0, // Port x configuration bits (y = 0..15) (u2)
            ospeedr8: Ospeedr0, // Port x configuration bits (y = 0..15) (u2)
            ospeedr9: Ospeedr0, // Port x configuration bits (y = 0..15) (u2)
            ospeedr10: Ospeedr0, // Port x configuration bits (y = 0..15) (u2)
            ospeedr11: Ospeedr0, // Port x configuration bits (y = 0..15) (u2)
            ospeedr12: Ospeedr0, // Port x configuration bits (y = 0..15) (u2)
            ospeedr13: Ospeedr0, // Port x configuration bits (y = 0..15) (u2)
            ospeedr14: Ospeedr0, // Port x configuration bits (y = 0..15) (u2)
            ospeedr15: Ospeedr0, // Port x configuration bits (y = 0..15) (u2)
        };
        pub const ospeedr = mmio(base_address + 0x8, 32, Ospeedr);

        /// address: 0x4002100c
        /// GPIO port pull-up/pull-down register
        pub const Pupdr = packed struct {
            pub const Pupdr0 = enum(u2) {
                floating = 0b00, // No pull-up, pull-down
                pull_up = 0b01, // Pull-up
                pull_down = 0b10, // Pull-down
            };
            pupdr0: Pupdr0, // Port x configuration bits (y = 0..15) (u2)
            pupdr1: Pupdr0, // Port x configuration bits (y = 0..15) (u2)
            pupdr2: Pupdr0, // Port x configuration bits (y = 0..15) (u2)
            pupdr3: Pupdr0, // Port x configuration bits (y = 0..15) (u2)
            pupdr4: Pupdr0, // Port x configuration bits (y = 0..15) (u2)
            pupdr5: Pupdr0, // Port x configuration bits (y = 0..15) (u2)
            pupdr6: Pupdr0, // Port x configuration bits (y = 0..15) (u2)
            pupdr7: Pupdr0, // Port x configuration bits (y = 0..15) (u2)
            pupdr8: Pupdr0, // Port x configuration bits (y = 0..15) (u2)
            pupdr9: Pupdr0, // Port x configuration bits (y = 0..15) (u2)
            pupdr10: Pupdr0, // Port x configuration bits (y = 0..15) (u2)
            pupdr11: Pupdr0, // Port x configuration bits (y = 0..15) (u2)
            pupdr12: Pupdr0, // Port x configuration bits (y = 0..15) (u2)
            pupdr13: Pupdr0, // Port x configuration bits (y = 0..15) (u2)
            pupdr14: Pupdr0, // Port x configuration bits (y = 0..15) (u2)
            pupdr15: Pupdr0, // Port x configuration bits (y = 0..15) (u2)
        };
        pub const pupdr = mmio(base_address + 0xc, 32, Pupdr);

        /// address: 0x40021010
        /// GPIO port input data register
        pub const Idr = packed struct {
            pub const Idr0 = enum(u1) {
                high = 1, // Input is logic high
                low = 0, // Input is logic low
            };
            idr0: Idr0, // Port input data (y = 0..15) (u1)
            idr1: Idr0, // Port input data (y = 0..15) (u1)
            idr2: Idr0, // Port input data (y = 0..15) (u1)
            idr3: Idr0, // Port input data (y = 0..15) (u1)
            idr4: Idr0, // Port input data (y = 0..15) (u1)
            idr5: Idr0, // Port input data (y = 0..15) (u1)
            idr6: Idr0, // Port input data (y = 0..15) (u1)
            idr7: Idr0, // Port input data (y = 0..15) (u1)
            idr8: Idr0, // Port input data (y = 0..15) (u1)
            idr9: Idr0, // Port input data (y = 0..15) (u1)
            idr10: Idr0, // Port input data (y = 0..15) (u1)
            idr11: Idr0, // Port input data (y = 0..15) (u1)
            idr12: Idr0, // Port input data (y = 0..15) (u1)
            idr13: Idr0, // Port input data (y = 0..15) (u1)
            idr14: Idr0, // Port input data (y = 0..15) (u1)
            idr15: Idr0, // Port input data (y = 0..15) (u1)
            _padding_16_31: u16,
        };
        pub const idr = mmio(base_address + 0x10, 32, Idr);

        /// address: 0x40021014
        /// GPIO port output data register
        pub const Odr = packed struct {
            pub const Odr0 = enum(u1) {
                high = 1, // Set output to logic high
                low = 0, // Set output to logic low
            };
            odr0: Odr0, // Port output data (y = 0..15) (u1)
            odr1: Odr0, // Port output data (y = 0..15) (u1)
            odr2: Odr0, // Port output data (y = 0..15) (u1)
            odr3: Odr0, // Port output data (y = 0..15) (u1)
            odr4: Odr0, // Port output data (y = 0..15) (u1)
            odr5: Odr0, // Port output data (y = 0..15) (u1)
            odr6: Odr0, // Port output data (y = 0..15) (u1)
            odr7: Odr0, // Port output data (y = 0..15) (u1)
            odr8: Odr0, // Port output data (y = 0..15) (u1)
            odr9: Odr0, // Port output data (y = 0..15) (u1)
            odr10: Odr0, // Port output data (y = 0..15) (u1)
            odr11: Odr0, // Port output data (y = 0..15) (u1)
            odr12: Odr0, // Port output data (y = 0..15) (u1)
            odr13: Odr0, // Port output data (y = 0..15) (u1)
            odr14: Odr0, // Port output data (y = 0..15) (u1)
            odr15: Odr0, // Port output data (y = 0..15) (u1)
            _padding_16_31: u16,
        };
        pub const odr = mmio(base_address + 0x14, 32, Odr);

        /// address: 0x40021018
        /// GPIO port bit set/reset register
        pub const Bsrr = packed struct {
            pub const Bs0w = enum(u1) {
                set = 1, // Sets the corresponding ODRx bit
            };
            pub const Br0w = enum(u1) {
                reset = 1, // Resets the corresponding ODRx bit
            };
            bs0: Bs0w, // Port x set bit y (y= 0..15) (u1)
            bs1: Bs0w, // Port x set bit y (y= 0..15) (u1)
            bs2: Bs0w, // Port x set bit y (y= 0..15) (u1)
            bs3: Bs0w, // Port x set bit y (y= 0..15) (u1)
            bs4: Bs0w, // Port x set bit y (y= 0..15) (u1)
            bs5: Bs0w, // Port x set bit y (y= 0..15) (u1)
            bs6: Bs0w, // Port x set bit y (y= 0..15) (u1)
            bs7: Bs0w, // Port x set bit y (y= 0..15) (u1)
            bs8: Bs0w, // Port x set bit y (y= 0..15) (u1)
            bs9: Bs0w, // Port x set bit y (y= 0..15) (u1)
            bs10: Bs0w, // Port x set bit y (y= 0..15) (u1)
            bs11: Bs0w, // Port x set bit y (y= 0..15) (u1)
            bs12: Bs0w, // Port x set bit y (y= 0..15) (u1)
            bs13: Bs0w, // Port x set bit y (y= 0..15) (u1)
            bs14: Bs0w, // Port x set bit y (y= 0..15) (u1)
            bs15: Bs0w, // Port x set bit y (y= 0..15) (u1)
            br0: Br0w, // Port x set bit y (y= 0..15) (u1)
            br1: Br0w, // Port x reset bit y (y = 0..15) (u1)
            br2: Br0w, // Port x reset bit y (y = 0..15) (u1)
            br3: Br0w, // Port x reset bit y (y = 0..15) (u1)
            br4: Br0w, // Port x reset bit y (y = 0..15) (u1)
            br5: Br0w, // Port x reset bit y (y = 0..15) (u1)
            br6: Br0w, // Port x reset bit y (y = 0..15) (u1)
            br7: Br0w, // Port x reset bit y (y = 0..15) (u1)
            br8: Br0w, // Port x reset bit y (y = 0..15) (u1)
            br9: Br0w, // Port x reset bit y (y = 0..15) (u1)
            br10: Br0w, // Port x reset bit y (y = 0..15) (u1)
            br11: Br0w, // Port x reset bit y (y = 0..15) (u1)
            br12: Br0w, // Port x reset bit y (y = 0..15) (u1)
            br13: Br0w, // Port x reset bit y (y = 0..15) (u1)
            br14: Br0w, // Port x reset bit y (y = 0..15) (u1)
            br15: Br0w, // Port x reset bit y (y = 0..15) (u1)
        };
        pub const bsrr = mmio(base_address + 0x18, 32, Bsrr);

        /// address: 0x4002101c
        /// GPIO port configuration lock register
        pub const Lckr = packed struct {
            pub const Lck0 = enum(u1) {
                unlocked = 0, // Port configuration not locked
                locked = 1, // Port configuration locked
            };
            pub const Lckk = enum(u1) {
                not_active = 0, // Port configuration lock key not active
                active = 1, // Port configuration lock key active
            };
            lck0: Lck0, // Port x lock bit y (y= 0..15) (u1)
            lck1: Lck0, // Port x lock bit y (y= 0..15) (u1)
            lck2: Lck0, // Port x lock bit y (y= 0..15) (u1)
            lck3: Lck0, // Port x lock bit y (y= 0..15) (u1)
            lck4: Lck0, // Port x lock bit y (y= 0..15) (u1)
            lck5: Lck0, // Port x lock bit y (y= 0..15) (u1)
            lck6: Lck0, // Port x lock bit y (y= 0..15) (u1)
            lck7: Lck0, // Port x lock bit y (y= 0..15) (u1)
            lck8: Lck0, // Port x lock bit y (y= 0..15) (u1)
            lck9: Lck0, // Port x lock bit y (y= 0..15) (u1)
            lck10: Lck0, // Port x lock bit y (y= 0..15) (u1)
            lck11: Lck0, // Port x lock bit y (y= 0..15) (u1)
            lck12: Lck0, // Port x lock bit y (y= 0..15) (u1)
            lck13: Lck0, // Port x lock bit y (y= 0..15) (u1)
            lck14: Lck0, // Port x lock bit y (y= 0..15) (u1)
            lck15: Lck0, // Port x lock bit y (y= 0..15) (u1)
            lckk: Lckk, // Port x lock bit y (y= 0..15) (u1)
            _padding_17_31: u15,
        };
        pub const lckr = mmio(base_address + 0x1c, 32, Lckr);

        /// address: 0x40021020
        /// GPIO alternate function low register
        pub const Afrl = packed struct {
            pub const Afrl0 = enum(u4) {
                af0 = 0b0000, // AF0
                af1 = 0b0001, // AF1
                af2 = 0b0010, // AF2
                af3 = 0b0011, // AF3
                af4 = 0b0100, // AF4
                af5 = 0b0101, // AF5
                af6 = 0b0110, // AF6
                af7 = 0b0111, // AF7
                af8 = 0b1000, // AF8
                af9 = 0b1001, // AF9
                af10 = 0b1010, // AF10
                af11 = 0b1011, // AF11
                af12 = 0b1100, // AF12
                af13 = 0b1101, // AF13
                af14 = 0b1110, // AF14
                af15 = 0b1111, // AF15
            };
            afrl0: Afrl0, // Alternate function selection for port x bit y (y = 0..7) (u4)
            afrl1: Afrl0, // Alternate function selection for port x bit y (y = 0..7) (u4)
            afrl2: Afrl0, // Alternate function selection for port x bit y (y = 0..7) (u4)
            afrl3: Afrl0, // Alternate function selection for port x bit y (y = 0..7) (u4)
            afrl4: Afrl0, // Alternate function selection for port x bit y (y = 0..7) (u4)
            afrl5: Afrl0, // Alternate function selection for port x bit y (y = 0..7) (u4)
            afrl6: Afrl0, // Alternate function selection for port x bit y (y = 0..7) (u4)
            afrl7: Afrl0, // Alternate function selection for port x bit y (y = 0..7) (u4)
        };
        pub const afrl = mmio(base_address + 0x20, 32, Afrl);

        /// address: 0x40021024
        /// GPIO alternate function high register
        pub const Afrh = packed struct {
            pub const Afrh8 = enum(u4) {
                af0 = 0b0000, // AF0
                af1 = 0b0001, // AF1
                af2 = 0b0010, // AF2
                af3 = 0b0011, // AF3
                af4 = 0b0100, // AF4
                af5 = 0b0101, // AF5
                af6 = 0b0110, // AF6
                af7 = 0b0111, // AF7
                af8 = 0b1000, // AF8
                af9 = 0b1001, // AF9
                af10 = 0b1010, // AF10
                af11 = 0b1011, // AF11
                af12 = 0b1100, // AF12
                af13 = 0b1101, // AF13
                af14 = 0b1110, // AF14
                af15 = 0b1111, // AF15
            };
            afrh8: Afrh8, // Alternate function selection for port x bit y (y = 8..15) (u4)
            afrh9: Afrh8, // Alternate function selection for port x bit y (y = 8..15) (u4)
            afrh10: Afrh8, // Alternate function selection for port x bit y (y = 8..15) (u4)
            afrh11: Afrh8, // Alternate function selection for port x bit y (y = 8..15) (u4)
            afrh12: Afrh8, // Alternate function selection for port x bit y (y = 8..15) (u4)
            afrh13: Afrh8, // Alternate function selection for port x bit y (y = 8..15) (u4)
            afrh14: Afrh8, // Alternate function selection for port x bit y (y = 8..15) (u4)
            afrh15: Afrh8, // Alternate function selection for port x bit y (y = 8..15) (u4)
        };
        pub const afrh = mmio(base_address + 0x24, 32, Afrh);
    };
    /// General-purpose I/Os
    pub const gpiod = struct {
        pub const base_address = 0x40020c00;

        /// address: 0x40020c00
        /// GPIO port mode register
        pub const Moder = packed struct {
            pub const Moder0 = enum(u2) {
                input = 0b00, // Input mode (reset state)
                output = 0b01, // General purpose output mode
                alternate = 0b10, // Alternate function mode
                analog = 0b11, // Analog mode
            };
            moder0: Moder0, // Port x configuration bits (y = 0..15) (u2)
            moder1: Moder0, // Port x configuration bits (y = 0..15) (u2)
            moder2: Moder0, // Port x configuration bits (y = 0..15) (u2)
            moder3: Moder0, // Port x configuration bits (y = 0..15) (u2)
            moder4: Moder0, // Port x configuration bits (y = 0..15) (u2)
            moder5: Moder0, // Port x configuration bits (y = 0..15) (u2)
            moder6: Moder0, // Port x configuration bits (y = 0..15) (u2)
            moder7: Moder0, // Port x configuration bits (y = 0..15) (u2)
            moder8: Moder0, // Port x configuration bits (y = 0..15) (u2)
            moder9: Moder0, // Port x configuration bits (y = 0..15) (u2)
            moder10: Moder0, // Port x configuration bits (y = 0..15) (u2)
            moder11: Moder0, // Port x configuration bits (y = 0..15) (u2)
            moder12: Moder0, // Port x configuration bits (y = 0..15) (u2)
            moder13: Moder0, // Port x configuration bits (y = 0..15) (u2)
            moder14: Moder0, // Port x configuration bits (y = 0..15) (u2)
            moder15: Moder0, // Port x configuration bits (y = 0..15) (u2)
        };
        pub const moder = mmio(base_address + 0x0, 32, Moder);

        /// address: 0x40020c04
        /// GPIO port output type register
        pub const Otyper = packed struct {
            pub const Ot0 = enum(u1) {
                push_pull = 0, // Output push-pull (reset state)
                open_drain = 1, // Output open-drain
            };
            ot0: Ot0, // Port x configuration bits (y = 0..15) (u1)
            ot1: Ot0, // Port x configuration bits (y = 0..15) (u1)
            ot2: Ot0, // Port x configuration bits (y = 0..15) (u1)
            ot3: Ot0, // Port x configuration bits (y = 0..15) (u1)
            ot4: Ot0, // Port x configuration bits (y = 0..15) (u1)
            ot5: Ot0, // Port x configuration bits (y = 0..15) (u1)
            ot6: Ot0, // Port x configuration bits (y = 0..15) (u1)
            ot7: Ot0, // Port x configuration bits (y = 0..15) (u1)
            ot8: Ot0, // Port x configuration bits (y = 0..15) (u1)
            ot9: Ot0, // Port x configuration bits (y = 0..15) (u1)
            ot10: Ot0, // Port x configuration bits (y = 0..15) (u1)
            ot11: Ot0, // Port x configuration bits (y = 0..15) (u1)
            ot12: Ot0, // Port x configuration bits (y = 0..15) (u1)
            ot13: Ot0, // Port x configuration bits (y = 0..15) (u1)
            ot14: Ot0, // Port x configuration bits (y = 0..15) (u1)
            ot15: Ot0, // Port x configuration bits (y = 0..15) (u1)
            _padding_16_31: u16,
        };
        pub const otyper = mmio(base_address + 0x4, 32, Otyper);

        /// address: 0x40020c08
        /// GPIO port output speed register
        pub const Ospeedr = packed struct {
            pub const Ospeedr0 = enum(u2) {
                low_speed = 0b00, // Low speed
                medium_speed = 0b01, // Medium speed
                high_speed = 0b10, // High speed
                very_high_speed = 0b11, // Very high speed
            };
            ospeedr0: Ospeedr0, // Port x configuration bits (y = 0..15) (u2)
            ospeedr1: Ospeedr0, // Port x configuration bits (y = 0..15) (u2)
            ospeedr2: Ospeedr0, // Port x configuration bits (y = 0..15) (u2)
            ospeedr3: Ospeedr0, // Port x configuration bits (y = 0..15) (u2)
            ospeedr4: Ospeedr0, // Port x configuration bits (y = 0..15) (u2)
            ospeedr5: Ospeedr0, // Port x configuration bits (y = 0..15) (u2)
            ospeedr6: Ospeedr0, // Port x configuration bits (y = 0..15) (u2)
            ospeedr7: Ospeedr0, // Port x configuration bits (y = 0..15) (u2)
            ospeedr8: Ospeedr0, // Port x configuration bits (y = 0..15) (u2)
            ospeedr9: Ospeedr0, // Port x configuration bits (y = 0..15) (u2)
            ospeedr10: Ospeedr0, // Port x configuration bits (y = 0..15) (u2)
            ospeedr11: Ospeedr0, // Port x configuration bits (y = 0..15) (u2)
            ospeedr12: Ospeedr0, // Port x configuration bits (y = 0..15) (u2)
            ospeedr13: Ospeedr0, // Port x configuration bits (y = 0..15) (u2)
            ospeedr14: Ospeedr0, // Port x configuration bits (y = 0..15) (u2)
            ospeedr15: Ospeedr0, // Port x configuration bits (y = 0..15) (u2)
        };
        pub const ospeedr = mmio(base_address + 0x8, 32, Ospeedr);

        /// address: 0x40020c0c
        /// GPIO port pull-up/pull-down register
        pub const Pupdr = packed struct {
            pub const Pupdr0 = enum(u2) {
                floating = 0b00, // No pull-up, pull-down
                pull_up = 0b01, // Pull-up
                pull_down = 0b10, // Pull-down
            };
            pupdr0: Pupdr0, // Port x configuration bits (y = 0..15) (u2)
            pupdr1: Pupdr0, // Port x configuration bits (y = 0..15) (u2)
            pupdr2: Pupdr0, // Port x configuration bits (y = 0..15) (u2)
            pupdr3: Pupdr0, // Port x configuration bits (y = 0..15) (u2)
            pupdr4: Pupdr0, // Port x configuration bits (y = 0..15) (u2)
            pupdr5: Pupdr0, // Port x configuration bits (y = 0..15) (u2)
            pupdr6: Pupdr0, // Port x configuration bits (y = 0..15) (u2)
            pupdr7: Pupdr0, // Port x configuration bits (y = 0..15) (u2)
            pupdr8: Pupdr0, // Port x configuration bits (y = 0..15) (u2)
            pupdr9: Pupdr0, // Port x configuration bits (y = 0..15) (u2)
            pupdr10: Pupdr0, // Port x configuration bits (y = 0..15) (u2)
            pupdr11: Pupdr0, // Port x configuration bits (y = 0..15) (u2)
            pupdr12: Pupdr0, // Port x configuration bits (y = 0..15) (u2)
            pupdr13: Pupdr0, // Port x configuration bits (y = 0..15) (u2)
            pupdr14: Pupdr0, // Port x configuration bits (y = 0..15) (u2)
            pupdr15: Pupdr0, // Port x configuration bits (y = 0..15) (u2)
        };
        pub const pupdr = mmio(base_address + 0xc, 32, Pupdr);

        /// address: 0x40020c10
        /// GPIO port input data register
        pub const Idr = packed struct {
            pub const Idr0 = enum(u1) {
                high = 1, // Input is logic high
                low = 0, // Input is logic low
            };
            idr0: Idr0, // Port input data (y = 0..15) (u1)
            idr1: Idr0, // Port input data (y = 0..15) (u1)
            idr2: Idr0, // Port input data (y = 0..15) (u1)
            idr3: Idr0, // Port input data (y = 0..15) (u1)
            idr4: Idr0, // Port input data (y = 0..15) (u1)
            idr5: Idr0, // Port input data (y = 0..15) (u1)
            idr6: Idr0, // Port input data (y = 0..15) (u1)
            idr7: Idr0, // Port input data (y = 0..15) (u1)
            idr8: Idr0, // Port input data (y = 0..15) (u1)
            idr9: Idr0, // Port input data (y = 0..15) (u1)
            idr10: Idr0, // Port input data (y = 0..15) (u1)
            idr11: Idr0, // Port input data (y = 0..15) (u1)
            idr12: Idr0, // Port input data (y = 0..15) (u1)
            idr13: Idr0, // Port input data (y = 0..15) (u1)
            idr14: Idr0, // Port input data (y = 0..15) (u1)
            idr15: Idr0, // Port input data (y = 0..15) (u1)
            _padding_16_31: u16,
        };
        pub const idr = mmio(base_address + 0x10, 32, Idr);

        /// address: 0x40020c14
        /// GPIO port output data register
        pub const Odr = packed struct {
            pub const Odr0 = enum(u1) {
                high = 1, // Set output to logic high
                low = 0, // Set output to logic low
            };
            odr0: Odr0, // Port output data (y = 0..15) (u1)
            odr1: Odr0, // Port output data (y = 0..15) (u1)
            odr2: Odr0, // Port output data (y = 0..15) (u1)
            odr3: Odr0, // Port output data (y = 0..15) (u1)
            odr4: Odr0, // Port output data (y = 0..15) (u1)
            odr5: Odr0, // Port output data (y = 0..15) (u1)
            odr6: Odr0, // Port output data (y = 0..15) (u1)
            odr7: Odr0, // Port output data (y = 0..15) (u1)
            odr8: Odr0, // Port output data (y = 0..15) (u1)
            odr9: Odr0, // Port output data (y = 0..15) (u1)
            odr10: Odr0, // Port output data (y = 0..15) (u1)
            odr11: Odr0, // Port output data (y = 0..15) (u1)
            odr12: Odr0, // Port output data (y = 0..15) (u1)
            odr13: Odr0, // Port output data (y = 0..15) (u1)
            odr14: Odr0, // Port output data (y = 0..15) (u1)
            odr15: Odr0, // Port output data (y = 0..15) (u1)
            _padding_16_31: u16,
        };
        pub const odr = mmio(base_address + 0x14, 32, Odr);

        /// address: 0x40020c18
        /// GPIO port bit set/reset register
        pub const Bsrr = packed struct {
            pub const Bs0w = enum(u1) {
                set = 1, // Sets the corresponding ODRx bit
            };
            pub const Br0w = enum(u1) {
                reset = 1, // Resets the corresponding ODRx bit
            };
            bs0: Bs0w, // Port x set bit y (y= 0..15) (u1)
            bs1: Bs0w, // Port x set bit y (y= 0..15) (u1)
            bs2: Bs0w, // Port x set bit y (y= 0..15) (u1)
            bs3: Bs0w, // Port x set bit y (y= 0..15) (u1)
            bs4: Bs0w, // Port x set bit y (y= 0..15) (u1)
            bs5: Bs0w, // Port x set bit y (y= 0..15) (u1)
            bs6: Bs0w, // Port x set bit y (y= 0..15) (u1)
            bs7: Bs0w, // Port x set bit y (y= 0..15) (u1)
            bs8: Bs0w, // Port x set bit y (y= 0..15) (u1)
            bs9: Bs0w, // Port x set bit y (y= 0..15) (u1)
            bs10: Bs0w, // Port x set bit y (y= 0..15) (u1)
            bs11: Bs0w, // Port x set bit y (y= 0..15) (u1)
            bs12: Bs0w, // Port x set bit y (y= 0..15) (u1)
            bs13: Bs0w, // Port x set bit y (y= 0..15) (u1)
            bs14: Bs0w, // Port x set bit y (y= 0..15) (u1)
            bs15: Bs0w, // Port x set bit y (y= 0..15) (u1)
            br0: Br0w, // Port x set bit y (y= 0..15) (u1)
            br1: Br0w, // Port x reset bit y (y = 0..15) (u1)
            br2: Br0w, // Port x reset bit y (y = 0..15) (u1)
            br3: Br0w, // Port x reset bit y (y = 0..15) (u1)
            br4: Br0w, // Port x reset bit y (y = 0..15) (u1)
            br5: Br0w, // Port x reset bit y (y = 0..15) (u1)
            br6: Br0w, // Port x reset bit y (y = 0..15) (u1)
            br7: Br0w, // Port x reset bit y (y = 0..15) (u1)
            br8: Br0w, // Port x reset bit y (y = 0..15) (u1)
            br9: Br0w, // Port x reset bit y (y = 0..15) (u1)
            br10: Br0w, // Port x reset bit y (y = 0..15) (u1)
            br11: Br0w, // Port x reset bit y (y = 0..15) (u1)
            br12: Br0w, // Port x reset bit y (y = 0..15) (u1)
            br13: Br0w, // Port x reset bit y (y = 0..15) (u1)
            br14: Br0w, // Port x reset bit y (y = 0..15) (u1)
            br15: Br0w, // Port x reset bit y (y = 0..15) (u1)
        };
        pub const bsrr = mmio(base_address + 0x18, 32, Bsrr);

        /// address: 0x40020c1c
        /// GPIO port configuration lock register
        pub const Lckr = packed struct {
            pub const Lck0 = enum(u1) {
                unlocked = 0, // Port configuration not locked
                locked = 1, // Port configuration locked
            };
            pub const Lckk = enum(u1) {
                not_active = 0, // Port configuration lock key not active
                active = 1, // Port configuration lock key active
            };
            lck0: Lck0, // Port x lock bit y (y= 0..15) (u1)
            lck1: Lck0, // Port x lock bit y (y= 0..15) (u1)
            lck2: Lck0, // Port x lock bit y (y= 0..15) (u1)
            lck3: Lck0, // Port x lock bit y (y= 0..15) (u1)
            lck4: Lck0, // Port x lock bit y (y= 0..15) (u1)
            lck5: Lck0, // Port x lock bit y (y= 0..15) (u1)
            lck6: Lck0, // Port x lock bit y (y= 0..15) (u1)
            lck7: Lck0, // Port x lock bit y (y= 0..15) (u1)
            lck8: Lck0, // Port x lock bit y (y= 0..15) (u1)
            lck9: Lck0, // Port x lock bit y (y= 0..15) (u1)
            lck10: Lck0, // Port x lock bit y (y= 0..15) (u1)
            lck11: Lck0, // Port x lock bit y (y= 0..15) (u1)
            lck12: Lck0, // Port x lock bit y (y= 0..15) (u1)
            lck13: Lck0, // Port x lock bit y (y= 0..15) (u1)
            lck14: Lck0, // Port x lock bit y (y= 0..15) (u1)
            lck15: Lck0, // Port x lock bit y (y= 0..15) (u1)
            lckk: Lckk, // Port x lock bit y (y= 0..15) (u1)
            _padding_17_31: u15,
        };
        pub const lckr = mmio(base_address + 0x1c, 32, Lckr);

        /// address: 0x40020c20
        /// GPIO alternate function low register
        pub const Afrl = packed struct {
            pub const Afrl0 = enum(u4) {
                af0 = 0b0000, // AF0
                af1 = 0b0001, // AF1
                af2 = 0b0010, // AF2
                af3 = 0b0011, // AF3
                af4 = 0b0100, // AF4
                af5 = 0b0101, // AF5
                af6 = 0b0110, // AF6
                af7 = 0b0111, // AF7
                af8 = 0b1000, // AF8
                af9 = 0b1001, // AF9
                af10 = 0b1010, // AF10
                af11 = 0b1011, // AF11
                af12 = 0b1100, // AF12
                af13 = 0b1101, // AF13
                af14 = 0b1110, // AF14
                af15 = 0b1111, // AF15
            };
            afrl0: Afrl0, // Alternate function selection for port x bit y (y = 0..7) (u4)
            afrl1: Afrl0, // Alternate function selection for port x bit y (y = 0..7) (u4)
            afrl2: Afrl0, // Alternate function selection for port x bit y (y = 0..7) (u4)
            afrl3: Afrl0, // Alternate function selection for port x bit y (y = 0..7) (u4)
            afrl4: Afrl0, // Alternate function selection for port x bit y (y = 0..7) (u4)
            afrl5: Afrl0, // Alternate function selection for port x bit y (y = 0..7) (u4)
            afrl6: Afrl0, // Alternate function selection for port x bit y (y = 0..7) (u4)
            afrl7: Afrl0, // Alternate function selection for port x bit y (y = 0..7) (u4)
        };
        pub const afrl = mmio(base_address + 0x20, 32, Afrl);

        /// address: 0x40020c24
        /// GPIO alternate function high register
        pub const Afrh = packed struct {
            pub const Afrh8 = enum(u4) {
                af0 = 0b0000, // AF0
                af1 = 0b0001, // AF1
                af2 = 0b0010, // AF2
                af3 = 0b0011, // AF3
                af4 = 0b0100, // AF4
                af5 = 0b0101, // AF5
                af6 = 0b0110, // AF6
                af7 = 0b0111, // AF7
                af8 = 0b1000, // AF8
                af9 = 0b1001, // AF9
                af10 = 0b1010, // AF10
                af11 = 0b1011, // AF11
                af12 = 0b1100, // AF12
                af13 = 0b1101, // AF13
                af14 = 0b1110, // AF14
                af15 = 0b1111, // AF15
            };
            afrh8: Afrh8, // Alternate function selection for port x bit y (y = 8..15) (u4)
            afrh9: Afrh8, // Alternate function selection for port x bit y (y = 8..15) (u4)
            afrh10: Afrh8, // Alternate function selection for port x bit y (y = 8..15) (u4)
            afrh11: Afrh8, // Alternate function selection for port x bit y (y = 8..15) (u4)
            afrh12: Afrh8, // Alternate function selection for port x bit y (y = 8..15) (u4)
            afrh13: Afrh8, // Alternate function selection for port x bit y (y = 8..15) (u4)
            afrh14: Afrh8, // Alternate function selection for port x bit y (y = 8..15) (u4)
            afrh15: Afrh8, // Alternate function selection for port x bit y (y = 8..15) (u4)
        };
        pub const afrh = mmio(base_address + 0x24, 32, Afrh);
    };
    /// General-purpose I/Os
    pub const gpioc = struct {
        pub const base_address = 0x40020800;

        /// address: 0x40020800
        /// GPIO port mode register
        pub const Moder = packed struct {
            pub const Moder0 = enum(u2) {
                input = 0b00, // Input mode (reset state)
                output = 0b01, // General purpose output mode
                alternate = 0b10, // Alternate function mode
                analog = 0b11, // Analog mode
            };
            moder0: Moder0, // Port x configuration bits (y = 0..15) (u2)
            moder1: Moder0, // Port x configuration bits (y = 0..15) (u2)
            moder2: Moder0, // Port x configuration bits (y = 0..15) (u2)
            moder3: Moder0, // Port x configuration bits (y = 0..15) (u2)
            moder4: Moder0, // Port x configuration bits (y = 0..15) (u2)
            moder5: Moder0, // Port x configuration bits (y = 0..15) (u2)
            moder6: Moder0, // Port x configuration bits (y = 0..15) (u2)
            moder7: Moder0, // Port x configuration bits (y = 0..15) (u2)
            moder8: Moder0, // Port x configuration bits (y = 0..15) (u2)
            moder9: Moder0, // Port x configuration bits (y = 0..15) (u2)
            moder10: Moder0, // Port x configuration bits (y = 0..15) (u2)
            moder11: Moder0, // Port x configuration bits (y = 0..15) (u2)
            moder12: Moder0, // Port x configuration bits (y = 0..15) (u2)
            moder13: Moder0, // Port x configuration bits (y = 0..15) (u2)
            moder14: Moder0, // Port x configuration bits (y = 0..15) (u2)
            moder15: Moder0, // Port x configuration bits (y = 0..15) (u2)
        };
        pub const moder = mmio(base_address + 0x0, 32, Moder);

        /// address: 0x40020804
        /// GPIO port output type register
        pub const Otyper = packed struct {
            pub const Ot0 = enum(u1) {
                push_pull = 0, // Output push-pull (reset state)
                open_drain = 1, // Output open-drain
            };
            ot0: Ot0, // Port x configuration bits (y = 0..15) (u1)
            ot1: Ot0, // Port x configuration bits (y = 0..15) (u1)
            ot2: Ot0, // Port x configuration bits (y = 0..15) (u1)
            ot3: Ot0, // Port x configuration bits (y = 0..15) (u1)
            ot4: Ot0, // Port x configuration bits (y = 0..15) (u1)
            ot5: Ot0, // Port x configuration bits (y = 0..15) (u1)
            ot6: Ot0, // Port x configuration bits (y = 0..15) (u1)
            ot7: Ot0, // Port x configuration bits (y = 0..15) (u1)
            ot8: Ot0, // Port x configuration bits (y = 0..15) (u1)
            ot9: Ot0, // Port x configuration bits (y = 0..15) (u1)
            ot10: Ot0, // Port x configuration bits (y = 0..15) (u1)
            ot11: Ot0, // Port x configuration bits (y = 0..15) (u1)
            ot12: Ot0, // Port x configuration bits (y = 0..15) (u1)
            ot13: Ot0, // Port x configuration bits (y = 0..15) (u1)
            ot14: Ot0, // Port x configuration bits (y = 0..15) (u1)
            ot15: Ot0, // Port x configuration bits (y = 0..15) (u1)
            _padding_16_31: u16,
        };
        pub const otyper = mmio(base_address + 0x4, 32, Otyper);

        /// address: 0x40020808
        /// GPIO port output speed register
        pub const Ospeedr = packed struct {
            pub const Ospeedr0 = enum(u2) {
                low_speed = 0b00, // Low speed
                medium_speed = 0b01, // Medium speed
                high_speed = 0b10, // High speed
                very_high_speed = 0b11, // Very high speed
            };
            ospeedr0: Ospeedr0, // Port x configuration bits (y = 0..15) (u2)
            ospeedr1: Ospeedr0, // Port x configuration bits (y = 0..15) (u2)
            ospeedr2: Ospeedr0, // Port x configuration bits (y = 0..15) (u2)
            ospeedr3: Ospeedr0, // Port x configuration bits (y = 0..15) (u2)
            ospeedr4: Ospeedr0, // Port x configuration bits (y = 0..15) (u2)
            ospeedr5: Ospeedr0, // Port x configuration bits (y = 0..15) (u2)
            ospeedr6: Ospeedr0, // Port x configuration bits (y = 0..15) (u2)
            ospeedr7: Ospeedr0, // Port x configuration bits (y = 0..15) (u2)
            ospeedr8: Ospeedr0, // Port x configuration bits (y = 0..15) (u2)
            ospeedr9: Ospeedr0, // Port x configuration bits (y = 0..15) (u2)
            ospeedr10: Ospeedr0, // Port x configuration bits (y = 0..15) (u2)
            ospeedr11: Ospeedr0, // Port x configuration bits (y = 0..15) (u2)
            ospeedr12: Ospeedr0, // Port x configuration bits (y = 0..15) (u2)
            ospeedr13: Ospeedr0, // Port x configuration bits (y = 0..15) (u2)
            ospeedr14: Ospeedr0, // Port x configuration bits (y = 0..15) (u2)
            ospeedr15: Ospeedr0, // Port x configuration bits (y = 0..15) (u2)
        };
        pub const ospeedr = mmio(base_address + 0x8, 32, Ospeedr);

        /// address: 0x4002080c
        /// GPIO port pull-up/pull-down register
        pub const Pupdr = packed struct {
            pub const Pupdr0 = enum(u2) {
                floating = 0b00, // No pull-up, pull-down
                pull_up = 0b01, // Pull-up
                pull_down = 0b10, // Pull-down
            };
            pupdr0: Pupdr0, // Port x configuration bits (y = 0..15) (u2)
            pupdr1: Pupdr0, // Port x configuration bits (y = 0..15) (u2)
            pupdr2: Pupdr0, // Port x configuration bits (y = 0..15) (u2)
            pupdr3: Pupdr0, // Port x configuration bits (y = 0..15) (u2)
            pupdr4: Pupdr0, // Port x configuration bits (y = 0..15) (u2)
            pupdr5: Pupdr0, // Port x configuration bits (y = 0..15) (u2)
            pupdr6: Pupdr0, // Port x configuration bits (y = 0..15) (u2)
            pupdr7: Pupdr0, // Port x configuration bits (y = 0..15) (u2)
            pupdr8: Pupdr0, // Port x configuration bits (y = 0..15) (u2)
            pupdr9: Pupdr0, // Port x configuration bits (y = 0..15) (u2)
            pupdr10: Pupdr0, // Port x configuration bits (y = 0..15) (u2)
            pupdr11: Pupdr0, // Port x configuration bits (y = 0..15) (u2)
            pupdr12: Pupdr0, // Port x configuration bits (y = 0..15) (u2)
            pupdr13: Pupdr0, // Port x configuration bits (y = 0..15) (u2)
            pupdr14: Pupdr0, // Port x configuration bits (y = 0..15) (u2)
            pupdr15: Pupdr0, // Port x configuration bits (y = 0..15) (u2)
        };
        pub const pupdr = mmio(base_address + 0xc, 32, Pupdr);

        /// address: 0x40020810
        /// GPIO port input data register
        pub const Idr = packed struct {
            pub const Idr0 = enum(u1) {
                high = 1, // Input is logic high
                low = 0, // Input is logic low
            };
            idr0: Idr0, // Port input data (y = 0..15) (u1)
            idr1: Idr0, // Port input data (y = 0..15) (u1)
            idr2: Idr0, // Port input data (y = 0..15) (u1)
            idr3: Idr0, // Port input data (y = 0..15) (u1)
            idr4: Idr0, // Port input data (y = 0..15) (u1)
            idr5: Idr0, // Port input data (y = 0..15) (u1)
            idr6: Idr0, // Port input data (y = 0..15) (u1)
            idr7: Idr0, // Port input data (y = 0..15) (u1)
            idr8: Idr0, // Port input data (y = 0..15) (u1)
            idr9: Idr0, // Port input data (y = 0..15) (u1)
            idr10: Idr0, // Port input data (y = 0..15) (u1)
            idr11: Idr0, // Port input data (y = 0..15) (u1)
            idr12: Idr0, // Port input data (y = 0..15) (u1)
            idr13: Idr0, // Port input data (y = 0..15) (u1)
            idr14: Idr0, // Port input data (y = 0..15) (u1)
            idr15: Idr0, // Port input data (y = 0..15) (u1)
            _padding_16_31: u16,
        };
        pub const idr = mmio(base_address + 0x10, 32, Idr);

        /// address: 0x40020814
        /// GPIO port output data register
        pub const Odr = packed struct {
            pub const Odr0 = enum(u1) {
                high = 1, // Set output to logic high
                low = 0, // Set output to logic low
            };
            odr0: Odr0, // Port output data (y = 0..15) (u1)
            odr1: Odr0, // Port output data (y = 0..15) (u1)
            odr2: Odr0, // Port output data (y = 0..15) (u1)
            odr3: Odr0, // Port output data (y = 0..15) (u1)
            odr4: Odr0, // Port output data (y = 0..15) (u1)
            odr5: Odr0, // Port output data (y = 0..15) (u1)
            odr6: Odr0, // Port output data (y = 0..15) (u1)
            odr7: Odr0, // Port output data (y = 0..15) (u1)
            odr8: Odr0, // Port output data (y = 0..15) (u1)
            odr9: Odr0, // Port output data (y = 0..15) (u1)
            odr10: Odr0, // Port output data (y = 0..15) (u1)
            odr11: Odr0, // Port output data (y = 0..15) (u1)
            odr12: Odr0, // Port output data (y = 0..15) (u1)
            odr13: Odr0, // Port output data (y = 0..15) (u1)
            odr14: Odr0, // Port output data (y = 0..15) (u1)
            odr15: Odr0, // Port output data (y = 0..15) (u1)
            _padding_16_31: u16,
        };
        pub const odr = mmio(base_address + 0x14, 32, Odr);

        /// address: 0x40020818
        /// GPIO port bit set/reset register
        pub const Bsrr = packed struct {
            pub const Bs0w = enum(u1) {
                set = 1, // Sets the corresponding ODRx bit
            };
            pub const Br0w = enum(u1) {
                reset = 1, // Resets the corresponding ODRx bit
            };
            bs0: Bs0w, // Port x set bit y (y= 0..15) (u1)
            bs1: Bs0w, // Port x set bit y (y= 0..15) (u1)
            bs2: Bs0w, // Port x set bit y (y= 0..15) (u1)
            bs3: Bs0w, // Port x set bit y (y= 0..15) (u1)
            bs4: Bs0w, // Port x set bit y (y= 0..15) (u1)
            bs5: Bs0w, // Port x set bit y (y= 0..15) (u1)
            bs6: Bs0w, // Port x set bit y (y= 0..15) (u1)
            bs7: Bs0w, // Port x set bit y (y= 0..15) (u1)
            bs8: Bs0w, // Port x set bit y (y= 0..15) (u1)
            bs9: Bs0w, // Port x set bit y (y= 0..15) (u1)
            bs10: Bs0w, // Port x set bit y (y= 0..15) (u1)
            bs11: Bs0w, // Port x set bit y (y= 0..15) (u1)
            bs12: Bs0w, // Port x set bit y (y= 0..15) (u1)
            bs13: Bs0w, // Port x set bit y (y= 0..15) (u1)
            bs14: Bs0w, // Port x set bit y (y= 0..15) (u1)
            bs15: Bs0w, // Port x set bit y (y= 0..15) (u1)
            br0: Br0w, // Port x set bit y (y= 0..15) (u1)
            br1: Br0w, // Port x reset bit y (y = 0..15) (u1)
            br2: Br0w, // Port x reset bit y (y = 0..15) (u1)
            br3: Br0w, // Port x reset bit y (y = 0..15) (u1)
            br4: Br0w, // Port x reset bit y (y = 0..15) (u1)
            br5: Br0w, // Port x reset bit y (y = 0..15) (u1)
            br6: Br0w, // Port x reset bit y (y = 0..15) (u1)
            br7: Br0w, // Port x reset bit y (y = 0..15) (u1)
            br8: Br0w, // Port x reset bit y (y = 0..15) (u1)
            br9: Br0w, // Port x reset bit y (y = 0..15) (u1)
            br10: Br0w, // Port x reset bit y (y = 0..15) (u1)
            br11: Br0w, // Port x reset bit y (y = 0..15) (u1)
            br12: Br0w, // Port x reset bit y (y = 0..15) (u1)
            br13: Br0w, // Port x reset bit y (y = 0..15) (u1)
            br14: Br0w, // Port x reset bit y (y = 0..15) (u1)
            br15: Br0w, // Port x reset bit y (y = 0..15) (u1)
        };
        pub const bsrr = mmio(base_address + 0x18, 32, Bsrr);

        /// address: 0x4002081c
        /// GPIO port configuration lock register
        pub const Lckr = packed struct {
            pub const Lck0 = enum(u1) {
                unlocked = 0, // Port configuration not locked
                locked = 1, // Port configuration locked
            };
            pub const Lckk = enum(u1) {
                not_active = 0, // Port configuration lock key not active
                active = 1, // Port configuration lock key active
            };
            lck0: Lck0, // Port x lock bit y (y= 0..15) (u1)
            lck1: Lck0, // Port x lock bit y (y= 0..15) (u1)
            lck2: Lck0, // Port x lock bit y (y= 0..15) (u1)
            lck3: Lck0, // Port x lock bit y (y= 0..15) (u1)
            lck4: Lck0, // Port x lock bit y (y= 0..15) (u1)
            lck5: Lck0, // Port x lock bit y (y= 0..15) (u1)
            lck6: Lck0, // Port x lock bit y (y= 0..15) (u1)
            lck7: Lck0, // Port x lock bit y (y= 0..15) (u1)
            lck8: Lck0, // Port x lock bit y (y= 0..15) (u1)
            lck9: Lck0, // Port x lock bit y (y= 0..15) (u1)
            lck10: Lck0, // Port x lock bit y (y= 0..15) (u1)
            lck11: Lck0, // Port x lock bit y (y= 0..15) (u1)
            lck12: Lck0, // Port x lock bit y (y= 0..15) (u1)
            lck13: Lck0, // Port x lock bit y (y= 0..15) (u1)
            lck14: Lck0, // Port x lock bit y (y= 0..15) (u1)
            lck15: Lck0, // Port x lock bit y (y= 0..15) (u1)
            lckk: Lckk, // Port x lock bit y (y= 0..15) (u1)
            _padding_17_31: u15,
        };
        pub const lckr = mmio(base_address + 0x1c, 32, Lckr);

        /// address: 0x40020820
        /// GPIO alternate function low register
        pub const Afrl = packed struct {
            pub const Afrl0 = enum(u4) {
                af0 = 0b0000, // AF0
                af1 = 0b0001, // AF1
                af2 = 0b0010, // AF2
                af3 = 0b0011, // AF3
                af4 = 0b0100, // AF4
                af5 = 0b0101, // AF5
                af6 = 0b0110, // AF6
                af7 = 0b0111, // AF7
                af8 = 0b1000, // AF8
                af9 = 0b1001, // AF9
                af10 = 0b1010, // AF10
                af11 = 0b1011, // AF11
                af12 = 0b1100, // AF12
                af13 = 0b1101, // AF13
                af14 = 0b1110, // AF14
                af15 = 0b1111, // AF15
            };
            afrl0: Afrl0, // Alternate function selection for port x bit y (y = 0..7) (u4)
            afrl1: Afrl0, // Alternate function selection for port x bit y (y = 0..7) (u4)
            afrl2: Afrl0, // Alternate function selection for port x bit y (y = 0..7) (u4)
            afrl3: Afrl0, // Alternate function selection for port x bit y (y = 0..7) (u4)
            afrl4: Afrl0, // Alternate function selection for port x bit y (y = 0..7) (u4)
            afrl5: Afrl0, // Alternate function selection for port x bit y (y = 0..7) (u4)
            afrl6: Afrl0, // Alternate function selection for port x bit y (y = 0..7) (u4)
            afrl7: Afrl0, // Alternate function selection for port x bit y (y = 0..7) (u4)
        };
        pub const afrl = mmio(base_address + 0x20, 32, Afrl);

        /// address: 0x40020824
        /// GPIO alternate function high register
        pub const Afrh = packed struct {
            pub const Afrh8 = enum(u4) {
                af0 = 0b0000, // AF0
                af1 = 0b0001, // AF1
                af2 = 0b0010, // AF2
                af3 = 0b0011, // AF3
                af4 = 0b0100, // AF4
                af5 = 0b0101, // AF5
                af6 = 0b0110, // AF6
                af7 = 0b0111, // AF7
                af8 = 0b1000, // AF8
                af9 = 0b1001, // AF9
                af10 = 0b1010, // AF10
                af11 = 0b1011, // AF11
                af12 = 0b1100, // AF12
                af13 = 0b1101, // AF13
                af14 = 0b1110, // AF14
                af15 = 0b1111, // AF15
            };
            afrh8: Afrh8, // Alternate function selection for port x bit y (y = 8..15) (u4)
            afrh9: Afrh8, // Alternate function selection for port x bit y (y = 8..15) (u4)
            afrh10: Afrh8, // Alternate function selection for port x bit y (y = 8..15) (u4)
            afrh11: Afrh8, // Alternate function selection for port x bit y (y = 8..15) (u4)
            afrh12: Afrh8, // Alternate function selection for port x bit y (y = 8..15) (u4)
            afrh13: Afrh8, // Alternate function selection for port x bit y (y = 8..15) (u4)
            afrh14: Afrh8, // Alternate function selection for port x bit y (y = 8..15) (u4)
            afrh15: Afrh8, // Alternate function selection for port x bit y (y = 8..15) (u4)
        };
        pub const afrh = mmio(base_address + 0x24, 32, Afrh);
    };
    /// Inter-integrated circuit
    pub const i2c3 = struct {
        pub const base_address = 0x40005c00;

        /// address: 0x40005c00
        /// Control register 1
        pub const Cr1 = packed struct {
            pub const Pe = enum(u1) {
                disabled = 0, // Peripheral disabled
                enabled = 1, // Peripheral enabled
            };
            pub const Smbus = enum(u1) {
                i2_c = 0, // I2C Mode
                sm_bus = 1, // SMBus
            };
            pub const Smbtype = enum(u1) {
                device = 0, // SMBus Device
                host = 1, // SMBus Host
            };
            pub const Enarp = enum(u1) {
                disabled = 0, // ARP disabled
                enabled = 1, // ARP enabled
            };
            pub const Enpec = enum(u1) {
                disabled = 0, // PEC calculation disabled
                enabled = 1, // PEC calculation enabled
            };
            pub const Engc = enum(u1) {
                disabled = 0, // General call disabled
                enabled = 1, // General call enabled
            };
            pub const Nostretch = enum(u1) {
                enabled = 0, // Clock stretching enabled
                disabled = 1, // Clock stretching disabled
            };
            pub const Start = enum(u1) {
                no_start = 0, // No Start generation
                start = 1, // In master mode: repeated start generation, in slave mode: start generation when bus is free
            };
            pub const Stop = enum(u1) {
                no_stop = 0, // No Stop generation
                stop = 1, // In master mode: stop generation after current byte/start, in slave mode: release SCL and SDA after current byte
            };
            pub const Ack = enum(u1) {
                nak = 0, // No acknowledge returned
                ack = 1, // Acknowledge returned after a byte is received
            };
            pub const Pos = enum(u1) {
                current = 0, // ACK bit controls the (N)ACK of the current byte being received
                next = 1, // ACK bit controls the (N)ACK of the next byte to be received
            };
            pub const Pec = enum(u1) {
                disabled = 0, // No PEC transfer
                enabled = 1, // PEC transfer
            };
            pub const Alert = enum(u1) {
                release = 0, // SMBA pin released high
                drive = 1, // SMBA pin driven low
            };
            pub const Swrst = enum(u1) {
                not_reset = 0, // I2C peripheral not under reset
                reset = 1, // I2C peripheral under reset
            };
            pe: Pe, // Peripheral enable (u1)
            smbus: Smbus, // SMBus mode (u1)
            _reserved_2_2: u1,
            smbtype: Smbtype, // SMBus type (u1)
            enarp: Enarp, // ARP enable (u1)
            enpec: Enpec, // PEC enable (u1)
            engc: Engc, // General call enable (u1)
            nostretch: Nostretch, // Clock stretching disable (Slave mode) (u1)
            start: Start, // Start generation (u1)
            stop: Stop, // Stop generation (u1)
            ack: Ack, // Acknowledge enable (u1)
            pos: Pos, // Acknowledge/PEC Position (for data reception) (u1)
            pec: Pec, // Packet error checking (u1)
            alert: Alert, // SMBus alert (u1)
            _reserved_14_14: u1,
            swrst: Swrst, // Software reset (u1)
            _padding_16_31: u16,
        };
        pub const cr1 = mmio(base_address + 0x0, 32, Cr1);

        /// address: 0x40005c04
        /// Control register 2
        pub const Cr2 = packed struct {
            pub const Iterren = enum(u1) {
                disabled = 0, // Error interrupt disabled
                enabled = 1, // Error interrupt enabled
            };
            pub const Itevten = enum(u1) {
                disabled = 0, // Event interrupt disabled
                enabled = 1, // Event interrupt enabled
            };
            pub const Itbufen = enum(u1) {
                disabled = 0, // TxE=1 or RxNE=1 does not generate any interrupt
                enabled = 1, // TxE=1 or RxNE=1 generates Event interrupt
            };
            pub const Dmaen = enum(u1) {
                disabled = 0, // DMA requests disabled
                enabled = 1, // DMA request enabled when TxE=1 or RxNE=1
            };
            pub const Last = enum(u1) {
                not_last = 0, // Next DMA EOT is not the last transfer
                last = 1, // Next DMA EOT is the last transfer
            };
            freq: u6, // Peripheral clock frequency
            _reserved_6_7: u2,
            iterren: Iterren, // Error interrupt enable (u1)
            itevten: Itevten, // Event interrupt enable (u1)
            itbufen: Itbufen, // Buffer interrupt enable (u1)
            dmaen: Dmaen, // DMA requests enable (u1)
            last: Last, // DMA last transfer (u1)
            _padding_13_31: u19,
        };
        pub const cr2 = mmio(base_address + 0x4, 32, Cr2);

        /// address: 0x40005c08
        /// Own address register 1
        pub const Oar1 = packed struct {
            pub const Addmode = enum(u1) {
                add7 = 0, // 7-bit slave address
                add10 = 1, // 10-bit slave address
            };
            add: u10, // Interface address
            _reserved_10_14: u5,
            addmode: Addmode, // Addressing mode (slave mode) (u1)
            _padding_16_31: u16,
        };
        pub const oar1 = mmio(base_address + 0x8, 32, Oar1);

        /// address: 0x40005c0c
        /// Own address register 2
        pub const Oar2 = packed struct {
            pub const Endual = enum(u1) {
                single = 0, // Single addressing mode
                dual = 1, // Dual addressing mode
            };
            endual: Endual, // Dual addressing mode enable (u1)
            add2: u7, // Interface address
            _padding_8_31: u24,
        };
        pub const oar2 = mmio(base_address + 0xc, 32, Oar2);

        /// address: 0x40005c10
        /// Data register
        pub const dr = mmioInt(base_address + 0x10, 32, u8);

        /// address: 0x40005c14
        /// Status register 1
        pub const Sr1 = packed struct {
            pub const Sb = enum(u1) {
                no_start = 0, // No Start condition
                start = 1, // Start condition generated
            };
            pub const Addr = enum(u1) {
                not_match = 0, // Adress mismatched or not received
                match = 1, // Received slave address matched with one of the enabled slave addresses
            };
            pub const Btf = enum(u1) {
                not_finished = 0, // Data byte transfer not done
                finished = 1, // Data byte transfer successful
            };
            pub const Stopf = enum(u1) {
                no_stop = 0, // No Stop condition detected
                stop = 1, // Stop condition detected
            };
            pub const Rxne = enum(u1) {
                empty = 0, // Data register empty
                not_empty = 1, // Data register not empty
            };
            pub const Txe = enum(u1) {
                not_empty = 0, // Data register not empty
                empty = 1, // Data register empty
            };
            pub const Berr = enum(u1) {
                no_error = 0, // No misplaced Start or Stop condition
                @"error" = 1, // Misplaced Start or Stop condition
            };
            pub const Arlo = enum(u1) {
                no_lost = 0, // No Arbitration Lost detected
                lost = 1, // Arbitration Lost detected
            };
            pub const Af = enum(u1) {
                no_failure = 0, // No acknowledge failure
                failure = 1, // Acknowledge failure
            };
            pub const Ovr = enum(u1) {
                no_overrun = 0, // No overrun/underrun occured
                overrun = 1, // Overrun/underrun occured
            };
            pub const Pecerr = enum(u1) {
                no_error = 0, // no PEC error: receiver returns ACK after PEC reception (if ACK=1)
                @"error" = 1, // PEC error: receiver returns NACK after PEC reception (whatever ACK)
            };
            pub const Timeout = enum(u1) {
                no_timeout = 0, // No Timeout error
                timeout = 1, // SCL remained LOW for 25 ms
            };
            pub const Smbalert = enum(u1) {
                no_alert = 0, // No SMBALERT occured
                alert = 1, // SMBALERT occurred
            };
            sb: Sb, // Start bit (Master mode) (u1)
            addr: Addr, // Address sent (master mode)/matched (slave mode) (u1)
            btf: Btf, // Byte transfer finished (u1)
            add10: u1, // 10-bit header sent (Master mode)
            stopf: Stopf, // Stop detection (slave mode) (u1)
            _reserved_5_5: u1,
            rxne: Rxne, // Data register not empty (receivers) (u1)
            txe: Txe, // Data register empty (transmitters) (u1)
            berr: Berr, // Bus error (u1)
            arlo: Arlo, // Arbitration lost (master mode) (u1)
            af: Af, // Acknowledge failure (u1)
            ovr: Ovr, // Overrun/Underrun (u1)
            pecerr: Pecerr, // PEC Error in reception (u1)
            _reserved_13_13: u1,
            timeout: Timeout, // Timeout or Tlow error (u1)
            smbalert: Smbalert, // SMBus alert (u1)
            _padding_16_31: u16,
        };
        pub const sr1 = mmio(base_address + 0x14, 32, Sr1);

        /// address: 0x40005c18
        /// Status register 2
        pub const Sr2 = packed struct {
            msl: u1, // Master/slave
            busy: u1, // Bus busy
            tra: u1, // Transmitter/receiver
            _reserved_3_3: u1,
            gencall: u1, // General call address (Slave mode)
            smbdefault: u1, // SMBus device default address (Slave mode)
            smbhost: u1, // SMBus host header (Slave mode)
            dualf: u1, // Dual flag (Slave mode)
            pec: u8, // acket error checking register
            _padding_16_31: u16,
        };
        pub const sr2 = mmio(base_address + 0x18, 32, Sr2);

        /// address: 0x40005c1c
        /// Clock control register
        pub const Ccr = packed struct {
            pub const Duty = enum(u1) {
                duty2_1 = 0, // Duty cycle t_low/t_high = 2/1
                duty16_9 = 1, // Duty cycle t_low/t_high = 16/9
            };
            pub const FS = enum(u1) {
                standard = 0, // Standard mode I2C
                fast = 1, // Fast mode I2C
            };
            ccr: u12, // Clock control register in Fast/Standard mode (Master mode)
            _reserved_12_13: u2,
            duty: Duty, // Fast mode duty cycle (u1)
            f_s: FS, // I2C master mode selection (u1)
            _padding_16_31: u16,
        };
        pub const ccr = mmio(base_address + 0x1c, 32, Ccr);

        /// address: 0x40005c20
        /// TRISE register
        pub const trise = mmioInt(base_address + 0x20, 32, u6);

        /// address: 0x40005c24
        /// FLTR register
        pub const Fltr = packed struct {
            pub const Dnf = enum(u4) {
                no_filter = 0b0000, // Digital filter disabled
                filter1 = 0b0001, // Digital filter enabled and filtering capability up to 1 tI2CCLK
                filter2 = 0b0010, // Digital filter enabled and filtering capability up to 2 tI2CCLK
                filter3 = 0b0011, // Digital filter enabled and filtering capability up to 3 tI2CCLK
                filter4 = 0b0100, // Digital filter enabled and filtering capability up to 4 tI2CCLK
                filter5 = 0b0101, // Digital filter enabled and filtering capability up to 5 tI2CCLK
                filter6 = 0b0110, // Digital filter enabled and filtering capability up to 6 tI2CCLK
                filter7 = 0b0111, // Digital filter enabled and filtering capability up to 7 tI2CCLK
                filter8 = 0b1000, // Digital filter enabled and filtering capability up to 8 tI2CCLK
                filter9 = 0b1001, // Digital filter enabled and filtering capability up to 9 tI2CCLK
                filter10 = 0b1010, // Digital filter enabled and filtering capability up to 10 tI2CCLK
                filter11 = 0b1011, // Digital filter enabled and filtering capability up to 11 tI2CCLK
                filter12 = 0b1100, // Digital filter enabled and filtering capability up to 12 tI2CCLK
                filter13 = 0b1101, // Digital filter enabled and filtering capability up to 13 tI2CCLK
                filter14 = 0b1110, // Digital filter enabled and filtering capability up to 14 tI2CCLK
                filter15 = 0b1111, // Digital filter enabled and filtering capability up to 15 tI2CCLK
            };
            pub const Anoff = enum(u1) {
                enabled = 0, // Analog noise filter enabled
                disabled = 1, // Analog noise filter disabled
            };
            dnf: Dnf, // Digital noise filter (u4)
            anoff: Anoff, // Analog noise filter (u1)
            _padding_5_31: u27,
        };
        pub const fltr = mmio(base_address + 36, 32, Fltr);
    };
    /// Inter-integrated circuit
    pub const i2c2 = struct {
        pub const base_address = 0x40005800;

        /// address: 0x40005800
        /// Control register 1
        pub const Cr1 = packed struct {
            pub const Pe = enum(u1) {
                disabled = 0, // Peripheral disabled
                enabled = 1, // Peripheral enabled
            };
            pub const Smbus = enum(u1) {
                i2_c = 0, // I2C Mode
                sm_bus = 1, // SMBus
            };
            pub const Smbtype = enum(u1) {
                device = 0, // SMBus Device
                host = 1, // SMBus Host
            };
            pub const Enarp = enum(u1) {
                disabled = 0, // ARP disabled
                enabled = 1, // ARP enabled
            };
            pub const Enpec = enum(u1) {
                disabled = 0, // PEC calculation disabled
                enabled = 1, // PEC calculation enabled
            };
            pub const Engc = enum(u1) {
                disabled = 0, // General call disabled
                enabled = 1, // General call enabled
            };
            pub const Nostretch = enum(u1) {
                enabled = 0, // Clock stretching enabled
                disabled = 1, // Clock stretching disabled
            };
            pub const Start = enum(u1) {
                no_start = 0, // No Start generation
                start = 1, // In master mode: repeated start generation, in slave mode: start generation when bus is free
            };
            pub const Stop = enum(u1) {
                no_stop = 0, // No Stop generation
                stop = 1, // In master mode: stop generation after current byte/start, in slave mode: release SCL and SDA after current byte
            };
            pub const Ack = enum(u1) {
                nak = 0, // No acknowledge returned
                ack = 1, // Acknowledge returned after a byte is received
            };
            pub const Pos = enum(u1) {
                current = 0, // ACK bit controls the (N)ACK of the current byte being received
                next = 1, // ACK bit controls the (N)ACK of the next byte to be received
            };
            pub const Pec = enum(u1) {
                disabled = 0, // No PEC transfer
                enabled = 1, // PEC transfer
            };
            pub const Alert = enum(u1) {
                release = 0, // SMBA pin released high
                drive = 1, // SMBA pin driven low
            };
            pub const Swrst = enum(u1) {
                not_reset = 0, // I2C peripheral not under reset
                reset = 1, // I2C peripheral under reset
            };
            pe: Pe, // Peripheral enable (u1)
            smbus: Smbus, // SMBus mode (u1)
            _reserved_2_2: u1,
            smbtype: Smbtype, // SMBus type (u1)
            enarp: Enarp, // ARP enable (u1)
            enpec: Enpec, // PEC enable (u1)
            engc: Engc, // General call enable (u1)
            nostretch: Nostretch, // Clock stretching disable (Slave mode) (u1)
            start: Start, // Start generation (u1)
            stop: Stop, // Stop generation (u1)
            ack: Ack, // Acknowledge enable (u1)
            pos: Pos, // Acknowledge/PEC Position (for data reception) (u1)
            pec: Pec, // Packet error checking (u1)
            alert: Alert, // SMBus alert (u1)
            _reserved_14_14: u1,
            swrst: Swrst, // Software reset (u1)
            _padding_16_31: u16,
        };
        pub const cr1 = mmio(base_address + 0x0, 32, Cr1);

        /// address: 0x40005804
        /// Control register 2
        pub const Cr2 = packed struct {
            pub const Iterren = enum(u1) {
                disabled = 0, // Error interrupt disabled
                enabled = 1, // Error interrupt enabled
            };
            pub const Itevten = enum(u1) {
                disabled = 0, // Event interrupt disabled
                enabled = 1, // Event interrupt enabled
            };
            pub const Itbufen = enum(u1) {
                disabled = 0, // TxE=1 or RxNE=1 does not generate any interrupt
                enabled = 1, // TxE=1 or RxNE=1 generates Event interrupt
            };
            pub const Dmaen = enum(u1) {
                disabled = 0, // DMA requests disabled
                enabled = 1, // DMA request enabled when TxE=1 or RxNE=1
            };
            pub const Last = enum(u1) {
                not_last = 0, // Next DMA EOT is not the last transfer
                last = 1, // Next DMA EOT is the last transfer
            };
            freq: u6, // Peripheral clock frequency
            _reserved_6_7: u2,
            iterren: Iterren, // Error interrupt enable (u1)
            itevten: Itevten, // Event interrupt enable (u1)
            itbufen: Itbufen, // Buffer interrupt enable (u1)
            dmaen: Dmaen, // DMA requests enable (u1)
            last: Last, // DMA last transfer (u1)
            _padding_13_31: u19,
        };
        pub const cr2 = mmio(base_address + 0x4, 32, Cr2);

        /// address: 0x40005808
        /// Own address register 1
        pub const Oar1 = packed struct {
            pub const Addmode = enum(u1) {
                add7 = 0, // 7-bit slave address
                add10 = 1, // 10-bit slave address
            };
            add: u10, // Interface address
            _reserved_10_14: u5,
            addmode: Addmode, // Addressing mode (slave mode) (u1)
            _padding_16_31: u16,
        };
        pub const oar1 = mmio(base_address + 0x8, 32, Oar1);

        /// address: 0x4000580c
        /// Own address register 2
        pub const Oar2 = packed struct {
            pub const Endual = enum(u1) {
                single = 0, // Single addressing mode
                dual = 1, // Dual addressing mode
            };
            endual: Endual, // Dual addressing mode enable (u1)
            add2: u7, // Interface address
            _padding_8_31: u24,
        };
        pub const oar2 = mmio(base_address + 0xc, 32, Oar2);

        /// address: 0x40005810
        /// Data register
        pub const dr = mmioInt(base_address + 0x10, 32, u8);

        /// address: 0x40005814
        /// Status register 1
        pub const Sr1 = packed struct {
            pub const Sb = enum(u1) {
                no_start = 0, // No Start condition
                start = 1, // Start condition generated
            };
            pub const Addr = enum(u1) {
                not_match = 0, // Adress mismatched or not received
                match = 1, // Received slave address matched with one of the enabled slave addresses
            };
            pub const Btf = enum(u1) {
                not_finished = 0, // Data byte transfer not done
                finished = 1, // Data byte transfer successful
            };
            pub const Stopf = enum(u1) {
                no_stop = 0, // No Stop condition detected
                stop = 1, // Stop condition detected
            };
            pub const Rxne = enum(u1) {
                empty = 0, // Data register empty
                not_empty = 1, // Data register not empty
            };
            pub const Txe = enum(u1) {
                not_empty = 0, // Data register not empty
                empty = 1, // Data register empty
            };
            pub const Berr = enum(u1) {
                no_error = 0, // No misplaced Start or Stop condition
                @"error" = 1, // Misplaced Start or Stop condition
            };
            pub const Arlo = enum(u1) {
                no_lost = 0, // No Arbitration Lost detected
                lost = 1, // Arbitration Lost detected
            };
            pub const Af = enum(u1) {
                no_failure = 0, // No acknowledge failure
                failure = 1, // Acknowledge failure
            };
            pub const Ovr = enum(u1) {
                no_overrun = 0, // No overrun/underrun occured
                overrun = 1, // Overrun/underrun occured
            };
            pub const Pecerr = enum(u1) {
                no_error = 0, // no PEC error: receiver returns ACK after PEC reception (if ACK=1)
                @"error" = 1, // PEC error: receiver returns NACK after PEC reception (whatever ACK)
            };
            pub const Timeout = enum(u1) {
                no_timeout = 0, // No Timeout error
                timeout = 1, // SCL remained LOW for 25 ms
            };
            pub const Smbalert = enum(u1) {
                no_alert = 0, // No SMBALERT occured
                alert = 1, // SMBALERT occurred
            };
            sb: Sb, // Start bit (Master mode) (u1)
            addr: Addr, // Address sent (master mode)/matched (slave mode) (u1)
            btf: Btf, // Byte transfer finished (u1)
            add10: u1, // 10-bit header sent (Master mode)
            stopf: Stopf, // Stop detection (slave mode) (u1)
            _reserved_5_5: u1,
            rxne: Rxne, // Data register not empty (receivers) (u1)
            txe: Txe, // Data register empty (transmitters) (u1)
            berr: Berr, // Bus error (u1)
            arlo: Arlo, // Arbitration lost (master mode) (u1)
            af: Af, // Acknowledge failure (u1)
            ovr: Ovr, // Overrun/Underrun (u1)
            pecerr: Pecerr, // PEC Error in reception (u1)
            _reserved_13_13: u1,
            timeout: Timeout, // Timeout or Tlow error (u1)
            smbalert: Smbalert, // SMBus alert (u1)
            _padding_16_31: u16,
        };
        pub const sr1 = mmio(base_address + 0x14, 32, Sr1);

        /// address: 0x40005818
        /// Status register 2
        pub const Sr2 = packed struct {
            msl: u1, // Master/slave
            busy: u1, // Bus busy
            tra: u1, // Transmitter/receiver
            _reserved_3_3: u1,
            gencall: u1, // General call address (Slave mode)
            smbdefault: u1, // SMBus device default address (Slave mode)
            smbhost: u1, // SMBus host header (Slave mode)
            dualf: u1, // Dual flag (Slave mode)
            pec: u8, // acket error checking register
            _padding_16_31: u16,
        };
        pub const sr2 = mmio(base_address + 0x18, 32, Sr2);

        /// address: 0x4000581c
        /// Clock control register
        pub const Ccr = packed struct {
            pub const Duty = enum(u1) {
                duty2_1 = 0, // Duty cycle t_low/t_high = 2/1
                duty16_9 = 1, // Duty cycle t_low/t_high = 16/9
            };
            pub const FS = enum(u1) {
                standard = 0, // Standard mode I2C
                fast = 1, // Fast mode I2C
            };
            ccr: u12, // Clock control register in Fast/Standard mode (Master mode)
            _reserved_12_13: u2,
            duty: Duty, // Fast mode duty cycle (u1)
            f_s: FS, // I2C master mode selection (u1)
            _padding_16_31: u16,
        };
        pub const ccr = mmio(base_address + 0x1c, 32, Ccr);

        /// address: 0x40005820
        /// TRISE register
        pub const trise = mmioInt(base_address + 0x20, 32, u6);

        /// address: 0x40005824
        /// FLTR register
        pub const Fltr = packed struct {
            pub const Dnf = enum(u4) {
                no_filter = 0b0000, // Digital filter disabled
                filter1 = 0b0001, // Digital filter enabled and filtering capability up to 1 tI2CCLK
                filter2 = 0b0010, // Digital filter enabled and filtering capability up to 2 tI2CCLK
                filter3 = 0b0011, // Digital filter enabled and filtering capability up to 3 tI2CCLK
                filter4 = 0b0100, // Digital filter enabled and filtering capability up to 4 tI2CCLK
                filter5 = 0b0101, // Digital filter enabled and filtering capability up to 5 tI2CCLK
                filter6 = 0b0110, // Digital filter enabled and filtering capability up to 6 tI2CCLK
                filter7 = 0b0111, // Digital filter enabled and filtering capability up to 7 tI2CCLK
                filter8 = 0b1000, // Digital filter enabled and filtering capability up to 8 tI2CCLK
                filter9 = 0b1001, // Digital filter enabled and filtering capability up to 9 tI2CCLK
                filter10 = 0b1010, // Digital filter enabled and filtering capability up to 10 tI2CCLK
                filter11 = 0b1011, // Digital filter enabled and filtering capability up to 11 tI2CCLK
                filter12 = 0b1100, // Digital filter enabled and filtering capability up to 12 tI2CCLK
                filter13 = 0b1101, // Digital filter enabled and filtering capability up to 13 tI2CCLK
                filter14 = 0b1110, // Digital filter enabled and filtering capability up to 14 tI2CCLK
                filter15 = 0b1111, // Digital filter enabled and filtering capability up to 15 tI2CCLK
            };
            pub const Anoff = enum(u1) {
                enabled = 0, // Analog noise filter enabled
                disabled = 1, // Analog noise filter disabled
            };
            dnf: Dnf, // Digital noise filter (u4)
            anoff: Anoff, // Analog noise filter (u1)
            _padding_5_31: u27,
        };
        pub const fltr = mmio(base_address + 36, 32, Fltr);
    };
    /// Serial peripheral interface
    pub const i2s2ext = struct {
        pub const base_address = 0x40003400;

        /// address: 0x40003400
        /// control register 1
        pub const Cr1 = packed struct {
            pub const Cpha = enum(u1) {
                first_edge = 0, // The first clock transition is the first data capture edge
                second_edge = 1, // The second clock transition is the first data capture edge
            };
            pub const Cpol = enum(u1) {
                idle_low = 0, // CK to 0 when idle
                idle_high = 1, // CK to 1 when idle
            };
            pub const Mstr = enum(u1) {
                slave = 0, // Slave configuration
                master = 1, // Master configuration
            };
            pub const Br = enum(u3) {
                div2 = 0b000, // f_PCLK / 2
                div4 = 0b001, // f_PCLK / 4
                div8 = 0b010, // f_PCLK / 8
                div16 = 0b011, // f_PCLK / 16
                div32 = 0b100, // f_PCLK / 32
                div64 = 0b101, // f_PCLK / 64
                div128 = 0b110, // f_PCLK / 128
                div256 = 0b111, // f_PCLK / 256
            };
            pub const Spe = enum(u1) {
                disabled = 0, // Peripheral disabled
                enabled = 1, // Peripheral enabled
            };
            pub const Lsbfirst = enum(u1) {
                msb_first = 0, // Data is transmitted/received with the MSB first
                lsb_first = 1, // Data is transmitted/received with the LSB first
            };
            pub const Ssi = enum(u1) {
                slave_selected = 0, // 0 is forced onto the NSS pin and the I/O value of the NSS pin is ignored
                slave_not_selected = 1, // 1 is forced onto the NSS pin and the I/O value of the NSS pin is ignored
            };
            pub const Ssm = enum(u1) {
                disabled = 0, // Software slave management disabled
                enabled = 1, // Software slave management enabled
            };
            pub const Rxonly = enum(u1) {
                full_duplex = 0, // Full duplex (Transmit and receive)
                output_disabled = 1, // Output disabled (Receive-only mode)
            };
            pub const Dff = enum(u1) {
                eight_bit = 0, // 8-bit data frame format is selected for transmission/reception
                sixteen_bit = 1, // 16-bit data frame format is selected for transmission/reception
            };
            pub const Crcnext = enum(u1) {
                tx_buffer = 0, // Next transmit value is from Tx buffer
                crc = 1, // Next transmit value is from Tx CRC register
            };
            pub const Crcen = enum(u1) {
                disabled = 0, // CRC calculation disabled
                enabled = 1, // CRC calculation enabled
            };
            pub const Bidioe = enum(u1) {
                output_disabled = 0, // Output disabled (receive-only mode)
                output_enabled = 1, // Output enabled (transmit-only mode)
            };
            pub const Bidimode = enum(u1) {
                unidirectional = 0, // 2-line unidirectional data mode selected
                bidirectional = 1, // 1-line bidirectional data mode selected
            };
            cpha: Cpha, // Clock phase (u1)
            cpol: Cpol, // Clock polarity (u1)
            mstr: Mstr, // Master selection (u1)
            br: Br, // Baud rate control (u3)
            spe: Spe, // SPI enable (u1)
            lsbfirst: Lsbfirst, // Frame format (u1)
            ssi: Ssi, // Internal slave select (u1)
            ssm: Ssm, // Software slave management (u1)
            rxonly: Rxonly, // Receive only (u1)
            dff: Dff, // Data frame format (u1)
            crcnext: Crcnext, // CRC transfer next (u1)
            crcen: Crcen, // Hardware CRC calculation enable (u1)
            bidioe: Bidioe, // Output enable in bidirectional mode (u1)
            bidimode: Bidimode, // Bidirectional data mode enable (u1)
            _padding_16_31: u16,
        };
        pub const cr1 = mmio(base_address + 0x0, 32, Cr1);

        /// address: 0x40003404
        /// control register 2
        pub const Cr2 = packed struct {
            pub const Rxdmaen = enum(u1) {
                disabled = 0, // Rx buffer DMA disabled
                enabled = 1, // Rx buffer DMA enabled
            };
            pub const Txdmaen = enum(u1) {
                disabled = 0, // Tx buffer DMA disabled
                enabled = 1, // Tx buffer DMA enabled
            };
            pub const Ssoe = enum(u1) {
                disabled = 0, // SS output is disabled in master mode
                enabled = 1, // SS output is enabled in master mode
            };
            pub const Frf = enum(u1) {
                motorola = 0, // SPI Motorola mode
                ti = 1, // SPI TI mode
            };
            pub const Errie = enum(u1) {
                masked = 0, // Error interrupt masked
                not_masked = 1, // Error interrupt not masked
            };
            pub const Rxneie = enum(u1) {
                masked = 0, // RXE interrupt masked
                not_masked = 1, // RXE interrupt not masked
            };
            pub const Txeie = enum(u1) {
                masked = 0, // TXE interrupt masked
                not_masked = 1, // TXE interrupt not masked
            };
            rxdmaen: Rxdmaen, // Rx buffer DMA enable (u1)
            txdmaen: Txdmaen, // Tx buffer DMA enable (u1)
            ssoe: Ssoe, // SS output enable (u1)
            _reserved_3_3: u1,
            frf: Frf, // Frame format (u1)
            errie: Errie, // Error interrupt enable (u1)
            rxneie: Rxneie, // RX buffer not empty interrupt enable (u1)
            txeie: Txeie, // Tx buffer empty interrupt enable (u1)
            _padding_8_31: u24,
        };
        pub const cr2 = mmio(base_address + 0x4, 32, Cr2);

        /// address: 0x40003408
        /// status register
        pub const Sr = packed struct {
            pub const Rxne = enum(u1) {
                empty = 0, // Rx buffer empty
                not_empty = 1, // Rx buffer not empty
            };
            pub const Txe = enum(u1) {
                not_empty = 0, // Tx buffer not empty
                empty = 1, // Tx buffer empty
            };
            pub const Chside = enum(u1) {
                left = 0, // Channel left has to be transmitted or has been received
                right = 1, // Channel right has to be transmitted or has been received
            };
            pub const Udrr = enum(u1) {
                no_underrun = 0, // No underrun occurred
                underrun = 1, // Underrun occurred
            };
            pub const Crcerr = enum(u1) {
                match = 0, // CRC value received matches the SPIx_RXCRCR value
                no_match = 1, // CRC value received does not match the SPIx_RXCRCR value
            };
            pub const Modfr = enum(u1) {
                no_fault = 0, // No mode fault occurred
                fault = 1, // Mode fault occurred
            };
            pub const Ovrr = enum(u1) {
                no_overrun = 0, // No overrun occurred
                overrun = 1, // Overrun occurred
            };
            pub const Bsyr = enum(u1) {
                not_busy = 0, // SPI not busy
                busy = 1, // SPI busy
            };
            pub const Frer = enum(u1) {
                no_error = 0, // No frame format error
                @"error" = 1, // A frame format error occurred
            };
            rxne: Rxne, // Receive buffer not empty (u1)
            txe: Txe, // Transmit buffer empty (u1)
            chside: Chside, // Channel side (u1)
            udr: Udrr, // Underrun flag (u1)
            crcerr: Crcerr, // CRC error flag (u1)
            modf: Modfr, // Mode fault (u1)
            ovr: Ovrr, // Overrun flag (u1)
            bsy: Bsyr, // Busy flag (u1)
            fre: Frer, // TI frame format error (u1)
            _padding_9_31: u23,
        };
        pub const sr = mmio(base_address + 0x8, 32, Sr);

        /// address: 0x4000340c
        /// data register
        pub const dr = mmioInt(base_address + 0xc, 32, u16);

        /// address: 0x40003410
        /// CRC polynomial register
        pub const Crcpr = packed struct {
            crcpoly: u16, // CRC polynomial register
            _padding_16_31: u16,
        };
        pub const crcpr = mmio(base_address + 0x10, 32, Crcpr);

        /// address: 0x40003414
        /// RX CRC register
        pub const Rxcrcr = packed struct {
            rxcrc: u16, // Rx CRC register
            _padding_16_31: u16,
        };
        pub const rxcrcr = mmio(base_address + 0x14, 32, Rxcrcr);

        /// address: 0x40003418
        /// TX CRC register
        pub const Txcrcr = packed struct {
            txcrc: u16, // Tx CRC register
            _padding_16_31: u16,
        };
        pub const txcrcr = mmio(base_address + 0x18, 32, Txcrcr);

        /// address: 0x4000341c
        /// I2S configuration register
        pub const I2scfgr = packed struct {
            pub const Chlen = enum(u1) {
                sixteen_bit = 0, // 16-bit wide
                thirty_two_bit = 1, // 32-bit wide
            };
            pub const Datlen = enum(u2) {
                sixteen_bit = 0b00, // 16-bit data length
                twenty_four_bit = 0b01, // 24-bit data length
                thirty_two_bit = 0b10, // 32-bit data length
            };
            pub const Ckpol = enum(u1) {
                idle_low = 0, // I2S clock inactive state is low level
                idle_high = 1, // I2S clock inactive state is high level
            };
            pub const I2sstd = enum(u2) {
                philips = 0b00, // I2S Philips standard
                msb = 0b01, // MSB justified standard
                lsb = 0b10, // LSB justified standard
                pcm = 0b11, // PCM standard
            };
            pub const Pcmsync = enum(u1) {
                short = 0, // Short frame synchronisation
                long = 1, // Long frame synchronisation
            };
            pub const I2scfg = enum(u2) {
                slave_tx = 0b00, // Slave - transmit
                slave_rx = 0b01, // Slave - receive
                master_tx = 0b10, // Master - transmit
                master_rx = 0b11, // Master - receive
            };
            pub const I2se = enum(u1) {
                disabled = 0, // I2S peripheral is disabled
                enabled = 1, // I2S peripheral is enabled
            };
            pub const I2smod = enum(u1) {
                spi_mode = 0, // SPI mode is selected
                i2_s_mode = 1, // I2S mode is selected
            };
            chlen: Chlen, // Channel length (number of bits per audio channel) (u1)
            datlen: Datlen, // Data length to be transferred (u2)
            ckpol: Ckpol, // Steady state clock polarity (u1)
            i2sstd: I2sstd, // I2S standard selection (u2)
            _reserved_6_6: u1,
            pcmsync: Pcmsync, // PCM frame synchronization (u1)
            i2scfg: I2scfg, // I2S configuration mode (u2)
            i2se: I2se, // I2S Enable (u1)
            i2smod: I2smod, // I2S mode selection (u1)
            _padding_12_31: u20,
        };
        pub const i2scfgr = mmio(base_address + 0x1c, 32, I2scfgr);

        /// address: 0x40003420
        /// I2S prescaler register
        pub const I2spr = packed struct {
            pub const Odd = enum(u1) {
                even = 0, // Real divider value is I2SDIV * 2
                odd = 1, // Real divider value is (I2SDIV * 2) + 1
            };
            pub const Mckoe = enum(u1) {
                disabled = 0, // Master clock output is disabled
                enabled = 1, // Master clock output is enabled
            };
            i2sdiv: u8, // I2S Linear prescaler
            odd: Odd, // Odd factor for the prescaler (u1)
            mckoe: Mckoe, // Master clock output enable (u1)
            _padding_10_31: u22,
        };
        pub const i2spr = mmio(base_address + 0x20, 32, I2spr);
    };
    /// Serial peripheral interface
    pub const i2s3ext = struct {
        pub const base_address = 0x40004000;

        /// address: 0x40004000
        /// control register 1
        pub const Cr1 = packed struct {
            pub const Cpha = enum(u1) {
                first_edge = 0, // The first clock transition is the first data capture edge
                second_edge = 1, // The second clock transition is the first data capture edge
            };
            pub const Cpol = enum(u1) {
                idle_low = 0, // CK to 0 when idle
                idle_high = 1, // CK to 1 when idle
            };
            pub const Mstr = enum(u1) {
                slave = 0, // Slave configuration
                master = 1, // Master configuration
            };
            pub const Br = enum(u3) {
                div2 = 0b000, // f_PCLK / 2
                div4 = 0b001, // f_PCLK / 4
                div8 = 0b010, // f_PCLK / 8
                div16 = 0b011, // f_PCLK / 16
                div32 = 0b100, // f_PCLK / 32
                div64 = 0b101, // f_PCLK / 64
                div128 = 0b110, // f_PCLK / 128
                div256 = 0b111, // f_PCLK / 256
            };
            pub const Spe = enum(u1) {
                disabled = 0, // Peripheral disabled
                enabled = 1, // Peripheral enabled
            };
            pub const Lsbfirst = enum(u1) {
                msb_first = 0, // Data is transmitted/received with the MSB first
                lsb_first = 1, // Data is transmitted/received with the LSB first
            };
            pub const Ssi = enum(u1) {
                slave_selected = 0, // 0 is forced onto the NSS pin and the I/O value of the NSS pin is ignored
                slave_not_selected = 1, // 1 is forced onto the NSS pin and the I/O value of the NSS pin is ignored
            };
            pub const Ssm = enum(u1) {
                disabled = 0, // Software slave management disabled
                enabled = 1, // Software slave management enabled
            };
            pub const Rxonly = enum(u1) {
                full_duplex = 0, // Full duplex (Transmit and receive)
                output_disabled = 1, // Output disabled (Receive-only mode)
            };
            pub const Dff = enum(u1) {
                eight_bit = 0, // 8-bit data frame format is selected for transmission/reception
                sixteen_bit = 1, // 16-bit data frame format is selected for transmission/reception
            };
            pub const Crcnext = enum(u1) {
                tx_buffer = 0, // Next transmit value is from Tx buffer
                crc = 1, // Next transmit value is from Tx CRC register
            };
            pub const Crcen = enum(u1) {
                disabled = 0, // CRC calculation disabled
                enabled = 1, // CRC calculation enabled
            };
            pub const Bidioe = enum(u1) {
                output_disabled = 0, // Output disabled (receive-only mode)
                output_enabled = 1, // Output enabled (transmit-only mode)
            };
            pub const Bidimode = enum(u1) {
                unidirectional = 0, // 2-line unidirectional data mode selected
                bidirectional = 1, // 1-line bidirectional data mode selected
            };
            cpha: Cpha, // Clock phase (u1)
            cpol: Cpol, // Clock polarity (u1)
            mstr: Mstr, // Master selection (u1)
            br: Br, // Baud rate control (u3)
            spe: Spe, // SPI enable (u1)
            lsbfirst: Lsbfirst, // Frame format (u1)
            ssi: Ssi, // Internal slave select (u1)
            ssm: Ssm, // Software slave management (u1)
            rxonly: Rxonly, // Receive only (u1)
            dff: Dff, // Data frame format (u1)
            crcnext: Crcnext, // CRC transfer next (u1)
            crcen: Crcen, // Hardware CRC calculation enable (u1)
            bidioe: Bidioe, // Output enable in bidirectional mode (u1)
            bidimode: Bidimode, // Bidirectional data mode enable (u1)
            _padding_16_31: u16,
        };
        pub const cr1 = mmio(base_address + 0x0, 32, Cr1);

        /// address: 0x40004004
        /// control register 2
        pub const Cr2 = packed struct {
            pub const Rxdmaen = enum(u1) {
                disabled = 0, // Rx buffer DMA disabled
                enabled = 1, // Rx buffer DMA enabled
            };
            pub const Txdmaen = enum(u1) {
                disabled = 0, // Tx buffer DMA disabled
                enabled = 1, // Tx buffer DMA enabled
            };
            pub const Ssoe = enum(u1) {
                disabled = 0, // SS output is disabled in master mode
                enabled = 1, // SS output is enabled in master mode
            };
            pub const Frf = enum(u1) {
                motorola = 0, // SPI Motorola mode
                ti = 1, // SPI TI mode
            };
            pub const Errie = enum(u1) {
                masked = 0, // Error interrupt masked
                not_masked = 1, // Error interrupt not masked
            };
            pub const Rxneie = enum(u1) {
                masked = 0, // RXE interrupt masked
                not_masked = 1, // RXE interrupt not masked
            };
            pub const Txeie = enum(u1) {
                masked = 0, // TXE interrupt masked
                not_masked = 1, // TXE interrupt not masked
            };
            rxdmaen: Rxdmaen, // Rx buffer DMA enable (u1)
            txdmaen: Txdmaen, // Tx buffer DMA enable (u1)
            ssoe: Ssoe, // SS output enable (u1)
            _reserved_3_3: u1,
            frf: Frf, // Frame format (u1)
            errie: Errie, // Error interrupt enable (u1)
            rxneie: Rxneie, // RX buffer not empty interrupt enable (u1)
            txeie: Txeie, // Tx buffer empty interrupt enable (u1)
            _padding_8_31: u24,
        };
        pub const cr2 = mmio(base_address + 0x4, 32, Cr2);

        /// address: 0x40004008
        /// status register
        pub const Sr = packed struct {
            pub const Rxne = enum(u1) {
                empty = 0, // Rx buffer empty
                not_empty = 1, // Rx buffer not empty
            };
            pub const Txe = enum(u1) {
                not_empty = 0, // Tx buffer not empty
                empty = 1, // Tx buffer empty
            };
            pub const Chside = enum(u1) {
                left = 0, // Channel left has to be transmitted or has been received
                right = 1, // Channel right has to be transmitted or has been received
            };
            pub const Udrr = enum(u1) {
                no_underrun = 0, // No underrun occurred
                underrun = 1, // Underrun occurred
            };
            pub const Crcerr = enum(u1) {
                match = 0, // CRC value received matches the SPIx_RXCRCR value
                no_match = 1, // CRC value received does not match the SPIx_RXCRCR value
            };
            pub const Modfr = enum(u1) {
                no_fault = 0, // No mode fault occurred
                fault = 1, // Mode fault occurred
            };
            pub const Ovrr = enum(u1) {
                no_overrun = 0, // No overrun occurred
                overrun = 1, // Overrun occurred
            };
            pub const Bsyr = enum(u1) {
                not_busy = 0, // SPI not busy
                busy = 1, // SPI busy
            };
            pub const Frer = enum(u1) {
                no_error = 0, // No frame format error
                @"error" = 1, // A frame format error occurred
            };
            rxne: Rxne, // Receive buffer not empty (u1)
            txe: Txe, // Transmit buffer empty (u1)
            chside: Chside, // Channel side (u1)
            udr: Udrr, // Underrun flag (u1)
            crcerr: Crcerr, // CRC error flag (u1)
            modf: Modfr, // Mode fault (u1)
            ovr: Ovrr, // Overrun flag (u1)
            bsy: Bsyr, // Busy flag (u1)
            fre: Frer, // TI frame format error (u1)
            _padding_9_31: u23,
        };
        pub const sr = mmio(base_address + 0x8, 32, Sr);

        /// address: 0x4000400c
        /// data register
        pub const dr = mmioInt(base_address + 0xc, 32, u16);

        /// address: 0x40004010
        /// CRC polynomial register
        pub const Crcpr = packed struct {
            crcpoly: u16, // CRC polynomial register
            _padding_16_31: u16,
        };
        pub const crcpr = mmio(base_address + 0x10, 32, Crcpr);

        /// address: 0x40004014
        /// RX CRC register
        pub const Rxcrcr = packed struct {
            rxcrc: u16, // Rx CRC register
            _padding_16_31: u16,
        };
        pub const rxcrcr = mmio(base_address + 0x14, 32, Rxcrcr);

        /// address: 0x40004018
        /// TX CRC register
        pub const Txcrcr = packed struct {
            txcrc: u16, // Tx CRC register
            _padding_16_31: u16,
        };
        pub const txcrcr = mmio(base_address + 0x18, 32, Txcrcr);

        /// address: 0x4000401c
        /// I2S configuration register
        pub const I2scfgr = packed struct {
            pub const Chlen = enum(u1) {
                sixteen_bit = 0, // 16-bit wide
                thirty_two_bit = 1, // 32-bit wide
            };
            pub const Datlen = enum(u2) {
                sixteen_bit = 0b00, // 16-bit data length
                twenty_four_bit = 0b01, // 24-bit data length
                thirty_two_bit = 0b10, // 32-bit data length
            };
            pub const Ckpol = enum(u1) {
                idle_low = 0, // I2S clock inactive state is low level
                idle_high = 1, // I2S clock inactive state is high level
            };
            pub const I2sstd = enum(u2) {
                philips = 0b00, // I2S Philips standard
                msb = 0b01, // MSB justified standard
                lsb = 0b10, // LSB justified standard
                pcm = 0b11, // PCM standard
            };
            pub const Pcmsync = enum(u1) {
                short = 0, // Short frame synchronisation
                long = 1, // Long frame synchronisation
            };
            pub const I2scfg = enum(u2) {
                slave_tx = 0b00, // Slave - transmit
                slave_rx = 0b01, // Slave - receive
                master_tx = 0b10, // Master - transmit
                master_rx = 0b11, // Master - receive
            };
            pub const I2se = enum(u1) {
                disabled = 0, // I2S peripheral is disabled
                enabled = 1, // I2S peripheral is enabled
            };
            pub const I2smod = enum(u1) {
                spi_mode = 0, // SPI mode is selected
                i2_s_mode = 1, // I2S mode is selected
            };
            chlen: Chlen, // Channel length (number of bits per audio channel) (u1)
            datlen: Datlen, // Data length to be transferred (u2)
            ckpol: Ckpol, // Steady state clock polarity (u1)
            i2sstd: I2sstd, // I2S standard selection (u2)
            _reserved_6_6: u1,
            pcmsync: Pcmsync, // PCM frame synchronization (u1)
            i2scfg: I2scfg, // I2S configuration mode (u2)
            i2se: I2se, // I2S Enable (u1)
            i2smod: I2smod, // I2S mode selection (u1)
            _padding_12_31: u20,
        };
        pub const i2scfgr = mmio(base_address + 0x1c, 32, I2scfgr);

        /// address: 0x40004020
        /// I2S prescaler register
        pub const I2spr = packed struct {
            pub const Odd = enum(u1) {
                even = 0, // Real divider value is I2SDIV * 2
                odd = 1, // Real divider value is (I2SDIV * 2) + 1
            };
            pub const Mckoe = enum(u1) {
                disabled = 0, // Master clock output is disabled
                enabled = 1, // Master clock output is enabled
            };
            i2sdiv: u8, // I2S Linear prescaler
            odd: Odd, // Odd factor for the prescaler (u1)
            mckoe: Mckoe, // Master clock output enable (u1)
            _padding_10_31: u22,
        };
        pub const i2spr = mmio(base_address + 0x20, 32, I2spr);
    };
    /// Serial peripheral interface
    pub const spi2 = struct {
        pub const base_address = 0x40003800;

        /// address: 0x40003800
        /// control register 1
        pub const Cr1 = packed struct {
            pub const Cpha = enum(u1) {
                first_edge = 0, // The first clock transition is the first data capture edge
                second_edge = 1, // The second clock transition is the first data capture edge
            };
            pub const Cpol = enum(u1) {
                idle_low = 0, // CK to 0 when idle
                idle_high = 1, // CK to 1 when idle
            };
            pub const Mstr = enum(u1) {
                slave = 0, // Slave configuration
                master = 1, // Master configuration
            };
            pub const Br = enum(u3) {
                div2 = 0b000, // f_PCLK / 2
                div4 = 0b001, // f_PCLK / 4
                div8 = 0b010, // f_PCLK / 8
                div16 = 0b011, // f_PCLK / 16
                div32 = 0b100, // f_PCLK / 32
                div64 = 0b101, // f_PCLK / 64
                div128 = 0b110, // f_PCLK / 128
                div256 = 0b111, // f_PCLK / 256
            };
            pub const Spe = enum(u1) {
                disabled = 0, // Peripheral disabled
                enabled = 1, // Peripheral enabled
            };
            pub const Lsbfirst = enum(u1) {
                msb_first = 0, // Data is transmitted/received with the MSB first
                lsb_first = 1, // Data is transmitted/received with the LSB first
            };
            pub const Ssi = enum(u1) {
                slave_selected = 0, // 0 is forced onto the NSS pin and the I/O value of the NSS pin is ignored
                slave_not_selected = 1, // 1 is forced onto the NSS pin and the I/O value of the NSS pin is ignored
            };
            pub const Ssm = enum(u1) {
                disabled = 0, // Software slave management disabled
                enabled = 1, // Software slave management enabled
            };
            pub const Rxonly = enum(u1) {
                full_duplex = 0, // Full duplex (Transmit and receive)
                output_disabled = 1, // Output disabled (Receive-only mode)
            };
            pub const Dff = enum(u1) {
                eight_bit = 0, // 8-bit data frame format is selected for transmission/reception
                sixteen_bit = 1, // 16-bit data frame format is selected for transmission/reception
            };
            pub const Crcnext = enum(u1) {
                tx_buffer = 0, // Next transmit value is from Tx buffer
                crc = 1, // Next transmit value is from Tx CRC register
            };
            pub const Crcen = enum(u1) {
                disabled = 0, // CRC calculation disabled
                enabled = 1, // CRC calculation enabled
            };
            pub const Bidioe = enum(u1) {
                output_disabled = 0, // Output disabled (receive-only mode)
                output_enabled = 1, // Output enabled (transmit-only mode)
            };
            pub const Bidimode = enum(u1) {
                unidirectional = 0, // 2-line unidirectional data mode selected
                bidirectional = 1, // 1-line bidirectional data mode selected
            };
            cpha: Cpha, // Clock phase (u1)
            cpol: Cpol, // Clock polarity (u1)
            mstr: Mstr, // Master selection (u1)
            br: Br, // Baud rate control (u3)
            spe: Spe, // SPI enable (u1)
            lsbfirst: Lsbfirst, // Frame format (u1)
            ssi: Ssi, // Internal slave select (u1)
            ssm: Ssm, // Software slave management (u1)
            rxonly: Rxonly, // Receive only (u1)
            dff: Dff, // Data frame format (u1)
            crcnext: Crcnext, // CRC transfer next (u1)
            crcen: Crcen, // Hardware CRC calculation enable (u1)
            bidioe: Bidioe, // Output enable in bidirectional mode (u1)
            bidimode: Bidimode, // Bidirectional data mode enable (u1)
            _padding_16_31: u16,
        };
        pub const cr1 = mmio(base_address + 0x0, 32, Cr1);

        /// address: 0x40003804
        /// control register 2
        pub const Cr2 = packed struct {
            pub const Rxdmaen = enum(u1) {
                disabled = 0, // Rx buffer DMA disabled
                enabled = 1, // Rx buffer DMA enabled
            };
            pub const Txdmaen = enum(u1) {
                disabled = 0, // Tx buffer DMA disabled
                enabled = 1, // Tx buffer DMA enabled
            };
            pub const Ssoe = enum(u1) {
                disabled = 0, // SS output is disabled in master mode
                enabled = 1, // SS output is enabled in master mode
            };
            pub const Frf = enum(u1) {
                motorola = 0, // SPI Motorola mode
                ti = 1, // SPI TI mode
            };
            pub const Errie = enum(u1) {
                masked = 0, // Error interrupt masked
                not_masked = 1, // Error interrupt not masked
            };
            pub const Rxneie = enum(u1) {
                masked = 0, // RXE interrupt masked
                not_masked = 1, // RXE interrupt not masked
            };
            pub const Txeie = enum(u1) {
                masked = 0, // TXE interrupt masked
                not_masked = 1, // TXE interrupt not masked
            };
            rxdmaen: Rxdmaen, // Rx buffer DMA enable (u1)
            txdmaen: Txdmaen, // Tx buffer DMA enable (u1)
            ssoe: Ssoe, // SS output enable (u1)
            _reserved_3_3: u1,
            frf: Frf, // Frame format (u1)
            errie: Errie, // Error interrupt enable (u1)
            rxneie: Rxneie, // RX buffer not empty interrupt enable (u1)
            txeie: Txeie, // Tx buffer empty interrupt enable (u1)
            _padding_8_31: u24,
        };
        pub const cr2 = mmio(base_address + 0x4, 32, Cr2);

        /// address: 0x40003808
        /// status register
        pub const Sr = packed struct {
            pub const Rxne = enum(u1) {
                empty = 0, // Rx buffer empty
                not_empty = 1, // Rx buffer not empty
            };
            pub const Txe = enum(u1) {
                not_empty = 0, // Tx buffer not empty
                empty = 1, // Tx buffer empty
            };
            pub const Chside = enum(u1) {
                left = 0, // Channel left has to be transmitted or has been received
                right = 1, // Channel right has to be transmitted or has been received
            };
            pub const Udrr = enum(u1) {
                no_underrun = 0, // No underrun occurred
                underrun = 1, // Underrun occurred
            };
            pub const Crcerr = enum(u1) {
                match = 0, // CRC value received matches the SPIx_RXCRCR value
                no_match = 1, // CRC value received does not match the SPIx_RXCRCR value
            };
            pub const Modfr = enum(u1) {
                no_fault = 0, // No mode fault occurred
                fault = 1, // Mode fault occurred
            };
            pub const Ovrr = enum(u1) {
                no_overrun = 0, // No overrun occurred
                overrun = 1, // Overrun occurred
            };
            pub const Bsyr = enum(u1) {
                not_busy = 0, // SPI not busy
                busy = 1, // SPI busy
            };
            pub const Frer = enum(u1) {
                no_error = 0, // No frame format error
                @"error" = 1, // A frame format error occurred
            };
            rxne: Rxne, // Receive buffer not empty (u1)
            txe: Txe, // Transmit buffer empty (u1)
            chside: Chside, // Channel side (u1)
            udr: Udrr, // Underrun flag (u1)
            crcerr: Crcerr, // CRC error flag (u1)
            modf: Modfr, // Mode fault (u1)
            ovr: Ovrr, // Overrun flag (u1)
            bsy: Bsyr, // Busy flag (u1)
            fre: Frer, // TI frame format error (u1)
            _padding_9_31: u23,
        };
        pub const sr = mmio(base_address + 0x8, 32, Sr);

        /// address: 0x4000380c
        /// data register
        pub const dr = mmioInt(base_address + 0xc, 32, u16);

        /// address: 0x40003810
        /// CRC polynomial register
        pub const Crcpr = packed struct {
            crcpoly: u16, // CRC polynomial register
            _padding_16_31: u16,
        };
        pub const crcpr = mmio(base_address + 0x10, 32, Crcpr);

        /// address: 0x40003814
        /// RX CRC register
        pub const Rxcrcr = packed struct {
            rxcrc: u16, // Rx CRC register
            _padding_16_31: u16,
        };
        pub const rxcrcr = mmio(base_address + 0x14, 32, Rxcrcr);

        /// address: 0x40003818
        /// TX CRC register
        pub const Txcrcr = packed struct {
            txcrc: u16, // Tx CRC register
            _padding_16_31: u16,
        };
        pub const txcrcr = mmio(base_address + 0x18, 32, Txcrcr);

        /// address: 0x4000381c
        /// I2S configuration register
        pub const I2scfgr = packed struct {
            pub const Chlen = enum(u1) {
                sixteen_bit = 0, // 16-bit wide
                thirty_two_bit = 1, // 32-bit wide
            };
            pub const Datlen = enum(u2) {
                sixteen_bit = 0b00, // 16-bit data length
                twenty_four_bit = 0b01, // 24-bit data length
                thirty_two_bit = 0b10, // 32-bit data length
            };
            pub const Ckpol = enum(u1) {
                idle_low = 0, // I2S clock inactive state is low level
                idle_high = 1, // I2S clock inactive state is high level
            };
            pub const I2sstd = enum(u2) {
                philips = 0b00, // I2S Philips standard
                msb = 0b01, // MSB justified standard
                lsb = 0b10, // LSB justified standard
                pcm = 0b11, // PCM standard
            };
            pub const Pcmsync = enum(u1) {
                short = 0, // Short frame synchronisation
                long = 1, // Long frame synchronisation
            };
            pub const I2scfg = enum(u2) {
                slave_tx = 0b00, // Slave - transmit
                slave_rx = 0b01, // Slave - receive
                master_tx = 0b10, // Master - transmit
                master_rx = 0b11, // Master - receive
            };
            pub const I2se = enum(u1) {
                disabled = 0, // I2S peripheral is disabled
                enabled = 1, // I2S peripheral is enabled
            };
            pub const I2smod = enum(u1) {
                spi_mode = 0, // SPI mode is selected
                i2_s_mode = 1, // I2S mode is selected
            };
            chlen: Chlen, // Channel length (number of bits per audio channel) (u1)
            datlen: Datlen, // Data length to be transferred (u2)
            ckpol: Ckpol, // Steady state clock polarity (u1)
            i2sstd: I2sstd, // I2S standard selection (u2)
            _reserved_6_6: u1,
            pcmsync: Pcmsync, // PCM frame synchronization (u1)
            i2scfg: I2scfg, // I2S configuration mode (u2)
            i2se: I2se, // I2S Enable (u1)
            i2smod: I2smod, // I2S mode selection (u1)
            _padding_12_31: u20,
        };
        pub const i2scfgr = mmio(base_address + 0x1c, 32, I2scfgr);

        /// address: 0x40003820
        /// I2S prescaler register
        pub const I2spr = packed struct {
            pub const Odd = enum(u1) {
                even = 0, // Real divider value is I2SDIV * 2
                odd = 1, // Real divider value is (I2SDIV * 2) + 1
            };
            pub const Mckoe = enum(u1) {
                disabled = 0, // Master clock output is disabled
                enabled = 1, // Master clock output is enabled
            };
            i2sdiv: u8, // I2S Linear prescaler
            odd: Odd, // Odd factor for the prescaler (u1)
            mckoe: Mckoe, // Master clock output enable (u1)
            _padding_10_31: u22,
        };
        pub const i2spr = mmio(base_address + 0x20, 32, I2spr);
    };
    /// Serial peripheral interface
    pub const spi3 = struct {
        pub const base_address = 0x40003c00;

        /// address: 0x40003c00
        /// control register 1
        pub const Cr1 = packed struct {
            pub const Cpha = enum(u1) {
                first_edge = 0, // The first clock transition is the first data capture edge
                second_edge = 1, // The second clock transition is the first data capture edge
            };
            pub const Cpol = enum(u1) {
                idle_low = 0, // CK to 0 when idle
                idle_high = 1, // CK to 1 when idle
            };
            pub const Mstr = enum(u1) {
                slave = 0, // Slave configuration
                master = 1, // Master configuration
            };
            pub const Br = enum(u3) {
                div2 = 0b000, // f_PCLK / 2
                div4 = 0b001, // f_PCLK / 4
                div8 = 0b010, // f_PCLK / 8
                div16 = 0b011, // f_PCLK / 16
                div32 = 0b100, // f_PCLK / 32
                div64 = 0b101, // f_PCLK / 64
                div128 = 0b110, // f_PCLK / 128
                div256 = 0b111, // f_PCLK / 256
            };
            pub const Spe = enum(u1) {
                disabled = 0, // Peripheral disabled
                enabled = 1, // Peripheral enabled
            };
            pub const Lsbfirst = enum(u1) {
                msb_first = 0, // Data is transmitted/received with the MSB first
                lsb_first = 1, // Data is transmitted/received with the LSB first
            };
            pub const Ssi = enum(u1) {
                slave_selected = 0, // 0 is forced onto the NSS pin and the I/O value of the NSS pin is ignored
                slave_not_selected = 1, // 1 is forced onto the NSS pin and the I/O value of the NSS pin is ignored
            };
            pub const Ssm = enum(u1) {
                disabled = 0, // Software slave management disabled
                enabled = 1, // Software slave management enabled
            };
            pub const Rxonly = enum(u1) {
                full_duplex = 0, // Full duplex (Transmit and receive)
                output_disabled = 1, // Output disabled (Receive-only mode)
            };
            pub const Dff = enum(u1) {
                eight_bit = 0, // 8-bit data frame format is selected for transmission/reception
                sixteen_bit = 1, // 16-bit data frame format is selected for transmission/reception
            };
            pub const Crcnext = enum(u1) {
                tx_buffer = 0, // Next transmit value is from Tx buffer
                crc = 1, // Next transmit value is from Tx CRC register
            };
            pub const Crcen = enum(u1) {
                disabled = 0, // CRC calculation disabled
                enabled = 1, // CRC calculation enabled
            };
            pub const Bidioe = enum(u1) {
                output_disabled = 0, // Output disabled (receive-only mode)
                output_enabled = 1, // Output enabled (transmit-only mode)
            };
            pub const Bidimode = enum(u1) {
                unidirectional = 0, // 2-line unidirectional data mode selected
                bidirectional = 1, // 1-line bidirectional data mode selected
            };
            cpha: Cpha, // Clock phase (u1)
            cpol: Cpol, // Clock polarity (u1)
            mstr: Mstr, // Master selection (u1)
            br: Br, // Baud rate control (u3)
            spe: Spe, // SPI enable (u1)
            lsbfirst: Lsbfirst, // Frame format (u1)
            ssi: Ssi, // Internal slave select (u1)
            ssm: Ssm, // Software slave management (u1)
            rxonly: Rxonly, // Receive only (u1)
            dff: Dff, // Data frame format (u1)
            crcnext: Crcnext, // CRC transfer next (u1)
            crcen: Crcen, // Hardware CRC calculation enable (u1)
            bidioe: Bidioe, // Output enable in bidirectional mode (u1)
            bidimode: Bidimode, // Bidirectional data mode enable (u1)
            _padding_16_31: u16,
        };
        pub const cr1 = mmio(base_address + 0x0, 32, Cr1);

        /// address: 0x40003c04
        /// control register 2
        pub const Cr2 = packed struct {
            pub const Rxdmaen = enum(u1) {
                disabled = 0, // Rx buffer DMA disabled
                enabled = 1, // Rx buffer DMA enabled
            };
            pub const Txdmaen = enum(u1) {
                disabled = 0, // Tx buffer DMA disabled
                enabled = 1, // Tx buffer DMA enabled
            };
            pub const Ssoe = enum(u1) {
                disabled = 0, // SS output is disabled in master mode
                enabled = 1, // SS output is enabled in master mode
            };
            pub const Frf = enum(u1) {
                motorola = 0, // SPI Motorola mode
                ti = 1, // SPI TI mode
            };
            pub const Errie = enum(u1) {
                masked = 0, // Error interrupt masked
                not_masked = 1, // Error interrupt not masked
            };
            pub const Rxneie = enum(u1) {
                masked = 0, // RXE interrupt masked
                not_masked = 1, // RXE interrupt not masked
            };
            pub const Txeie = enum(u1) {
                masked = 0, // TXE interrupt masked
                not_masked = 1, // TXE interrupt not masked
            };
            rxdmaen: Rxdmaen, // Rx buffer DMA enable (u1)
            txdmaen: Txdmaen, // Tx buffer DMA enable (u1)
            ssoe: Ssoe, // SS output enable (u1)
            _reserved_3_3: u1,
            frf: Frf, // Frame format (u1)
            errie: Errie, // Error interrupt enable (u1)
            rxneie: Rxneie, // RX buffer not empty interrupt enable (u1)
            txeie: Txeie, // Tx buffer empty interrupt enable (u1)
            _padding_8_31: u24,
        };
        pub const cr2 = mmio(base_address + 0x4, 32, Cr2);

        /// address: 0x40003c08
        /// status register
        pub const Sr = packed struct {
            pub const Rxne = enum(u1) {
                empty = 0, // Rx buffer empty
                not_empty = 1, // Rx buffer not empty
            };
            pub const Txe = enum(u1) {
                not_empty = 0, // Tx buffer not empty
                empty = 1, // Tx buffer empty
            };
            pub const Chside = enum(u1) {
                left = 0, // Channel left has to be transmitted or has been received
                right = 1, // Channel right has to be transmitted or has been received
            };
            pub const Udrr = enum(u1) {
                no_underrun = 0, // No underrun occurred
                underrun = 1, // Underrun occurred
            };
            pub const Crcerr = enum(u1) {
                match = 0, // CRC value received matches the SPIx_RXCRCR value
                no_match = 1, // CRC value received does not match the SPIx_RXCRCR value
            };
            pub const Modfr = enum(u1) {
                no_fault = 0, // No mode fault occurred
                fault = 1, // Mode fault occurred
            };
            pub const Ovrr = enum(u1) {
                no_overrun = 0, // No overrun occurred
                overrun = 1, // Overrun occurred
            };
            pub const Bsyr = enum(u1) {
                not_busy = 0, // SPI not busy
                busy = 1, // SPI busy
            };
            pub const Frer = enum(u1) {
                no_error = 0, // No frame format error
                @"error" = 1, // A frame format error occurred
            };
            rxne: Rxne, // Receive buffer not empty (u1)
            txe: Txe, // Transmit buffer empty (u1)
            chside: Chside, // Channel side (u1)
            udr: Udrr, // Underrun flag (u1)
            crcerr: Crcerr, // CRC error flag (u1)
            modf: Modfr, // Mode fault (u1)
            ovr: Ovrr, // Overrun flag (u1)
            bsy: Bsyr, // Busy flag (u1)
            fre: Frer, // TI frame format error (u1)
            _padding_9_31: u23,
        };
        pub const sr = mmio(base_address + 0x8, 32, Sr);

        /// address: 0x40003c0c
        /// data register
        pub const dr = mmioInt(base_address + 0xc, 32, u16);

        /// address: 0x40003c10
        /// CRC polynomial register
        pub const Crcpr = packed struct {
            crcpoly: u16, // CRC polynomial register
            _padding_16_31: u16,
        };
        pub const crcpr = mmio(base_address + 0x10, 32, Crcpr);

        /// address: 0x40003c14
        /// RX CRC register
        pub const Rxcrcr = packed struct {
            rxcrc: u16, // Rx CRC register
            _padding_16_31: u16,
        };
        pub const rxcrcr = mmio(base_address + 0x14, 32, Rxcrcr);

        /// address: 0x40003c18
        /// TX CRC register
        pub const Txcrcr = packed struct {
            txcrc: u16, // Tx CRC register
            _padding_16_31: u16,
        };
        pub const txcrcr = mmio(base_address + 0x18, 32, Txcrcr);

        /// address: 0x40003c1c
        /// I2S configuration register
        pub const I2scfgr = packed struct {
            pub const Chlen = enum(u1) {
                sixteen_bit = 0, // 16-bit wide
                thirty_two_bit = 1, // 32-bit wide
            };
            pub const Datlen = enum(u2) {
                sixteen_bit = 0b00, // 16-bit data length
                twenty_four_bit = 0b01, // 24-bit data length
                thirty_two_bit = 0b10, // 32-bit data length
            };
            pub const Ckpol = enum(u1) {
                idle_low = 0, // I2S clock inactive state is low level
                idle_high = 1, // I2S clock inactive state is high level
            };
            pub const I2sstd = enum(u2) {
                philips = 0b00, // I2S Philips standard
                msb = 0b01, // MSB justified standard
                lsb = 0b10, // LSB justified standard
                pcm = 0b11, // PCM standard
            };
            pub const Pcmsync = enum(u1) {
                short = 0, // Short frame synchronisation
                long = 1, // Long frame synchronisation
            };
            pub const I2scfg = enum(u2) {
                slave_tx = 0b00, // Slave - transmit
                slave_rx = 0b01, // Slave - receive
                master_tx = 0b10, // Master - transmit
                master_rx = 0b11, // Master - receive
            };
            pub const I2se = enum(u1) {
                disabled = 0, // I2S peripheral is disabled
                enabled = 1, // I2S peripheral is enabled
            };
            pub const I2smod = enum(u1) {
                spi_mode = 0, // SPI mode is selected
                i2_s_mode = 1, // I2S mode is selected
            };
            chlen: Chlen, // Channel length (number of bits per audio channel) (u1)
            datlen: Datlen, // Data length to be transferred (u2)
            ckpol: Ckpol, // Steady state clock polarity (u1)
            i2sstd: I2sstd, // I2S standard selection (u2)
            _reserved_6_6: u1,
            pcmsync: Pcmsync, // PCM frame synchronization (u1)
            i2scfg: I2scfg, // I2S configuration mode (u2)
            i2se: I2se, // I2S Enable (u1)
            i2smod: I2smod, // I2S mode selection (u1)
            _padding_12_31: u20,
        };
        pub const i2scfgr = mmio(base_address + 0x1c, 32, I2scfgr);

        /// address: 0x40003c20
        /// I2S prescaler register
        pub const I2spr = packed struct {
            pub const Odd = enum(u1) {
                even = 0, // Real divider value is I2SDIV * 2
                odd = 1, // Real divider value is (I2SDIV * 2) + 1
            };
            pub const Mckoe = enum(u1) {
                disabled = 0, // Master clock output is disabled
                enabled = 1, // Master clock output is enabled
            };
            i2sdiv: u8, // I2S Linear prescaler
            odd: Odd, // Odd factor for the prescaler (u1)
            mckoe: Mckoe, // Master clock output enable (u1)
            _padding_10_31: u22,
        };
        pub const i2spr = mmio(base_address + 0x20, 32, I2spr);
    };
    /// Serial peripheral interface
    pub const spi4 = struct {
        pub const base_address = 0x40013400;

        /// address: 0x40013400
        /// control register 1
        pub const Cr1 = packed struct {
            pub const Cpha = enum(u1) {
                first_edge = 0, // The first clock transition is the first data capture edge
                second_edge = 1, // The second clock transition is the first data capture edge
            };
            pub const Cpol = enum(u1) {
                idle_low = 0, // CK to 0 when idle
                idle_high = 1, // CK to 1 when idle
            };
            pub const Mstr = enum(u1) {
                slave = 0, // Slave configuration
                master = 1, // Master configuration
            };
            pub const Br = enum(u3) {
                div2 = 0b000, // f_PCLK / 2
                div4 = 0b001, // f_PCLK / 4
                div8 = 0b010, // f_PCLK / 8
                div16 = 0b011, // f_PCLK / 16
                div32 = 0b100, // f_PCLK / 32
                div64 = 0b101, // f_PCLK / 64
                div128 = 0b110, // f_PCLK / 128
                div256 = 0b111, // f_PCLK / 256
            };
            pub const Spe = enum(u1) {
                disabled = 0, // Peripheral disabled
                enabled = 1, // Peripheral enabled
            };
            pub const Lsbfirst = enum(u1) {
                msb_first = 0, // Data is transmitted/received with the MSB first
                lsb_first = 1, // Data is transmitted/received with the LSB first
            };
            pub const Ssi = enum(u1) {
                slave_selected = 0, // 0 is forced onto the NSS pin and the I/O value of the NSS pin is ignored
                slave_not_selected = 1, // 1 is forced onto the NSS pin and the I/O value of the NSS pin is ignored
            };
            pub const Ssm = enum(u1) {
                disabled = 0, // Software slave management disabled
                enabled = 1, // Software slave management enabled
            };
            pub const Rxonly = enum(u1) {
                full_duplex = 0, // Full duplex (Transmit and receive)
                output_disabled = 1, // Output disabled (Receive-only mode)
            };
            pub const Dff = enum(u1) {
                eight_bit = 0, // 8-bit data frame format is selected for transmission/reception
                sixteen_bit = 1, // 16-bit data frame format is selected for transmission/reception
            };
            pub const Crcnext = enum(u1) {
                tx_buffer = 0, // Next transmit value is from Tx buffer
                crc = 1, // Next transmit value is from Tx CRC register
            };
            pub const Crcen = enum(u1) {
                disabled = 0, // CRC calculation disabled
                enabled = 1, // CRC calculation enabled
            };
            pub const Bidioe = enum(u1) {
                output_disabled = 0, // Output disabled (receive-only mode)
                output_enabled = 1, // Output enabled (transmit-only mode)
            };
            pub const Bidimode = enum(u1) {
                unidirectional = 0, // 2-line unidirectional data mode selected
                bidirectional = 1, // 1-line bidirectional data mode selected
            };
            cpha: Cpha, // Clock phase (u1)
            cpol: Cpol, // Clock polarity (u1)
            mstr: Mstr, // Master selection (u1)
            br: Br, // Baud rate control (u3)
            spe: Spe, // SPI enable (u1)
            lsbfirst: Lsbfirst, // Frame format (u1)
            ssi: Ssi, // Internal slave select (u1)
            ssm: Ssm, // Software slave management (u1)
            rxonly: Rxonly, // Receive only (u1)
            dff: Dff, // Data frame format (u1)
            crcnext: Crcnext, // CRC transfer next (u1)
            crcen: Crcen, // Hardware CRC calculation enable (u1)
            bidioe: Bidioe, // Output enable in bidirectional mode (u1)
            bidimode: Bidimode, // Bidirectional data mode enable (u1)
            _padding_16_31: u16,
        };
        pub const cr1 = mmio(base_address + 0x0, 32, Cr1);

        /// address: 0x40013404
        /// control register 2
        pub const Cr2 = packed struct {
            pub const Rxdmaen = enum(u1) {
                disabled = 0, // Rx buffer DMA disabled
                enabled = 1, // Rx buffer DMA enabled
            };
            pub const Txdmaen = enum(u1) {
                disabled = 0, // Tx buffer DMA disabled
                enabled = 1, // Tx buffer DMA enabled
            };
            pub const Ssoe = enum(u1) {
                disabled = 0, // SS output is disabled in master mode
                enabled = 1, // SS output is enabled in master mode
            };
            pub const Frf = enum(u1) {
                motorola = 0, // SPI Motorola mode
                ti = 1, // SPI TI mode
            };
            pub const Errie = enum(u1) {
                masked = 0, // Error interrupt masked
                not_masked = 1, // Error interrupt not masked
            };
            pub const Rxneie = enum(u1) {
                masked = 0, // RXE interrupt masked
                not_masked = 1, // RXE interrupt not masked
            };
            pub const Txeie = enum(u1) {
                masked = 0, // TXE interrupt masked
                not_masked = 1, // TXE interrupt not masked
            };
            rxdmaen: Rxdmaen, // Rx buffer DMA enable (u1)
            txdmaen: Txdmaen, // Tx buffer DMA enable (u1)
            ssoe: Ssoe, // SS output enable (u1)
            _reserved_3_3: u1,
            frf: Frf, // Frame format (u1)
            errie: Errie, // Error interrupt enable (u1)
            rxneie: Rxneie, // RX buffer not empty interrupt enable (u1)
            txeie: Txeie, // Tx buffer empty interrupt enable (u1)
            _padding_8_31: u24,
        };
        pub const cr2 = mmio(base_address + 0x4, 32, Cr2);

        /// address: 0x40013408
        /// status register
        pub const Sr = packed struct {
            pub const Rxne = enum(u1) {
                empty = 0, // Rx buffer empty
                not_empty = 1, // Rx buffer not empty
            };
            pub const Txe = enum(u1) {
                not_empty = 0, // Tx buffer not empty
                empty = 1, // Tx buffer empty
            };
            pub const Chside = enum(u1) {
                left = 0, // Channel left has to be transmitted or has been received
                right = 1, // Channel right has to be transmitted or has been received
            };
            pub const Udrr = enum(u1) {
                no_underrun = 0, // No underrun occurred
                underrun = 1, // Underrun occurred
            };
            pub const Crcerr = enum(u1) {
                match = 0, // CRC value received matches the SPIx_RXCRCR value
                no_match = 1, // CRC value received does not match the SPIx_RXCRCR value
            };
            pub const Modfr = enum(u1) {
                no_fault = 0, // No mode fault occurred
                fault = 1, // Mode fault occurred
            };
            pub const Ovrr = enum(u1) {
                no_overrun = 0, // No overrun occurred
                overrun = 1, // Overrun occurred
            };
            pub const Bsyr = enum(u1) {
                not_busy = 0, // SPI not busy
                busy = 1, // SPI busy
            };
            pub const Frer = enum(u1) {
                no_error = 0, // No frame format error
                @"error" = 1, // A frame format error occurred
            };
            rxne: Rxne, // Receive buffer not empty (u1)
            txe: Txe, // Transmit buffer empty (u1)
            chside: Chside, // Channel side (u1)
            udr: Udrr, // Underrun flag (u1)
            crcerr: Crcerr, // CRC error flag (u1)
            modf: Modfr, // Mode fault (u1)
            ovr: Ovrr, // Overrun flag (u1)
            bsy: Bsyr, // Busy flag (u1)
            fre: Frer, // TI frame format error (u1)
            _padding_9_31: u23,
        };
        pub const sr = mmio(base_address + 0x8, 32, Sr);

        /// address: 0x4001340c
        /// data register
        pub const dr = mmioInt(base_address + 0xc, 32, u16);

        /// address: 0x40013410
        /// CRC polynomial register
        pub const Crcpr = packed struct {
            crcpoly: u16, // CRC polynomial register
            _padding_16_31: u16,
        };
        pub const crcpr = mmio(base_address + 0x10, 32, Crcpr);

        /// address: 0x40013414
        /// RX CRC register
        pub const Rxcrcr = packed struct {
            rxcrc: u16, // Rx CRC register
            _padding_16_31: u16,
        };
        pub const rxcrcr = mmio(base_address + 0x14, 32, Rxcrcr);

        /// address: 0x40013418
        /// TX CRC register
        pub const Txcrcr = packed struct {
            txcrc: u16, // Tx CRC register
            _padding_16_31: u16,
        };
        pub const txcrcr = mmio(base_address + 0x18, 32, Txcrcr);

        /// address: 0x4001341c
        /// I2S configuration register
        pub const I2scfgr = packed struct {
            pub const Chlen = enum(u1) {
                sixteen_bit = 0, // 16-bit wide
                thirty_two_bit = 1, // 32-bit wide
            };
            pub const Datlen = enum(u2) {
                sixteen_bit = 0b00, // 16-bit data length
                twenty_four_bit = 0b01, // 24-bit data length
                thirty_two_bit = 0b10, // 32-bit data length
            };
            pub const Ckpol = enum(u1) {
                idle_low = 0, // I2S clock inactive state is low level
                idle_high = 1, // I2S clock inactive state is high level
            };
            pub const I2sstd = enum(u2) {
                philips = 0b00, // I2S Philips standard
                msb = 0b01, // MSB justified standard
                lsb = 0b10, // LSB justified standard
                pcm = 0b11, // PCM standard
            };
            pub const Pcmsync = enum(u1) {
                short = 0, // Short frame synchronisation
                long = 1, // Long frame synchronisation
            };
            pub const I2scfg = enum(u2) {
                slave_tx = 0b00, // Slave - transmit
                slave_rx = 0b01, // Slave - receive
                master_tx = 0b10, // Master - transmit
                master_rx = 0b11, // Master - receive
            };
            pub const I2se = enum(u1) {
                disabled = 0, // I2S peripheral is disabled
                enabled = 1, // I2S peripheral is enabled
            };
            pub const I2smod = enum(u1) {
                spi_mode = 0, // SPI mode is selected
                i2_s_mode = 1, // I2S mode is selected
            };
            chlen: Chlen, // Channel length (number of bits per audio channel) (u1)
            datlen: Datlen, // Data length to be transferred (u2)
            ckpol: Ckpol, // Steady state clock polarity (u1)
            i2sstd: I2sstd, // I2S standard selection (u2)
            _reserved_6_6: u1,
            pcmsync: Pcmsync, // PCM frame synchronization (u1)
            i2scfg: I2scfg, // I2S configuration mode (u2)
            i2se: I2se, // I2S Enable (u1)
            i2smod: I2smod, // I2S mode selection (u1)
            _padding_12_31: u20,
        };
        pub const i2scfgr = mmio(base_address + 0x1c, 32, I2scfgr);

        /// address: 0x40013420
        /// I2S prescaler register
        pub const I2spr = packed struct {
            pub const Odd = enum(u1) {
                even = 0, // Real divider value is I2SDIV * 2
                odd = 1, // Real divider value is (I2SDIV * 2) + 1
            };
            pub const Mckoe = enum(u1) {
                disabled = 0, // Master clock output is disabled
                enabled = 1, // Master clock output is enabled
            };
            i2sdiv: u8, // I2S Linear prescaler
            odd: Odd, // Odd factor for the prescaler (u1)
            mckoe: Mckoe, // Master clock output enable (u1)
            _padding_10_31: u22,
        };
        pub const i2spr = mmio(base_address + 0x20, 32, I2spr);
    };
    /// Serial peripheral interface
    pub const spi5 = struct {
        pub const base_address = 0x40015000;

        /// address: 0x40015000
        /// control register 1
        pub const Cr1 = packed struct {
            pub const Cpha = enum(u1) {
                first_edge = 0, // The first clock transition is the first data capture edge
                second_edge = 1, // The second clock transition is the first data capture edge
            };
            pub const Cpol = enum(u1) {
                idle_low = 0, // CK to 0 when idle
                idle_high = 1, // CK to 1 when idle
            };
            pub const Mstr = enum(u1) {
                slave = 0, // Slave configuration
                master = 1, // Master configuration
            };
            pub const Br = enum(u3) {
                div2 = 0b000, // f_PCLK / 2
                div4 = 0b001, // f_PCLK / 4
                div8 = 0b010, // f_PCLK / 8
                div16 = 0b011, // f_PCLK / 16
                div32 = 0b100, // f_PCLK / 32
                div64 = 0b101, // f_PCLK / 64
                div128 = 0b110, // f_PCLK / 128
                div256 = 0b111, // f_PCLK / 256
            };
            pub const Spe = enum(u1) {
                disabled = 0, // Peripheral disabled
                enabled = 1, // Peripheral enabled
            };
            pub const Lsbfirst = enum(u1) {
                msb_first = 0, // Data is transmitted/received with the MSB first
                lsb_first = 1, // Data is transmitted/received with the LSB first
            };
            pub const Ssi = enum(u1) {
                slave_selected = 0, // 0 is forced onto the NSS pin and the I/O value of the NSS pin is ignored
                slave_not_selected = 1, // 1 is forced onto the NSS pin and the I/O value of the NSS pin is ignored
            };
            pub const Ssm = enum(u1) {
                disabled = 0, // Software slave management disabled
                enabled = 1, // Software slave management enabled
            };
            pub const Rxonly = enum(u1) {
                full_duplex = 0, // Full duplex (Transmit and receive)
                output_disabled = 1, // Output disabled (Receive-only mode)
            };
            pub const Dff = enum(u1) {
                eight_bit = 0, // 8-bit data frame format is selected for transmission/reception
                sixteen_bit = 1, // 16-bit data frame format is selected for transmission/reception
            };
            pub const Crcnext = enum(u1) {
                tx_buffer = 0, // Next transmit value is from Tx buffer
                crc = 1, // Next transmit value is from Tx CRC register
            };
            pub const Crcen = enum(u1) {
                disabled = 0, // CRC calculation disabled
                enabled = 1, // CRC calculation enabled
            };
            pub const Bidioe = enum(u1) {
                output_disabled = 0, // Output disabled (receive-only mode)
                output_enabled = 1, // Output enabled (transmit-only mode)
            };
            pub const Bidimode = enum(u1) {
                unidirectional = 0, // 2-line unidirectional data mode selected
                bidirectional = 1, // 1-line bidirectional data mode selected
            };
            cpha: Cpha, // Clock phase (u1)
            cpol: Cpol, // Clock polarity (u1)
            mstr: Mstr, // Master selection (u1)
            br: Br, // Baud rate control (u3)
            spe: Spe, // SPI enable (u1)
            lsbfirst: Lsbfirst, // Frame format (u1)
            ssi: Ssi, // Internal slave select (u1)
            ssm: Ssm, // Software slave management (u1)
            rxonly: Rxonly, // Receive only (u1)
            dff: Dff, // Data frame format (u1)
            crcnext: Crcnext, // CRC transfer next (u1)
            crcen: Crcen, // Hardware CRC calculation enable (u1)
            bidioe: Bidioe, // Output enable in bidirectional mode (u1)
            bidimode: Bidimode, // Bidirectional data mode enable (u1)
            _padding_16_31: u16,
        };
        pub const cr1 = mmio(base_address + 0x0, 32, Cr1);

        /// address: 0x40015004
        /// control register 2
        pub const Cr2 = packed struct {
            pub const Rxdmaen = enum(u1) {
                disabled = 0, // Rx buffer DMA disabled
                enabled = 1, // Rx buffer DMA enabled
            };
            pub const Txdmaen = enum(u1) {
                disabled = 0, // Tx buffer DMA disabled
                enabled = 1, // Tx buffer DMA enabled
            };
            pub const Ssoe = enum(u1) {
                disabled = 0, // SS output is disabled in master mode
                enabled = 1, // SS output is enabled in master mode
            };
            pub const Frf = enum(u1) {
                motorola = 0, // SPI Motorola mode
                ti = 1, // SPI TI mode
            };
            pub const Errie = enum(u1) {
                masked = 0, // Error interrupt masked
                not_masked = 1, // Error interrupt not masked
            };
            pub const Rxneie = enum(u1) {
                masked = 0, // RXE interrupt masked
                not_masked = 1, // RXE interrupt not masked
            };
            pub const Txeie = enum(u1) {
                masked = 0, // TXE interrupt masked
                not_masked = 1, // TXE interrupt not masked
            };
            rxdmaen: Rxdmaen, // Rx buffer DMA enable (u1)
            txdmaen: Txdmaen, // Tx buffer DMA enable (u1)
            ssoe: Ssoe, // SS output enable (u1)
            _reserved_3_3: u1,
            frf: Frf, // Frame format (u1)
            errie: Errie, // Error interrupt enable (u1)
            rxneie: Rxneie, // RX buffer not empty interrupt enable (u1)
            txeie: Txeie, // Tx buffer empty interrupt enable (u1)
            _padding_8_31: u24,
        };
        pub const cr2 = mmio(base_address + 0x4, 32, Cr2);

        /// address: 0x40015008
        /// status register
        pub const Sr = packed struct {
            pub const Rxne = enum(u1) {
                empty = 0, // Rx buffer empty
                not_empty = 1, // Rx buffer not empty
            };
            pub const Txe = enum(u1) {
                not_empty = 0, // Tx buffer not empty
                empty = 1, // Tx buffer empty
            };
            pub const Chside = enum(u1) {
                left = 0, // Channel left has to be transmitted or has been received
                right = 1, // Channel right has to be transmitted or has been received
            };
            pub const Udrr = enum(u1) {
                no_underrun = 0, // No underrun occurred
                underrun = 1, // Underrun occurred
            };
            pub const Crcerr = enum(u1) {
                match = 0, // CRC value received matches the SPIx_RXCRCR value
                no_match = 1, // CRC value received does not match the SPIx_RXCRCR value
            };
            pub const Modfr = enum(u1) {
                no_fault = 0, // No mode fault occurred
                fault = 1, // Mode fault occurred
            };
            pub const Ovrr = enum(u1) {
                no_overrun = 0, // No overrun occurred
                overrun = 1, // Overrun occurred
            };
            pub const Bsyr = enum(u1) {
                not_busy = 0, // SPI not busy
                busy = 1, // SPI busy
            };
            pub const Frer = enum(u1) {
                no_error = 0, // No frame format error
                @"error" = 1, // A frame format error occurred
            };
            rxne: Rxne, // Receive buffer not empty (u1)
            txe: Txe, // Transmit buffer empty (u1)
            chside: Chside, // Channel side (u1)
            udr: Udrr, // Underrun flag (u1)
            crcerr: Crcerr, // CRC error flag (u1)
            modf: Modfr, // Mode fault (u1)
            ovr: Ovrr, // Overrun flag (u1)
            bsy: Bsyr, // Busy flag (u1)
            fre: Frer, // TI frame format error (u1)
            _padding_9_31: u23,
        };
        pub const sr = mmio(base_address + 0x8, 32, Sr);

        /// address: 0x4001500c
        /// data register
        pub const dr = mmioInt(base_address + 0xc, 32, u16);

        /// address: 0x40015010
        /// CRC polynomial register
        pub const Crcpr = packed struct {
            crcpoly: u16, // CRC polynomial register
            _padding_16_31: u16,
        };
        pub const crcpr = mmio(base_address + 0x10, 32, Crcpr);

        /// address: 0x40015014
        /// RX CRC register
        pub const Rxcrcr = packed struct {
            rxcrc: u16, // Rx CRC register
            _padding_16_31: u16,
        };
        pub const rxcrcr = mmio(base_address + 0x14, 32, Rxcrcr);

        /// address: 0x40015018
        /// TX CRC register
        pub const Txcrcr = packed struct {
            txcrc: u16, // Tx CRC register
            _padding_16_31: u16,
        };
        pub const txcrcr = mmio(base_address + 0x18, 32, Txcrcr);

        /// address: 0x4001501c
        /// I2S configuration register
        pub const I2scfgr = packed struct {
            pub const Chlen = enum(u1) {
                sixteen_bit = 0, // 16-bit wide
                thirty_two_bit = 1, // 32-bit wide
            };
            pub const Datlen = enum(u2) {
                sixteen_bit = 0b00, // 16-bit data length
                twenty_four_bit = 0b01, // 24-bit data length
                thirty_two_bit = 0b10, // 32-bit data length
            };
            pub const Ckpol = enum(u1) {
                idle_low = 0, // I2S clock inactive state is low level
                idle_high = 1, // I2S clock inactive state is high level
            };
            pub const I2sstd = enum(u2) {
                philips = 0b00, // I2S Philips standard
                msb = 0b01, // MSB justified standard
                lsb = 0b10, // LSB justified standard
                pcm = 0b11, // PCM standard
            };
            pub const Pcmsync = enum(u1) {
                short = 0, // Short frame synchronisation
                long = 1, // Long frame synchronisation
            };
            pub const I2scfg = enum(u2) {
                slave_tx = 0b00, // Slave - transmit
                slave_rx = 0b01, // Slave - receive
                master_tx = 0b10, // Master - transmit
                master_rx = 0b11, // Master - receive
            };
            pub const I2se = enum(u1) {
                disabled = 0, // I2S peripheral is disabled
                enabled = 1, // I2S peripheral is enabled
            };
            pub const I2smod = enum(u1) {
                spi_mode = 0, // SPI mode is selected
                i2_s_mode = 1, // I2S mode is selected
            };
            chlen: Chlen, // Channel length (number of bits per audio channel) (u1)
            datlen: Datlen, // Data length to be transferred (u2)
            ckpol: Ckpol, // Steady state clock polarity (u1)
            i2sstd: I2sstd, // I2S standard selection (u2)
            _reserved_6_6: u1,
            pcmsync: Pcmsync, // PCM frame synchronization (u1)
            i2scfg: I2scfg, // I2S configuration mode (u2)
            i2se: I2se, // I2S Enable (u1)
            i2smod: I2smod, // I2S mode selection (u1)
            _padding_12_31: u20,
        };
        pub const i2scfgr = mmio(base_address + 0x1c, 32, I2scfgr);

        /// address: 0x40015020
        /// I2S prescaler register
        pub const I2spr = packed struct {
            pub const Odd = enum(u1) {
                even = 0, // Real divider value is I2SDIV * 2
                odd = 1, // Real divider value is (I2SDIV * 2) + 1
            };
            pub const Mckoe = enum(u1) {
                disabled = 0, // Master clock output is disabled
                enabled = 1, // Master clock output is enabled
            };
            i2sdiv: u8, // I2S Linear prescaler
            odd: Odd, // Odd factor for the prescaler (u1)
            mckoe: Mckoe, // Master clock output enable (u1)
            _padding_10_31: u22,
        };
        pub const i2spr = mmio(base_address + 0x20, 32, I2spr);
    };
};
const std = @import("std");

pub fn mmio(addr: usize, comptime size: u8, comptime PackedT: type) *volatile Mmio(size, PackedT) {
    return @intToPtr(*volatile Mmio(size, PackedT), addr);
}

pub fn Mmio(comptime size: u8, comptime PackedT: type) type {
    if ((size % 8) != 0)
        @compileError("size must be divisible by 8!");

    if (!std.math.isPowerOfTwo(size / 8))
        @compileError("size must encode a power of two number of bytes!");

    const IntT = std.meta.Int(.unsigned, size);

    if (@sizeOf(PackedT) != (size / 8))
        @compileError(std.fmt.comptimePrint("IntT and PackedT must have the same size!, they are {} and {} bytes respectively", .{ size / 8, @sizeOf(PackedT) }));

    return extern struct {
        const Self = @This();

        raw: IntT,

        pub const underlying_type = PackedT;

        pub inline fn read(addr: *volatile Self) PackedT {
            return @bitCast(PackedT, addr.raw);
        }

        pub inline fn write(addr: *volatile Self, val: PackedT) void {
            // This is a workaround for a compiler bug related to miscompilation
            // If the tmp var is not used, result location will fuck things up
            var tmp = @bitCast(IntT, val);
            addr.raw = tmp;
        }

        pub inline fn modify(addr: *volatile Self, fields: anytype) void {
            var val = read(addr);
            inline for (@typeInfo(@TypeOf(fields)).Struct.fields) |field| {
                @field(val, field.name) = @field(fields, field.name);
            }
            write(addr, val);
        }

        pub inline fn toggle(addr: *volatile Self, fields: anytype) void {
            var val = read(addr);
            inline for (@typeInfo(@TypeOf(fields)).Struct.fields) |field| {
                @field(val, @tagName(field.default_value.?)) = !@field(val, @tagName(field.default_value.?));
            }
            write(addr, val);
        }

        pub inline fn set(addr: *volatile Self, comptime field_name: anytype, field_value: anytype) void {
            var val = read(addr);
            @field(val, field_name) = field_value;
            write(addr, val);
        }
    };
}

pub fn MmioInt(comptime size: u8, comptime T: type) type {
    return extern struct {
        const Self = @This();

        raw: std.meta.Int(.unsigned, size),

        pub inline fn read(addr: *volatile Self) T {
            return @truncate(T, addr.raw);
        }

        pub inline fn modify(addr: *volatile Self, val: T) void {
            const Int = std.meta.Int(.unsigned, size);
            const mask = ~@as(Int, (1 << @bitSizeOf(T)) - 1);

            var tmp = addr.raw;
            addr.raw = (tmp & mask) | val;
        }
    };
}

pub fn mmioInt(addr: usize, comptime size: usize, comptime T: type) *volatile MmioInt(size, T) {
    return @intToPtr(*volatile MmioInt(size, T), addr);
}
