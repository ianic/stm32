#!/usr/bin/env ruby

require 'erb'
require 'json'
require 'nokogiri'
require 'csv'

if ARGV[0].nil?
	print "Usage: registers.rb [chip-name]\n"
	exit 1
end

def read_data(chip)
    filename = "data/STM32F#{chip[0..2].upcase}.svd"
    doc = File.open(filename) { |f| Nokogiri::XML(f) }
    peripherals = []
    for pd in doc.xpath("//peripheral") do
      # if derivedFrom is defined on peripheral
      # copy from parent except name and base_address
      unless pd.attribute("derivedFrom").nil?
        from_name = pd.attribute("derivedFrom").text
        parent = peripherals.find{ |p| p["name"] == from_name }
        p = parent.clone.merge({
                                    "name" => pd.xpath("name").text,
                                    "base_address" => pd.xpath("baseAddress").text.sub("0X", "0x").downcase,
                                  })
        peripherals << p
        next
      end

      p = {
        "name" => pd.xpath("name").text,
        "desc" => pd.xpath("description").text.delete("\n").squeeze(" "),
        "group" => pd.xpath("groupName").text,
        "base_address" => pd.xpath("baseAddress").text.sub("0X", "0x").downcase,
      }
      registers = []
      for rd in pd.xpath("registers/register") do
        r = {
          "name" => rd.xpath("name").text,
          "desc" => rd.xpath("description").text.delete("\n").squeeze(" "),
          "address_offset" => rd.xpath("addressOffset").text.sub("0X", "0x").downcase,
          "access" => rd.xpath("access").text,
          "size" => rd.xpath("size").text.to_i(16),
          "reset_value" => rd.xpath("resetValue").text,
        }
        fields = []
        for fd in rd.xpath("fields/field") do
          fields << {
            "name" => fd.xpath("name").text,
            "desc" => fd.xpath("description").text.delete("\n").squeeze(" "),
            "bit_offset" => fd.xpath("bitOffset").text.to_i,
            "bit_width" => fd.xpath("bitWidth").text.to_i,
          }
        end
        r["fields"] = fields
        registers << r
      p["registers"] = registers
      end
      peripherals << p
    end
    peripherals
end

def add_reserved_padding(r)
  if r.fields.length == 1
    r.bit_width = r.fields[0].bit_width
    r.type = r.bit_width == 32 ? :int : :mmio_int
    return
  end

  r.fields.sort_by!(&:bit_offset)
  fields = []
  bit_offset = 0
  for f in r.fields do
    if f.bit_offset != bit_offset
      fields << OpenStruct.new({
                                 "name" => "reserved_#{bit_offset}_#{f.bit_offset-1}",
                                 "bit_offset" => bit_offset,
                                 "bit_width" => f.bit_offset - bit_offset,
                               })
    end
    fields << f
    bit_offset = f.bit_offset + f.bit_width
  end
  if bit_offset < r.size
    fields << OpenStruct.new({
                                 "name" => "padding_#{bit_offset}_#{r.size-1}",
                                 "bit_offset" => bit_offset,
                                 "bit_width" => r.size - bit_offset,
                               })
  end
  r.fields = fields
end

peripherals = read_data ARGV[0]
peripherals = peripherals.map do |p|
  p = OpenStruct.new(p)
  p.registers.map! do |r|
    r = OpenStruct.new(r)
    r.address = "0x" + (p.base_address.to_i(16) + r.address_offset.to_i(16)).to_s(16)
    r.fields.map! do |f|
      OpenStruct.new(f)
    end
    add_reserved_padding(r)
    r
  end
  p
end

def generate(peripherals)
  tmpl = <<-EOF
// this file was generated by cgen/gpio.rb
pub const registers = struct {
    <%- for p in peripherals %>
    /// <%= p.desc %>
    pub const <%= p.name %> = struct {
        pub const base_address = <%= p.base_address %>;

        <%- for r in p.registers %>
        /// address: <%= r.address %>
        /// <%= r.desc %>
        <%- case r.type -%>
        <%- when :int -%>
        pub const <%= r.name %> = @intToPtr(*volatile u32, base_address + <%= r.address_offset %>);
        <%- when :mmio_int -%>
        pub const <%= r.name %> = @intToPtr(*volatile MmioInt(32, u<%= r.bit_width %>), base_address + <%= r.address_offset %>);
        <%- else -%>
        pub const <%= r.name %> = @intToPtr(*volatile Mmio(32, packed struct {
            <%- for f in r.fields -%>
            <%- if f.desc -%>
            /// <%= f.desc %>
            <%- end -%>
            <%= f.name %>: u<%= f.bit_width %>,
            <%- end -%>
        }), base_address + <%= r.address_offset %>);
        <%- end -%>
        <%- end -%>
   };
  <%- end -%>
};
  EOF
  puts ERB.new(tmpl, trim_mode: '-').result(binding)
end

#peripherals = peripherals.select{ |p| p.name == "CRC" }
generate peripherals
