#!/usr/bin/env ruby

require 'erb'
require 'json'

# extend string
class String
  def titlecase
    split('_').collect(&:capitalize).join
  end
end

if ARGV[0].nil?
  print "Usage: gpio.rb [chip-name]\n"
  exit 1
end

def read_data(chip)
  filename = "stm32-data/data/chips/STM32F#{chip.upcase}.json"
  file = File.read(filename)

  data = JSON.parse(file, object_class: OpenStruct)
  peripherals = data.cores[0].peripherals

  chip_pins = case chip.downcase
              when '411re'
                # 64 pins chip (R in the name) smt32f411RE
                [['A', 0..15], ['B', [*0..10, *12..15]], ['C', 0..15], ['D', 2..2], ['H', 0..1]]
              end

  [chip_pins, peripherals]
end

chip_pins, peripherals = read_data(ARGV[0])

# prepare spec data in format:
# [
#  {
#    name: PA0
#    peripherals: [
#      {
#        name: TIM2
#        signals: [
#          {
#            analog: false
#            name: CH1
#            af: 1
#          }
#          ...
#        ]
#      }
#      ...
#    ]
#  }
# ]
def pin_specs(chip_pins, peripherals)
  specs = []
  for cp in chip_pins do
    port = cp[0]
    port_pins = cp[1]

    for pin in port_pins do
      spec = OpenStruct.new
      spec.pin = "P#{port}#{pin}"
      spec.peripherals = []

      pin_per = peripherals # peripherals with this pin
                .reject { |per| per.pins.nil? }
                .reject { |per| per.pins.select { |pp| pp.pin == spec.pin }.empty? }
                .uniq

      for per in pin_per do
        sp = OpenStruct.new
        sp.name = per.name
        sp.signals = []
        for pp in per.pins do
          next if pp.pin != spec.pin

          sp_s = OpenStruct.new
          sp_s.name = pp.signal
          sp_s.analog = (per.name.start_with?('ADC') or !pp.af)
          sp_s.af = pp.af
          sp.signals << sp_s
        end
        spec.peripherals << sp
      end
      specs << spec
   end
  end
  specs
end

def peripheral_specs(peripherals)
  specs = []
  for per in peripherals do
    next unless per.pins

    spec = OpenStruct.new
    spec.name = per.name
    spec.signals = []

    signals = per.pins.map { |pin| pin.signal }.uniq
    for signal in signals
      sig = OpenStruct.new
      sig.name = signal
      sig.pins = []
      for pin in per.pins.select { |pin| pin.signal == signal } do
        sig_pin = OpenStruct.new
        sig_pin.name = pin.pin
        sig_pin.analog = (per.name.start_with?('ADC') or !pin.af)
        sig_pin.af = pin.af
        sig.pins << sig_pin
      end
      spec.signals << sig
    end
    specs << spec
  end
  specs
end

def generate(pin_specs, peripheral_specs)
  tmpl = <<~EOF
    // this file was generated by cgen/gpio.rb
      const hal = @import("microzig").hal.gpio;

      pub const gpio = struct {
          <%- for spec in pin_specs -%>
          pub const <%= spec.pin.downcase %> = struct {
              const pin = hal.Pin("<%= spec.pin %>");
              pub const Output = pin.Output;
              pub const Input = pin.Input;
              pub const analog = pin.analog;
              <%- for per in spec.peripherals -%>
              pub const <%= per.name.downcase %> = struct {
              <%- for sig in per.signals -%>
                  <%- if sig.analog -%>
                  pub const <%= sig.name.downcase %> = pin.analog;
                  <%- else -%>
                  pub fn <%= sig.name.downcase %>(comptime c: hal.FunctionConfig) void {
                      pin.Function(<%= sig.af.to_s %>).init(c);
                  }
                  <%- end -%>
              <%- end -%>
              };
              <%- end -%>
          };
          <%- end %>
          <%- for per in peripheral_specs -%>
          pub const <%= per.name.downcase %> = struct {
              <%- for sig in per.signals -%>
              pub const <%= sig.name.downcase %> = struct {
              <%- for pin in sig.pins -%>
                  pub const <%= pin.name.downcase %> = gpio.<%= pin.name.downcase %>.<%= per.name.downcase %>.<%= sig.name.downcase %>;
              <%- end -%>
              };
              <%- end -%>
          };
          <%- end -%>
      };
  EOF
  puts ERB.new(tmpl, trim_mode: '-').result(binding)
end

generate pin_specs(chip_pins, peripherals), peripheral_specs(peripherals)
